// Code generated from parser/presto_parser/parser/SqlBase.g4 by ANTLR 4.8. DO NOT EDIT.

package parser // SqlBase
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 244, 1859,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 3, 2, 3, 2, 3, 2, 3, 3, 3, 3, 3, 3,
	3, 4, 3, 4, 3, 4, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5,
	3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 179, 10, 5, 3, 5, 3, 5, 3, 5, 5, 5, 184,
	10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 190, 10, 5, 3, 5, 3, 5, 5, 5, 194,
	10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5,
	3, 5, 5, 5, 208, 10, 5, 3, 5, 3, 5, 5, 5, 212, 10, 5, 3, 5, 3, 5, 5, 5,
	216, 10, 5, 3, 5, 3, 5, 5, 5, 220, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5,
	3, 5, 5, 5, 228, 10, 5, 3, 5, 3, 5, 5, 5, 232, 10, 5, 3, 5, 5, 5, 235,
	10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 242, 10, 5, 3, 5, 3, 5, 3, 5,
	3, 5, 3, 5, 7, 5, 249, 10, 5, 12, 5, 14, 5, 252, 11, 5, 3, 5, 3, 5, 3,
	5, 5, 5, 257, 10, 5, 3, 5, 3, 5, 5, 5, 261, 10, 5, 3, 5, 3, 5, 3, 5, 3,
	5, 5, 5, 267, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 274, 10, 5, 3,
	5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 283, 10, 5, 3, 5, 3, 5, 3,
	5, 3, 5, 5, 5, 289, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3,
	5, 3, 5, 5, 5, 300, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 307, 10,
	5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 317, 10, 5, 3,
	5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 324, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3,
	5, 3, 5, 5, 5, 332, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 340,
	10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 348, 10, 5, 3, 5, 3, 5,
	3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 7, 5, 358, 10, 5, 12, 5, 14, 5, 361,
	11, 5, 3, 5, 3, 5, 3, 5, 5, 5, 366, 10, 5, 3, 5, 3, 5, 3, 5, 5, 5, 371,
	10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 377, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5,
	3, 5, 3, 5, 3, 5, 5, 5, 386, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5,
	3, 5, 5, 5, 395, 10, 5, 3, 5, 3, 5, 3, 5, 5, 5, 400, 10, 5, 3, 5, 3, 5,
	5, 5, 404, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 412, 10, 5,
	3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 419, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5,
	3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 432, 10, 5, 3, 5, 5, 5,
	435, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 7, 5, 443, 10, 5, 12, 5,
	14, 5, 446, 11, 5, 5, 5, 448, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5,
	455, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 464, 10, 5,
	3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 470, 10, 5, 3, 5, 3, 5, 3, 5, 5, 5, 475,
	10, 5, 3, 5, 3, 5, 5, 5, 479, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5,
	7, 5, 487, 10, 5, 12, 5, 14, 5, 490, 11, 5, 5, 5, 492, 10, 5, 3, 5, 3,
	5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 502, 10, 5, 3, 5, 3, 5, 3,
	5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 7, 5, 513, 10, 5, 12, 5, 14, 5,
	516, 11, 5, 3, 5, 3, 5, 3, 5, 5, 5, 521, 10, 5, 3, 5, 3, 5, 3, 5, 5, 5,
	526, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 532, 10, 5, 3, 5, 3, 5, 3, 5,
	3, 5, 3, 5, 7, 5, 539, 10, 5, 12, 5, 14, 5, 542, 11, 5, 3, 5, 3, 5, 3,
	5, 5, 5, 547, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 554, 10, 5, 3,
	5, 3, 5, 3, 5, 3, 5, 7, 5, 560, 10, 5, 12, 5, 14, 5, 563, 11, 5, 3, 5,
	3, 5, 5, 5, 567, 10, 5, 3, 5, 3, 5, 5, 5, 571, 10, 5, 3, 5, 3, 5, 3, 5,
	3, 5, 3, 5, 3, 5, 5, 5, 579, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 585,
	10, 5, 3, 5, 3, 5, 3, 5, 7, 5, 590, 10, 5, 12, 5, 14, 5, 593, 11, 5, 3,
	5, 3, 5, 5, 5, 597, 10, 5, 3, 5, 3, 5, 5, 5, 601, 10, 5, 3, 5, 3, 5, 3,
	5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 611, 10, 5, 3, 5, 5, 5, 614, 10,
	5, 3, 5, 3, 5, 5, 5, 618, 10, 5, 3, 5, 5, 5, 621, 10, 5, 3, 5, 3, 5, 3,
	5, 3, 5, 7, 5, 627, 10, 5, 12, 5, 14, 5, 630, 11, 5, 3, 5, 3, 5, 5, 5,
	634, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5,
	3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 655, 10, 5,
	3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 661, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5,
	667, 10, 5, 5, 5, 669, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 675, 10, 5,
	3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 681, 10, 5, 5, 5, 683, 10, 5, 3, 5, 3, 5,
	3, 5, 3, 5, 5, 5, 689, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5,
	3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 708,
	10, 5, 3, 5, 3, 5, 3, 5, 5, 5, 713, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5,
	5, 5, 720, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5,
	3, 5, 5, 5, 732, 10, 5, 5, 5, 734, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5,
	3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 7, 5,
	752, 10, 5, 12, 5, 14, 5, 755, 11, 5, 5, 5, 757, 10, 5, 3, 5, 3, 5, 5,
	5, 761, 10, 5, 3, 5, 3, 5, 5, 5, 765, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3,
	5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 7, 5, 781, 10,
	5, 12, 5, 14, 5, 784, 11, 5, 5, 5, 786, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5,
	3, 5, 3, 5, 5, 5, 794, 10, 5, 3, 6, 5, 6, 797, 10, 6, 3, 6, 3, 6, 3, 7,
	3, 7, 5, 7, 803, 10, 7, 3, 7, 3, 7, 3, 7, 7, 7, 808, 10, 7, 12, 7, 14,
	7, 811, 11, 7, 3, 8, 3, 8, 5, 8, 815, 10, 8, 3, 9, 3, 9, 3, 9, 3, 9, 5,
	9, 821, 10, 9, 3, 9, 3, 9, 5, 9, 825, 10, 9, 3, 9, 3, 9, 5, 9, 829, 10,
	9, 3, 10, 3, 10, 3, 10, 3, 10, 5, 10, 835, 10, 10, 3, 11, 3, 11, 3, 11,
	3, 11, 7, 11, 841, 10, 11, 12, 11, 14, 11, 844, 11, 11, 3, 11, 3, 11, 3,
	12, 3, 12, 3, 12, 3, 12, 3, 13, 3, 13, 3, 13, 3, 14, 7, 14, 856, 10, 14,
	12, 14, 14, 14, 859, 11, 14, 3, 15, 3, 15, 3, 15, 3, 15, 5, 15, 865, 10,
	15, 3, 16, 7, 16, 868, 10, 16, 12, 16, 14, 16, 871, 11, 16, 3, 17, 3, 17,
	3, 18, 3, 18, 5, 18, 877, 10, 18, 3, 19, 3, 19, 3, 19, 3, 20, 3, 20, 3,
	20, 5, 20, 885, 10, 20, 3, 21, 3, 21, 5, 21, 889, 10, 21, 3, 22, 3, 22,
	3, 22, 5, 22, 894, 10, 22, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3,
	23, 3, 23, 3, 23, 5, 23, 905, 10, 23, 3, 24, 3, 24, 3, 25, 3, 25, 3, 25,
	3, 25, 3, 25, 3, 25, 7, 25, 915, 10, 25, 12, 25, 14, 25, 918, 11, 25, 5,
	25, 920, 10, 25, 3, 25, 3, 25, 3, 25, 5, 25, 925, 10, 25, 5, 25, 927, 10,
	25, 3, 25, 3, 25, 5, 25, 931, 10, 25, 3, 26, 3, 26, 3, 26, 3, 26, 3, 26,
	3, 26, 5, 26, 939, 10, 26, 3, 26, 3, 26, 3, 26, 3, 26, 5, 26, 945, 10,
	26, 3, 26, 7, 26, 948, 10, 26, 12, 26, 14, 26, 951, 11, 26, 3, 27, 3, 27,
	3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 7, 27, 960, 10, 27, 12, 27, 14, 27,
	963, 11, 27, 3, 27, 3, 27, 3, 27, 3, 27, 5, 27, 969, 10, 27, 3, 28, 3,
	28, 5, 28, 973, 10, 28, 3, 28, 3, 28, 5, 28, 977, 10, 28, 3, 29, 3, 29,
	5, 29, 981, 10, 29, 3, 29, 3, 29, 3, 29, 7, 29, 986, 10, 29, 12, 29, 14,
	29, 989, 11, 29, 3, 29, 3, 29, 3, 29, 3, 29, 7, 29, 995, 10, 29, 12, 29,
	14, 29, 998, 11, 29, 5, 29, 1000, 10, 29, 3, 29, 3, 29, 5, 29, 1004, 10,
	29, 3, 29, 3, 29, 3, 29, 5, 29, 1009, 10, 29, 3, 29, 3, 29, 5, 29, 1013,
	10, 29, 3, 30, 5, 30, 1016, 10, 30, 3, 30, 3, 30, 3, 30, 7, 30, 1021, 10,
	30, 12, 30, 14, 30, 1024, 11, 30, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3,
	31, 7, 31, 1032, 10, 31, 12, 31, 14, 31, 1035, 11, 31, 5, 31, 1037, 10,
	31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 7, 31, 1045, 10, 31, 12,
	31, 14, 31, 1048, 11, 31, 5, 31, 1050, 10, 31, 3, 31, 3, 31, 3, 31, 3,
	31, 3, 31, 3, 31, 3, 31, 7, 31, 1059, 10, 31, 12, 31, 14, 31, 1062, 11,
	31, 3, 31, 3, 31, 5, 31, 1066, 10, 31, 3, 32, 3, 32, 3, 32, 3, 32, 7, 32,
	1072, 10, 32, 12, 32, 14, 32, 1075, 11, 32, 5, 32, 1077, 10, 32, 3, 32,
	3, 32, 5, 32, 1081, 10, 32, 3, 33, 3, 33, 5, 33, 1085, 10, 33, 3, 33, 3,
	33, 3, 33, 3, 33, 3, 33, 3, 34, 3, 34, 3, 35, 3, 35, 5, 35, 1096, 10, 35,
	3, 35, 5, 35, 1099, 10, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 5, 35, 1106,
	10, 35, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36,
	3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 5, 36, 1125, 10,
	36, 7, 36, 1127, 10, 36, 12, 36, 14, 36, 1130, 11, 36, 3, 37, 5, 37, 1133,
	10, 37, 3, 37, 3, 37, 5, 37, 1137, 10, 37, 3, 37, 3, 37, 5, 37, 1141, 10,
	37, 3, 37, 3, 37, 5, 37, 1145, 10, 37, 5, 37, 1147, 10, 37, 3, 38, 3, 38,
	3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 7, 38, 1156, 10, 38, 12, 38, 14, 38,
	1159, 11, 38, 3, 38, 3, 38, 5, 38, 1163, 10, 38, 3, 39, 3, 39, 3, 39, 3,
	39, 3, 39, 3, 39, 3, 39, 5, 39, 1172, 10, 39, 3, 40, 3, 40, 3, 41, 3, 41,
	5, 41, 1178, 10, 41, 3, 41, 3, 41, 5, 41, 1182, 10, 41, 5, 41, 1184, 10,
	41, 3, 42, 3, 42, 3, 42, 3, 42, 7, 42, 1190, 10, 42, 12, 42, 14, 42, 1193,
	11, 42, 3, 42, 3, 42, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43,
	3, 43, 3, 43, 3, 43, 7, 43, 1207, 10, 43, 12, 43, 14, 43, 1210, 11, 43,
	3, 43, 3, 43, 3, 43, 5, 43, 1215, 10, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3,
	43, 3, 43, 3, 43, 3, 43, 3, 43, 5, 43, 1226, 10, 43, 3, 44, 3, 44, 3, 45,
	3, 45, 3, 45, 5, 45, 1233, 10, 45, 3, 45, 3, 45, 5, 45, 1237, 10, 45, 3,
	45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 7, 45, 1245, 10, 45, 12, 45, 14,
	45, 1248, 11, 45, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46,
	3, 46, 3, 46, 5, 46, 1260, 10, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3,
	46, 5, 46, 1268, 10, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 7, 46, 1275,
	10, 46, 12, 46, 14, 46, 1278, 11, 46, 3, 46, 3, 46, 3, 46, 5, 46, 1283,
	10, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 5, 46, 1291, 10, 46,
	3, 46, 3, 46, 3, 46, 3, 46, 5, 46, 1297, 10, 46, 3, 46, 3, 46, 5, 46, 1301,
	10, 46, 3, 46, 3, 46, 3, 46, 5, 46, 1306, 10, 46, 3, 46, 3, 46, 3, 46,
	5, 46, 1311, 10, 46, 3, 47, 3, 47, 3, 47, 3, 47, 5, 47, 1317, 10, 47, 3,
	47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47,
	3, 47, 7, 47, 1331, 10, 47, 12, 47, 14, 47, 1334, 11, 47, 3, 48, 3, 48,
	3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3,
	48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48,
	3, 48, 6, 48, 1360, 10, 48, 13, 48, 14, 48, 1361, 3, 48, 3, 48, 3, 48,
	3, 48, 3, 48, 3, 48, 3, 48, 7, 48, 1371, 10, 48, 12, 48, 14, 48, 1374,
	11, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 5, 48, 1383, 10,
	48, 3, 48, 5, 48, 1386, 10, 48, 3, 48, 3, 48, 3, 48, 5, 48, 1391, 10, 48,
	3, 48, 3, 48, 3, 48, 7, 48, 1396, 10, 48, 12, 48, 14, 48, 1399, 11, 48,
	5, 48, 1401, 10, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 7, 48, 1408, 10,
	48, 12, 48, 14, 48, 1411, 11, 48, 5, 48, 1413, 10, 48, 3, 48, 3, 48, 5,
	48, 1417, 10, 48, 3, 48, 5, 48, 1420, 10, 48, 3, 48, 5, 48, 1423, 10, 48,
	3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 7, 48, 1433, 10,
	48, 12, 48, 14, 48, 1436, 11, 48, 5, 48, 1438, 10, 48, 3, 48, 3, 48, 3,
	48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48,
	3, 48, 3, 48, 6, 48, 1455, 10, 48, 13, 48, 14, 48, 1456, 3, 48, 3, 48,
	5, 48, 1461, 10, 48, 3, 48, 3, 48, 3, 48, 3, 48, 6, 48, 1467, 10, 48, 13,
	48, 14, 48, 1468, 3, 48, 3, 48, 5, 48, 1473, 10, 48, 3, 48, 3, 48, 3, 48,
	3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3,
	48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 7, 48, 1496, 10, 48,
	12, 48, 14, 48, 1499, 11, 48, 5, 48, 1501, 10, 48, 3, 48, 3, 48, 3, 48,
	3, 48, 3, 48, 3, 48, 3, 48, 5, 48, 1510, 10, 48, 3, 48, 3, 48, 3, 48, 3,
	48, 5, 48, 1516, 10, 48, 3, 48, 3, 48, 3, 48, 3, 48, 5, 48, 1522, 10, 48,
	3, 48, 3, 48, 3, 48, 3, 48, 5, 48, 1528, 10, 48, 3, 48, 3, 48, 3, 48, 3,
	48, 3, 48, 3, 48, 3, 48, 3, 48, 5, 48, 1538, 10, 48, 3, 48, 3, 48, 3, 48,
	3, 48, 3, 48, 3, 48, 3, 48, 5, 48, 1547, 10, 48, 3, 48, 3, 48, 3, 48, 3,
	48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48,
	3, 48, 3, 48, 3, 48, 3, 48, 7, 48, 1567, 10, 48, 12, 48, 14, 48, 1570,
	11, 48, 5, 48, 1572, 10, 48, 3, 48, 5, 48, 1575, 10, 48, 3, 48, 3, 48,
	3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 7, 48, 1585, 10, 48, 12, 48,
	14, 48, 1588, 11, 48, 3, 49, 3, 49, 3, 49, 3, 49, 5, 49, 1594, 10, 49,
	5, 49, 1596, 10, 49, 3, 50, 3, 50, 3, 50, 3, 50, 5, 50, 1602, 10, 50, 3,
	51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 5, 51, 1610, 10, 51, 3, 52, 3, 52,
	3, 53, 3, 53, 3, 54, 3, 54, 3, 55, 3, 55, 5, 55, 1620, 10, 55, 3, 55, 3,
	55, 3, 55, 3, 55, 5, 55, 1626, 10, 55, 3, 56, 3, 56, 3, 57, 3, 57, 3, 58,
	3, 58, 3, 58, 3, 58, 7, 58, 1636, 10, 58, 12, 58, 14, 58, 1639, 11, 58,
	5, 58, 1641, 10, 58, 3, 58, 3, 58, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 3,
	59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59,
	3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 7, 59, 1666, 10, 59, 12, 59, 14, 59,
	1669, 11, 59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 7, 59, 1678,
	10, 59, 12, 59, 14, 59, 1681, 11, 59, 3, 59, 3, 59, 5, 59, 1685, 10, 59,
	3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 5, 59, 1692, 10, 59, 3, 59, 3, 59, 7,
	59, 1696, 10, 59, 12, 59, 14, 59, 1699, 11, 59, 3, 60, 3, 60, 5, 60, 1703,
	10, 60, 3, 61, 3, 61, 3, 61, 3, 61, 5, 61, 1709, 10, 61, 3, 62, 3, 62,
	3, 62, 3, 62, 3, 62, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 64, 3,
	64, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64, 7, 64, 1729, 10, 64, 12, 64, 14,
	64, 1732, 11, 64, 5, 64, 1734, 10, 64, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64,
	7, 64, 1741, 10, 64, 12, 64, 14, 64, 1744, 11, 64, 5, 64, 1746, 10, 64,
	3, 64, 5, 64, 1749, 10, 64, 3, 64, 3, 64, 3, 65, 3, 65, 3, 65, 3, 65, 3,
	65, 3, 65, 3, 65, 3, 65, 3, 65, 3, 65, 3, 65, 3, 65, 3, 65, 3, 65, 3, 65,
	3, 65, 5, 65, 1769, 10, 65, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 3,
	66, 3, 66, 3, 66, 5, 66, 1780, 10, 66, 3, 67, 3, 67, 3, 67, 3, 67, 5, 67,
	1786, 10, 67, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 5, 68, 1793, 10, 68, 3,
	69, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 5, 69, 1802, 10, 69, 3, 70,
	3, 70, 3, 70, 3, 70, 3, 70, 5, 70, 1809, 10, 70, 3, 71, 3, 71, 3, 71, 3,
	71, 5, 71, 1815, 10, 71, 3, 72, 3, 72, 3, 72, 7, 72, 1820, 10, 72, 12,
	72, 14, 72, 1823, 11, 72, 3, 73, 3, 73, 3, 73, 5, 73, 1828, 10, 73, 3,
	74, 3, 74, 3, 74, 3, 74, 3, 74, 5, 74, 1835, 10, 74, 3, 75, 3, 75, 3, 75,
	7, 75, 1840, 10, 75, 12, 75, 14, 75, 1843, 11, 75, 3, 76, 3, 76, 3, 76,
	3, 76, 3, 76, 5, 76, 1850, 10, 76, 3, 77, 3, 77, 3, 77, 5, 77, 1855, 10,
	77, 3, 78, 3, 78, 3, 78, 2, 8, 50, 70, 88, 92, 94, 116, 79, 2, 4, 6, 8,
	10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44,
	46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80,
	82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112,
	114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142,
	144, 146, 148, 150, 152, 154, 2, 25, 4, 2, 28, 28, 156, 156, 4, 2, 51,
	51, 97, 97, 4, 2, 75, 75, 89, 89, 4, 2, 63, 63, 90, 90, 3, 2, 165, 166,
	4, 2, 14, 14, 230, 230, 4, 2, 62, 62, 199, 199, 4, 2, 21, 21, 53, 53, 4,
	2, 71, 71, 104, 104, 4, 2, 14, 14, 56, 56, 4, 2, 23, 23, 182, 182, 3, 2,
	221, 222, 3, 2, 223, 225, 3, 2, 215, 220, 5, 2, 14, 14, 18, 18, 177, 177,
	4, 2, 69, 69, 193, 193, 7, 2, 49, 49, 86, 86, 115, 116, 169, 169, 213,
	213, 3, 2, 119, 122, 4, 2, 72, 72, 143, 143, 5, 2, 82, 82, 101, 101, 187,
	187, 6, 2, 57, 57, 98, 98, 112, 112, 204, 204, 4, 2, 132, 132, 212, 212,
	49, 2, 12, 14, 16, 16, 18, 19, 21, 23, 26, 28, 31, 36, 41, 41, 43, 43,
	47, 49, 51, 51, 53, 53, 55, 55, 57, 57, 63, 63, 66, 66, 68, 68, 70, 72,
	74, 74, 77, 82, 86, 88, 90, 90, 92, 92, 95, 95, 97, 98, 100, 101, 103,
	105, 107, 107, 109, 109, 112, 117, 119, 124, 128, 130, 132, 133, 136, 136,
	138, 143, 145, 148, 150, 159, 161, 163, 165, 170, 172, 182, 184, 187, 189,
	192, 194, 195, 197, 198, 201, 202, 204, 204, 206, 207, 211, 214, 2, 2151,
	2, 156, 3, 2, 2, 2, 4, 159, 3, 2, 2, 2, 6, 162, 3, 2, 2, 2, 8, 793, 3,
	2, 2, 2, 10, 796, 3, 2, 2, 2, 12, 800, 3, 2, 2, 2, 14, 814, 3, 2, 2, 2,
	16, 816, 3, 2, 2, 2, 18, 830, 3, 2, 2, 2, 20, 836, 3, 2, 2, 2, 22, 847,
	3, 2, 2, 2, 24, 851, 3, 2, 2, 2, 26, 857, 3, 2, 2, 2, 28, 864, 3, 2, 2,
	2, 30, 869, 3, 2, 2, 2, 32, 872, 3, 2, 2, 2, 34, 876, 3, 2, 2, 2, 36, 878,
	3, 2, 2, 2, 38, 881, 3, 2, 2, 2, 40, 888, 3, 2, 2, 2, 42, 893, 3, 2, 2,
	2, 44, 904, 3, 2, 2, 2, 46, 906, 3, 2, 2, 2, 48, 908, 3, 2, 2, 2, 50, 932,
	3, 2, 2, 2, 52, 968, 3, 2, 2, 2, 54, 970, 3, 2, 2, 2, 56, 978, 3, 2, 2,
	2, 58, 1015, 3, 2, 2, 2, 60, 1065, 3, 2, 2, 2, 62, 1080, 3, 2, 2, 2, 64,
	1082, 3, 2, 2, 2, 66, 1091, 3, 2, 2, 2, 68, 1105, 3, 2, 2, 2, 70, 1107,
	3, 2, 2, 2, 72, 1146, 3, 2, 2, 2, 74, 1162, 3, 2, 2, 2, 76, 1164, 3, 2,
	2, 2, 78, 1173, 3, 2, 2, 2, 80, 1175, 3, 2, 2, 2, 82, 1185, 3, 2, 2, 2,
	84, 1225, 3, 2, 2, 2, 86, 1227, 3, 2, 2, 2, 88, 1236, 3, 2, 2, 2, 90, 1310,
	3, 2, 2, 2, 92, 1316, 3, 2, 2, 2, 94, 1574, 3, 2, 2, 2, 96, 1595, 3, 2,
	2, 2, 98, 1601, 3, 2, 2, 2, 100, 1609, 3, 2, 2, 2, 102, 1611, 3, 2, 2,
	2, 104, 1613, 3, 2, 2, 2, 106, 1615, 3, 2, 2, 2, 108, 1617, 3, 2, 2, 2,
	110, 1627, 3, 2, 2, 2, 112, 1629, 3, 2, 2, 2, 114, 1631, 3, 2, 2, 2, 116,
	1691, 3, 2, 2, 2, 118, 1702, 3, 2, 2, 2, 120, 1708, 3, 2, 2, 2, 122, 1710,
	3, 2, 2, 2, 124, 1715, 3, 2, 2, 2, 126, 1721, 3, 2, 2, 2, 128, 1768, 3,
	2, 2, 2, 130, 1779, 3, 2, 2, 2, 132, 1785, 3, 2, 2, 2, 134, 1792, 3, 2,
	2, 2, 136, 1801, 3, 2, 2, 2, 138, 1808, 3, 2, 2, 2, 140, 1814, 3, 2, 2,
	2, 142, 1816, 3, 2, 2, 2, 144, 1827, 3, 2, 2, 2, 146, 1834, 3, 2, 2, 2,
	148, 1836, 3, 2, 2, 2, 150, 1849, 3, 2, 2, 2, 152, 1854, 3, 2, 2, 2, 154,
	1856, 3, 2, 2, 2, 156, 157, 5, 8, 5, 2, 157, 158, 7, 2, 2, 3, 158, 3, 3,
	2, 2, 2, 159, 160, 5, 86, 44, 2, 160, 161, 7, 2, 2, 3, 161, 5, 3, 2, 2,
	2, 162, 163, 5, 34, 18, 2, 163, 164, 7, 2, 2, 3, 164, 7, 3, 2, 2, 2, 165,
	794, 5, 10, 6, 2, 166, 167, 7, 201, 2, 2, 167, 794, 5, 150, 76, 2, 168,
	169, 7, 201, 2, 2, 169, 170, 5, 150, 76, 2, 170, 171, 7, 3, 2, 2, 171,
	172, 5, 150, 76, 2, 172, 794, 3, 2, 2, 2, 173, 174, 7, 38, 2, 2, 174, 178,
	7, 167, 2, 2, 175, 176, 7, 87, 2, 2, 176, 177, 7, 126, 2, 2, 177, 179,
	7, 65, 2, 2, 178, 175, 3, 2, 2, 2, 178, 179, 3, 2, 2, 2, 179, 180, 3, 2,
	2, 2, 180, 183, 5, 142, 72, 2, 181, 182, 7, 210, 2, 2, 182, 184, 5, 20,
	11, 2, 183, 181, 3, 2, 2, 2, 183, 184, 3, 2, 2, 2, 184, 794, 3, 2, 2, 2,
	185, 186, 7, 58, 2, 2, 186, 189, 7, 167, 2, 2, 187, 188, 7, 87, 2, 2, 188,
	190, 7, 65, 2, 2, 189, 187, 3, 2, 2, 2, 189, 190, 3, 2, 2, 2, 190, 191,
	3, 2, 2, 2, 191, 193, 5, 142, 72, 2, 192, 194, 9, 2, 2, 2, 193, 192, 3,
	2, 2, 2, 193, 194, 3, 2, 2, 2, 194, 794, 3, 2, 2, 2, 195, 196, 7, 15, 2,
	2, 196, 197, 7, 167, 2, 2, 197, 198, 5, 142, 72, 2, 198, 199, 7, 151, 2,
	2, 199, 200, 7, 191, 2, 2, 200, 201, 5, 150, 76, 2, 201, 794, 3, 2, 2,
	2, 202, 203, 7, 38, 2, 2, 203, 207, 7, 183, 2, 2, 204, 205, 7, 87, 2, 2,
	205, 206, 7, 126, 2, 2, 206, 208, 7, 65, 2, 2, 207, 204, 3, 2, 2, 2, 207,
	208, 3, 2, 2, 2, 208, 209, 3, 2, 2, 2, 209, 211, 5, 142, 72, 2, 210, 212,
	5, 82, 42, 2, 211, 210, 3, 2, 2, 2, 211, 212, 3, 2, 2, 2, 212, 215, 3,
	2, 2, 2, 213, 214, 7, 34, 2, 2, 214, 216, 5, 96, 49, 2, 215, 213, 3, 2,
	2, 2, 215, 216, 3, 2, 2, 2, 216, 219, 3, 2, 2, 2, 217, 218, 7, 210, 2,
	2, 218, 220, 5, 20, 11, 2, 219, 217, 3, 2, 2, 2, 219, 220, 3, 2, 2, 2,
	220, 221, 3, 2, 2, 2, 221, 227, 7, 20, 2, 2, 222, 228, 5, 10, 6, 2, 223,
	224, 7, 4, 2, 2, 224, 225, 5, 10, 6, 2, 225, 226, 7, 5, 2, 2, 226, 228,
	3, 2, 2, 2, 227, 222, 3, 2, 2, 2, 227, 223, 3, 2, 2, 2, 228, 234, 3, 2,
	2, 2, 229, 231, 7, 210, 2, 2, 230, 232, 7, 123, 2, 2, 231, 230, 3, 2, 2,
	2, 231, 232, 3, 2, 2, 2, 232, 233, 3, 2, 2, 2, 233, 235, 7, 47, 2, 2, 234,
	229, 3, 2, 2, 2, 234, 235, 3, 2, 2, 2, 235, 794, 3, 2, 2, 2, 236, 237,
	7, 38, 2, 2, 237, 241, 7, 183, 2, 2, 238, 239, 7, 87, 2, 2, 239, 240, 7,
	126, 2, 2, 240, 242, 7, 65, 2, 2, 241, 238, 3, 2, 2, 2, 241, 242, 3, 2,
	2, 2, 242, 243, 3, 2, 2, 2, 243, 244, 5, 142, 72, 2, 244, 245, 7, 4, 2,
	2, 245, 250, 5, 14, 8, 2, 246, 247, 7, 6, 2, 2, 247, 249, 5, 14, 8, 2,
	248, 246, 3, 2, 2, 2, 249, 252, 3, 2, 2, 2, 250, 248, 3, 2, 2, 2, 250,
	251, 3, 2, 2, 2, 251, 253, 3, 2, 2, 2, 252, 250, 3, 2, 2, 2, 253, 256,
	7, 5, 2, 2, 254, 255, 7, 34, 2, 2, 255, 257, 5, 96, 49, 2, 256, 254, 3,
	2, 2, 2, 256, 257, 3, 2, 2, 2, 257, 260, 3, 2, 2, 2, 258, 259, 7, 210,
	2, 2, 259, 261, 5, 20, 11, 2, 260, 258, 3, 2, 2, 2, 260, 261, 3, 2, 2,
	2, 261, 794, 3, 2, 2, 2, 262, 263, 7, 58, 2, 2, 263, 266, 7, 183, 2, 2,
	264, 265, 7, 87, 2, 2, 265, 267, 7, 65, 2, 2, 266, 264, 3, 2, 2, 2, 266,
	267, 3, 2, 2, 2, 267, 268, 3, 2, 2, 2, 268, 794, 5, 142, 72, 2, 269, 270,
	7, 93, 2, 2, 270, 271, 7, 96, 2, 2, 271, 273, 5, 142, 72, 2, 272, 274,
	5, 82, 42, 2, 273, 272, 3, 2, 2, 2, 273, 274, 3, 2, 2, 2, 274, 275, 3,
	2, 2, 2, 275, 276, 5, 10, 6, 2, 276, 794, 3, 2, 2, 2, 277, 278, 7, 52,
	2, 2, 278, 279, 7, 75, 2, 2, 279, 282, 5, 142, 72, 2, 280, 281, 7, 209,
	2, 2, 281, 283, 5, 88, 45, 2, 282, 280, 3, 2, 2, 2, 282, 283, 3, 2, 2,
	2, 283, 794, 3, 2, 2, 2, 284, 285, 7, 15, 2, 2, 285, 288, 7, 183, 2, 2,
	286, 287, 7, 87, 2, 2, 287, 289, 7, 65, 2, 2, 288, 286, 3, 2, 2, 2, 288,
	289, 3, 2, 2, 2, 289, 290, 3, 2, 2, 2, 290, 291, 5, 142, 72, 2, 291, 292,
	7, 151, 2, 2, 292, 293, 7, 191, 2, 2, 293, 294, 5, 142, 72, 2, 294, 794,
	3, 2, 2, 2, 295, 296, 7, 15, 2, 2, 296, 299, 7, 183, 2, 2, 297, 298, 7,
	87, 2, 2, 298, 300, 7, 65, 2, 2, 299, 297, 3, 2, 2, 2, 299, 300, 3, 2,
	2, 2, 300, 301, 3, 2, 2, 2, 301, 302, 5, 142, 72, 2, 302, 303, 7, 151,
	2, 2, 303, 306, 7, 32, 2, 2, 304, 305, 7, 87, 2, 2, 305, 307, 7, 65, 2,
	2, 306, 304, 3, 2, 2, 2, 306, 307, 3, 2, 2, 2, 307, 308, 3, 2, 2, 2, 308,
	309, 5, 150, 76, 2, 309, 310, 7, 191, 2, 2, 310, 311, 5, 150, 76, 2, 311,
	794, 3, 2, 2, 2, 312, 313, 7, 15, 2, 2, 313, 316, 7, 183, 2, 2, 314, 315,
	7, 87, 2, 2, 315, 317, 7, 65, 2, 2, 316, 314, 3, 2, 2, 2, 316, 317, 3,
	2, 2, 2, 317, 318, 3, 2, 2, 2, 318, 319, 5, 142, 72, 2, 319, 320, 7, 58,
	2, 2, 320, 323, 7, 32, 2, 2, 321, 322, 7, 87, 2, 2, 322, 324, 7, 65, 2,
	2, 323, 321, 3, 2, 2, 2, 323, 324, 3, 2, 2, 2, 324, 325, 3, 2, 2, 2, 325,
	326, 5, 142, 72, 2, 326, 794, 3, 2, 2, 2, 327, 328, 7, 15, 2, 2, 328, 331,
	7, 183, 2, 2, 329, 330, 7, 87, 2, 2, 330, 332, 7, 65, 2, 2, 331, 329, 3,
	2, 2, 2, 331, 332, 3, 2, 2, 2, 332, 333, 3, 2, 2, 2, 333, 334, 5, 142,
	72, 2, 334, 335, 7, 12, 2, 2, 335, 339, 7, 32, 2, 2, 336, 337, 7, 87, 2,
	2, 337, 338, 7, 126, 2, 2, 338, 340, 7, 65, 2, 2, 339, 336, 3, 2, 2, 2,
	339, 340, 3, 2, 2, 2, 340, 341, 3, 2, 2, 2, 341, 342, 5, 16, 9, 2, 342,
	794, 3, 2, 2, 2, 343, 344, 7, 16, 2, 2, 344, 347, 5, 142, 72, 2, 345, 346,
	7, 210, 2, 2, 346, 348, 5, 20, 11, 2, 347, 345, 3, 2, 2, 2, 347, 348, 3,
	2, 2, 2, 348, 794, 3, 2, 2, 2, 349, 350, 7, 38, 2, 2, 350, 351, 7, 195,
	2, 2, 351, 352, 5, 142, 72, 2, 352, 365, 7, 20, 2, 2, 353, 354, 7, 4, 2,
	2, 354, 359, 5, 24, 13, 2, 355, 356, 7, 6, 2, 2, 356, 358, 5, 24, 13, 2,
	357, 355, 3, 2, 2, 2, 358, 361, 3, 2, 2, 2, 359, 357, 3, 2, 2, 2, 359,
	360, 3, 2, 2, 2, 360, 362, 3, 2, 2, 2, 361, 359, 3, 2, 2, 2, 362, 363,
	7, 5, 2, 2, 363, 366, 3, 2, 2, 2, 364, 366, 5, 116, 59, 2, 365, 353, 3,
	2, 2, 2, 365, 364, 3, 2, 2, 2, 366, 794, 3, 2, 2, 2, 367, 370, 7, 38, 2,
	2, 368, 369, 7, 134, 2, 2, 369, 371, 7, 153, 2, 2, 370, 368, 3, 2, 2, 2,
	370, 371, 3, 2, 2, 2, 371, 372, 3, 2, 2, 2, 372, 373, 7, 207, 2, 2, 373,
	376, 5, 142, 72, 2, 374, 375, 7, 170, 2, 2, 375, 377, 9, 3, 2, 2, 376,
	374, 3, 2, 2, 2, 376, 377, 3, 2, 2, 2, 377, 378, 3, 2, 2, 2, 378, 379,
	7, 20, 2, 2, 379, 380, 5, 10, 6, 2, 380, 794, 3, 2, 2, 2, 381, 382, 7,
	58, 2, 2, 382, 385, 7, 207, 2, 2, 383, 384, 7, 87, 2, 2, 384, 386, 7, 65,
	2, 2, 385, 383, 3, 2, 2, 2, 385, 386, 3, 2, 2, 2, 386, 387, 3, 2, 2, 2,
	387, 794, 5, 142, 72, 2, 388, 389, 7, 38, 2, 2, 389, 390, 7, 114, 2, 2,
	390, 394, 7, 207, 2, 2, 391, 392, 7, 87, 2, 2, 392, 393, 7, 126, 2, 2,
	393, 395, 7, 65, 2, 2, 394, 391, 3, 2, 2, 2, 394, 395, 3, 2, 2, 2, 395,
	396, 3, 2, 2, 2, 396, 399, 5, 142, 72, 2, 397, 398, 7, 34, 2, 2, 398, 400,
	5, 96, 49, 2, 399, 397, 3, 2, 2, 2, 399, 400, 3, 2, 2, 2, 400, 403, 3,
	2, 2, 2, 401, 402, 7, 210, 2, 2, 402, 404, 5, 20, 11, 2, 403, 401, 3, 2,
	2, 2, 403, 404, 3, 2, 2, 2, 404, 405, 3, 2, 2, 2, 405, 411, 7, 20, 2, 2,
	406, 412, 5, 10, 6, 2, 407, 408, 7, 4, 2, 2, 408, 409, 5, 10, 6, 2, 409,
	410, 7, 5, 2, 2, 410, 412, 3, 2, 2, 2, 411, 406, 3, 2, 2, 2, 411, 407,
	3, 2, 2, 2, 412, 794, 3, 2, 2, 2, 413, 414, 7, 58, 2, 2, 414, 415, 7, 114,
	2, 2, 415, 418, 7, 207, 2, 2, 416, 417, 7, 87, 2, 2, 417, 419, 7, 65, 2,
	2, 418, 416, 3, 2, 2, 2, 418, 419, 3, 2, 2, 2, 419, 420, 3, 2, 2, 2, 420,
	794, 5, 142, 72, 2, 421, 422, 7, 150, 2, 2, 422, 423, 7, 114, 2, 2, 423,
	424, 7, 207, 2, 2, 424, 425, 5, 142, 72, 2, 425, 426, 7, 209, 2, 2, 426,
	427, 5, 88, 45, 2, 427, 794, 3, 2, 2, 2, 428, 431, 7, 38, 2, 2, 429, 430,
	7, 134, 2, 2, 430, 432, 7, 153, 2, 2, 431, 429, 3, 2, 2, 2, 431, 432, 3,
	2, 2, 2, 432, 434, 3, 2, 2, 2, 433, 435, 7, 186, 2, 2, 434, 433, 3, 2,
	2, 2, 434, 435, 3, 2, 2, 2, 435, 436, 3, 2, 2, 2, 436, 437, 7, 77, 2, 2,
	437, 438, 5, 142, 72, 2, 438, 447, 7, 4, 2, 2, 439, 444, 5, 24, 13, 2,
	440, 441, 7, 6, 2, 2, 441, 443, 5, 24, 13, 2, 442, 440, 3, 2, 2, 2, 443,
	446, 3, 2, 2, 2, 444, 442, 3, 2, 2, 2, 444, 445, 3, 2, 2, 2, 445, 448,
	3, 2, 2, 2, 446, 444, 3, 2, 2, 2, 447, 439, 3, 2, 2, 2, 447, 448, 3, 2,
	2, 2, 448, 449, 3, 2, 2, 2, 449, 450, 7, 5, 2, 2, 450, 451, 7, 158, 2,
	2, 451, 454, 5, 116, 59, 2, 452, 453, 7, 34, 2, 2, 453, 455, 5, 96, 49,
	2, 454, 452, 3, 2, 2, 2, 454, 455, 3, 2, 2, 2, 455, 456, 3, 2, 2, 2, 456,
	457, 5, 26, 14, 2, 457, 458, 5, 34, 18, 2, 458, 794, 3, 2, 2, 2, 459, 460,
	7, 15, 2, 2, 460, 461, 7, 77, 2, 2, 461, 463, 5, 142, 72, 2, 462, 464,
	5, 114, 58, 2, 463, 462, 3, 2, 2, 2, 463, 464, 3, 2, 2, 2, 464, 465, 3,
	2, 2, 2, 465, 466, 5, 30, 16, 2, 466, 794, 3, 2, 2, 2, 467, 469, 7, 58,
	2, 2, 468, 470, 7, 186, 2, 2, 469, 468, 3, 2, 2, 2, 469, 470, 3, 2, 2,
	2, 470, 471, 3, 2, 2, 2, 471, 474, 7, 77, 2, 2, 472, 473, 7, 87, 2, 2,
	473, 475, 7, 65, 2, 2, 474, 472, 3, 2, 2, 2, 474, 475, 3, 2, 2, 2, 475,
	476, 3, 2, 2, 2, 476, 478, 5, 142, 72, 2, 477, 479, 5, 114, 58, 2, 478,
	477, 3, 2, 2, 2, 478, 479, 3, 2, 2, 2, 479, 794, 3, 2, 2, 2, 480, 481,
	7, 26, 2, 2, 481, 482, 5, 142, 72, 2, 482, 491, 7, 4, 2, 2, 483, 488, 5,
	138, 70, 2, 484, 485, 7, 6, 2, 2, 485, 487, 5, 138, 70, 2, 486, 484, 3,
	2, 2, 2, 487, 490, 3, 2, 2, 2, 488, 486, 3, 2, 2, 2, 488, 489, 3, 2, 2,
	2, 489, 492, 3, 2, 2, 2, 490, 488, 3, 2, 2, 2, 491, 483, 3, 2, 2, 2, 491,
	492, 3, 2, 2, 2, 492, 493, 3, 2, 2, 2, 493, 494, 7, 5, 2, 2, 494, 794,
	3, 2, 2, 2, 495, 496, 7, 38, 2, 2, 496, 497, 7, 161, 2, 2, 497, 501, 5,
	150, 76, 2, 498, 499, 7, 210, 2, 2, 499, 500, 7, 13, 2, 2, 500, 502, 5,
	144, 73, 2, 501, 498, 3, 2, 2, 2, 501, 502, 3, 2, 2, 2, 502, 794, 3, 2,
	2, 2, 503, 504, 7, 58, 2, 2, 504, 505, 7, 161, 2, 2, 505, 794, 5, 150,
	76, 2, 506, 507, 7, 79, 2, 2, 507, 508, 5, 148, 75, 2, 508, 509, 7, 191,
	2, 2, 509, 514, 5, 146, 74, 2, 510, 511, 7, 6, 2, 2, 511, 513, 5, 146,
	74, 2, 512, 510, 3, 2, 2, 2, 513, 516, 3, 2, 2, 2, 514, 512, 3, 2, 2, 2,
	514, 515, 3, 2, 2, 2, 515, 520, 3, 2, 2, 2, 516, 514, 3, 2, 2, 2, 517,
	518, 7, 210, 2, 2, 518, 519, 7, 13, 2, 2, 519, 521, 7, 133, 2, 2, 520,
	517, 3, 2, 2, 2, 520, 521, 3, 2, 2, 2, 521, 525, 3, 2, 2, 2, 522, 523,
	7, 80, 2, 2, 523, 524, 7, 25, 2, 2, 524, 526, 5, 144, 73, 2, 525, 522,
	3, 2, 2, 2, 525, 526, 3, 2, 2, 2, 526, 794, 3, 2, 2, 2, 527, 531, 7, 159,
	2, 2, 528, 529, 7, 13, 2, 2, 529, 530, 7, 133, 2, 2, 530, 532, 7, 73, 2,
	2, 531, 528, 3, 2, 2, 2, 531, 532, 3, 2, 2, 2, 532, 533, 3, 2, 2, 2, 533,
	534, 5, 148, 75, 2, 534, 535, 7, 75, 2, 2, 535, 540, 5, 146, 74, 2, 536,
	537, 7, 6, 2, 2, 537, 539, 5, 146, 74, 2, 538, 536, 3, 2, 2, 2, 539, 542,
	3, 2, 2, 2, 540, 538, 3, 2, 2, 2, 540, 541, 3, 2, 2, 2, 541, 546, 3, 2,
	2, 2, 542, 540, 3, 2, 2, 2, 543, 544, 7, 80, 2, 2, 544, 545, 7, 25, 2,
	2, 545, 547, 5, 144, 73, 2, 546, 543, 3, 2, 2, 2, 546, 547, 3, 2, 2, 2,
	547, 794, 3, 2, 2, 2, 548, 549, 7, 174, 2, 2, 549, 553, 7, 161, 2, 2, 550,
	554, 7, 14, 2, 2, 551, 554, 7, 124, 2, 2, 552, 554, 5, 150, 76, 2, 553,
	550, 3, 2, 2, 2, 553, 551, 3, 2, 2, 2, 553, 552, 3, 2, 2, 2, 554, 794,
	3, 2, 2, 2, 555, 566, 7, 79, 2, 2, 556, 561, 5, 140, 71, 2, 557, 558, 7,
	6, 2, 2, 558, 560, 5, 140, 71, 2, 559, 557, 3, 2, 2, 2, 560, 563, 3, 2,
	2, 2, 561, 559, 3, 2, 2, 2, 561, 562, 3, 2, 2, 2, 562, 567, 3, 2, 2, 2,
	563, 561, 3, 2, 2, 2, 564, 565, 7, 14, 2, 2, 565, 567, 7, 145, 2, 2, 566,
	556, 3, 2, 2, 2, 566, 564, 3, 2, 2, 2, 567, 568, 3, 2, 2, 2, 568, 570,
	7, 131, 2, 2, 569, 571, 7, 183, 2, 2, 570, 569, 3, 2, 2, 2, 570, 571, 3,
	2, 2, 2, 571, 572, 3, 2, 2, 2, 572, 573, 5, 142, 72, 2, 573, 574, 7, 191,
	2, 2, 574, 578, 5, 146, 74, 2, 575, 576, 7, 210, 2, 2, 576, 577, 7, 79,
	2, 2, 577, 579, 7, 133, 2, 2, 578, 575, 3, 2, 2, 2, 578, 579, 3, 2, 2,
	2, 579, 794, 3, 2, 2, 2, 580, 584, 7, 159, 2, 2, 581, 582, 7, 79, 2, 2,
	582, 583, 7, 133, 2, 2, 583, 585, 7, 73, 2, 2, 584, 581, 3, 2, 2, 2, 584,
	585, 3, 2, 2, 2, 585, 596, 3, 2, 2, 2, 586, 591, 5, 140, 71, 2, 587, 588,
	7, 6, 2, 2, 588, 590, 5, 140, 71, 2, 589, 587, 3, 2, 2, 2, 590, 593, 3,
	2, 2, 2, 591, 589, 3, 2, 2, 2, 591, 592, 3, 2, 2, 2, 592, 597, 3, 2, 2,
	2, 593, 591, 3, 2, 2, 2, 594, 595, 7, 14, 2, 2, 595, 597, 7, 145, 2, 2,
	596, 586, 3, 2, 2, 2, 596, 594, 3, 2, 2, 2, 597, 598, 3, 2, 2, 2, 598,
	600, 7, 131, 2, 2, 599, 601, 7, 183, 2, 2, 600, 599, 3, 2, 2, 2, 600, 601,
	3, 2, 2, 2, 601, 602, 3, 2, 2, 2, 602, 603, 5, 142, 72, 2, 603, 604, 7,
	75, 2, 2, 604, 605, 5, 146, 74, 2, 605, 794, 3, 2, 2, 2, 606, 607, 7, 176,
	2, 2, 607, 613, 7, 81, 2, 2, 608, 610, 7, 131, 2, 2, 609, 611, 7, 183,
	2, 2, 610, 609, 3, 2, 2, 2, 610, 611, 3, 2, 2, 2, 611, 612, 3, 2, 2, 2,
	612, 614, 5, 142, 72, 2, 613, 608, 3, 2, 2, 2, 613, 614, 3, 2, 2, 2, 614,
	794, 3, 2, 2, 2, 615, 617, 7, 66, 2, 2, 616, 618, 7, 16, 2, 2, 617, 616,
	3, 2, 2, 2, 617, 618, 3, 2, 2, 2, 618, 620, 3, 2, 2, 2, 619, 621, 7, 206,
	2, 2, 620, 619, 3, 2, 2, 2, 620, 621, 3, 2, 2, 2, 621, 633, 3, 2, 2, 2,
	622, 623, 7, 4, 2, 2, 623, 628, 5, 132, 67, 2, 624, 625, 7, 6, 2, 2, 625,
	627, 5, 132, 67, 2, 626, 624, 3, 2, 2, 2, 627, 630, 3, 2, 2, 2, 628, 626,
	3, 2, 2, 2, 628, 629, 3, 2, 2, 2, 629, 631, 3, 2, 2, 2, 630, 628, 3, 2,
	2, 2, 631, 632, 7, 5, 2, 2, 632, 634, 3, 2, 2, 2, 633, 622, 3, 2, 2, 2,
	633, 634, 3, 2, 2, 2, 634, 635, 3, 2, 2, 2, 635, 794, 5, 8, 5, 2, 636,
	637, 7, 176, 2, 2, 637, 638, 7, 38, 2, 2, 638, 639, 7, 183, 2, 2, 639,
	794, 5, 142, 72, 2, 640, 641, 7, 176, 2, 2, 641, 642, 7, 38, 2, 2, 642,
	643, 7, 207, 2, 2, 643, 794, 5, 142, 72, 2, 644, 645, 7, 176, 2, 2, 645,
	646, 7, 38, 2, 2, 646, 647, 7, 114, 2, 2, 647, 648, 7, 207, 2, 2, 648,
	794, 5, 142, 72, 2, 649, 650, 7, 176, 2, 2, 650, 651, 7, 38, 2, 2, 651,
	652, 7, 77, 2, 2, 652, 654, 5, 142, 72, 2, 653, 655, 5, 114, 58, 2, 654,
	653, 3, 2, 2, 2, 654, 655, 3, 2, 2, 2, 655, 794, 3, 2, 2, 2, 656, 657,
	7, 176, 2, 2, 657, 660, 7, 184, 2, 2, 658, 659, 9, 4, 2, 2, 659, 661, 5,
	142, 72, 2, 660, 658, 3, 2, 2, 2, 660, 661, 3, 2, 2, 2, 661, 668, 3, 2,
	2, 2, 662, 663, 7, 108, 2, 2, 663, 666, 5, 96, 49, 2, 664, 665, 7, 61,
	2, 2, 665, 667, 5, 96, 49, 2, 666, 664, 3, 2, 2, 2, 666, 667, 3, 2, 2,
	2, 667, 669, 3, 2, 2, 2, 668, 662, 3, 2, 2, 2, 668, 669, 3, 2, 2, 2, 669,
	794, 3, 2, 2, 2, 670, 671, 7, 176, 2, 2, 671, 674, 7, 168, 2, 2, 672, 673,
	9, 4, 2, 2, 673, 675, 5, 150, 76, 2, 674, 672, 3, 2, 2, 2, 674, 675, 3,
	2, 2, 2, 675, 682, 3, 2, 2, 2, 676, 677, 7, 108, 2, 2, 677, 680, 5, 96,
	49, 2, 678, 679, 7, 61, 2, 2, 679, 681, 5, 96, 49, 2, 680, 678, 3, 2, 2,
	2, 680, 681, 3, 2, 2, 2, 681, 683, 3, 2, 2, 2, 682, 676, 3, 2, 2, 2, 682,
	683, 3, 2, 2, 2, 683, 794, 3, 2, 2, 2, 684, 685, 7, 176, 2, 2, 685, 688,
	7, 31, 2, 2, 686, 687, 7, 108, 2, 2, 687, 689, 5, 96, 49, 2, 688, 686,
	3, 2, 2, 2, 688, 689, 3, 2, 2, 2, 689, 794, 3, 2, 2, 2, 690, 691, 7, 176,
	2, 2, 691, 692, 7, 33, 2, 2, 692, 693, 9, 4, 2, 2, 693, 794, 5, 142, 72,
	2, 694, 695, 7, 176, 2, 2, 695, 696, 7, 180, 2, 2, 696, 697, 7, 73, 2,
	2, 697, 794, 5, 142, 72, 2, 698, 699, 7, 176, 2, 2, 699, 700, 7, 180, 2,
	2, 700, 701, 7, 73, 2, 2, 701, 702, 7, 4, 2, 2, 702, 703, 5, 56, 29, 2,
	703, 704, 7, 5, 2, 2, 704, 794, 3, 2, 2, 2, 705, 707, 7, 176, 2, 2, 706,
	708, 7, 41, 2, 2, 707, 706, 3, 2, 2, 2, 707, 708, 3, 2, 2, 2, 708, 709,
	3, 2, 2, 2, 709, 712, 7, 162, 2, 2, 710, 711, 9, 4, 2, 2, 711, 713, 5,
	150, 76, 2, 712, 710, 3, 2, 2, 2, 712, 713, 3, 2, 2, 2, 713, 794, 3, 2,
	2, 2, 714, 715, 7, 176, 2, 2, 715, 716, 7, 161, 2, 2, 716, 719, 7, 81,
	2, 2, 717, 718, 9, 4, 2, 2, 718, 720, 5, 150, 76, 2, 719, 717, 3, 2, 2,
	2, 719, 720, 3, 2, 2, 2, 720, 794, 3, 2, 2, 2, 721, 722, 7, 54, 2, 2, 722,
	794, 5, 142, 72, 2, 723, 724, 7, 53, 2, 2, 724, 794, 5, 142, 72, 2, 725,
	726, 7, 176, 2, 2, 726, 733, 7, 78, 2, 2, 727, 728, 7, 108, 2, 2, 728,
	731, 5, 96, 49, 2, 729, 730, 7, 61, 2, 2, 730, 732, 5, 96, 49, 2, 731,
	729, 3, 2, 2, 2, 731, 732, 3, 2, 2, 2, 732, 734, 3, 2, 2, 2, 733, 727,
	3, 2, 2, 2, 733, 734, 3, 2, 2, 2, 734, 794, 3, 2, 2, 2, 735, 736, 7, 176,
	2, 2, 736, 794, 7, 173, 2, 2, 737, 738, 7, 174, 2, 2, 738, 739, 7, 173,
	2, 2, 739, 740, 5, 142, 72, 2, 740, 741, 7, 215, 2, 2, 741, 742, 5, 86,
	44, 2, 742, 794, 3, 2, 2, 2, 743, 744, 7, 154, 2, 2, 744, 745, 7, 173,
	2, 2, 745, 794, 5, 142, 72, 2, 746, 747, 7, 179, 2, 2, 747, 756, 7, 192,
	2, 2, 748, 753, 5, 134, 68, 2, 749, 750, 7, 6, 2, 2, 750, 752, 5, 134,
	68, 2, 751, 749, 3, 2, 2, 2, 752, 755, 3, 2, 2, 2, 753, 751, 3, 2, 2, 2,
	753, 754, 3, 2, 2, 2, 754, 757, 3, 2, 2, 2, 755, 753, 3, 2, 2, 2, 756,
	748, 3, 2, 2, 2, 756, 757, 3, 2, 2, 2, 757, 794, 3, 2, 2, 2, 758, 760,
	7, 35, 2, 2, 759, 761, 7, 211, 2, 2, 760, 759, 3, 2, 2, 2, 760, 761, 3,
	2, 2, 2, 761, 794, 3, 2, 2, 2, 762, 764, 7, 163, 2, 2, 763, 765, 7, 211,
	2, 2, 764, 763, 3, 2, 2, 2, 764, 765, 3, 2, 2, 2, 765, 794, 3, 2, 2, 2,
	766, 767, 7, 144, 2, 2, 767, 768, 5, 150, 76, 2, 768, 769, 7, 75, 2, 2,
	769, 770, 5, 8, 5, 2, 770, 794, 3, 2, 2, 2, 771, 772, 7, 50, 2, 2, 772,
	773, 7, 144, 2, 2, 773, 794, 5, 150, 76, 2, 774, 775, 7, 64, 2, 2, 775,
	785, 5, 150, 76, 2, 776, 777, 7, 203, 2, 2, 777, 782, 5, 86, 44, 2, 778,
	779, 7, 6, 2, 2, 779, 781, 5, 86, 44, 2, 780, 778, 3, 2, 2, 2, 781, 784,
	3, 2, 2, 2, 782, 780, 3, 2, 2, 2, 782, 783, 3, 2, 2, 2, 783, 786, 3, 2,
	2, 2, 784, 782, 3, 2, 2, 2, 785, 776, 3, 2, 2, 2, 785, 786, 3, 2, 2, 2,
	786, 794, 3, 2, 2, 2, 787, 788, 7, 54, 2, 2, 788, 789, 7, 92, 2, 2, 789,
	794, 5, 150, 76, 2, 790, 791, 7, 54, 2, 2, 791, 792, 7, 138, 2, 2, 792,
	794, 5, 150, 76, 2, 793, 165, 3, 2, 2, 2, 793, 166, 3, 2, 2, 2, 793, 168,
	3, 2, 2, 2, 793, 173, 3, 2, 2, 2, 793, 185, 3, 2, 2, 2, 793, 195, 3, 2,
	2, 2, 793, 202, 3, 2, 2, 2, 793, 236, 3, 2, 2, 2, 793, 262, 3, 2, 2, 2,
	793, 269, 3, 2, 2, 2, 793, 277, 3, 2, 2, 2, 793, 284, 3, 2, 2, 2, 793,
	295, 3, 2, 2, 2, 793, 312, 3, 2, 2, 2, 793, 327, 3, 2, 2, 2, 793, 343,
	3, 2, 2, 2, 793, 349, 3, 2, 2, 2, 793, 367, 3, 2, 2, 2, 793, 381, 3, 2,
	2, 2, 793, 388, 3, 2, 2, 2, 793, 413, 3, 2, 2, 2, 793, 421, 3, 2, 2, 2,
	793, 428, 3, 2, 2, 2, 793, 459, 3, 2, 2, 2, 793, 467, 3, 2, 2, 2, 793,
	480, 3, 2, 2, 2, 793, 495, 3, 2, 2, 2, 793, 503, 3, 2, 2, 2, 793, 506,
	3, 2, 2, 2, 793, 527, 3, 2, 2, 2, 793, 548, 3, 2, 2, 2, 793, 555, 3, 2,
	2, 2, 793, 580, 3, 2, 2, 2, 793, 606, 3, 2, 2, 2, 793, 615, 3, 2, 2, 2,
	793, 636, 3, 2, 2, 2, 793, 640, 3, 2, 2, 2, 793, 644, 3, 2, 2, 2, 793,
	649, 3, 2, 2, 2, 793, 656, 3, 2, 2, 2, 793, 670, 3, 2, 2, 2, 793, 684,
	3, 2, 2, 2, 793, 690, 3, 2, 2, 2, 793, 694, 3, 2, 2, 2, 793, 698, 3, 2,
	2, 2, 793, 705, 3, 2, 2, 2, 793, 714, 3, 2, 2, 2, 793, 721, 3, 2, 2, 2,
	793, 723, 3, 2, 2, 2, 793, 725, 3, 2, 2, 2, 793, 735, 3, 2, 2, 2, 793,
	737, 3, 2, 2, 2, 793, 743, 3, 2, 2, 2, 793, 746, 3, 2, 2, 2, 793, 758,
	3, 2, 2, 2, 793, 762, 3, 2, 2, 2, 793, 766, 3, 2, 2, 2, 793, 771, 3, 2,
	2, 2, 793, 774, 3, 2, 2, 2, 793, 787, 3, 2, 2, 2, 793, 790, 3, 2, 2, 2,
	794, 9, 3, 2, 2, 2, 795, 797, 5, 12, 7, 2, 796, 795, 3, 2, 2, 2, 796, 797,
	3, 2, 2, 2, 797, 798, 3, 2, 2, 2, 798, 799, 5, 48, 25, 2, 799, 11, 3, 2,
	2, 2, 800, 802, 7, 210, 2, 2, 801, 803, 7, 149, 2, 2, 802, 801, 3, 2, 2,
	2, 802, 803, 3, 2, 2, 2, 803, 804, 3, 2, 2, 2, 804, 809, 5, 64, 33, 2,
	805, 806, 7, 6, 2, 2, 806, 808, 5, 64, 33, 2, 807, 805, 3, 2, 2, 2, 808,
	811, 3, 2, 2, 2, 809, 807, 3, 2, 2, 2, 809, 810, 3, 2, 2, 2, 810, 13, 3,
	2, 2, 2, 811, 809, 3, 2, 2, 2, 812, 815, 5, 16, 9, 2, 813, 815, 5, 18,
	10, 2, 814, 812, 3, 2, 2, 2, 814, 813, 3, 2, 2, 2, 815, 15, 3, 2, 2, 2,
	816, 817, 5, 150, 76, 2, 817, 820, 5, 116, 59, 2, 818, 819, 7, 126, 2,
	2, 819, 821, 7, 127, 2, 2, 820, 818, 3, 2, 2, 2, 820, 821, 3, 2, 2, 2,
	821, 824, 3, 2, 2, 2, 822, 823, 7, 34, 2, 2, 823, 825, 5, 96, 49, 2, 824,
	822, 3, 2, 2, 2, 824, 825, 3, 2, 2, 2, 825, 828, 3, 2, 2, 2, 826, 827,
	7, 210, 2, 2, 827, 829, 5, 20, 11, 2, 828, 826, 3, 2, 2, 2, 828, 829, 3,
	2, 2, 2, 829, 17, 3, 2, 2, 2, 830, 831, 7, 108, 2, 2, 831, 834, 5, 142,
	72, 2, 832, 833, 9, 5, 2, 2, 833, 835, 7, 146, 2, 2, 834, 832, 3, 2, 2,
	2, 834, 835, 3, 2, 2, 2, 835, 19, 3, 2, 2, 2, 836, 837, 7, 4, 2, 2, 837,
	842, 5, 22, 12, 2, 838, 839, 7, 6, 2, 2, 839, 841, 5, 22, 12, 2, 840, 838,
	3, 2, 2, 2, 841, 844, 3, 2, 2, 2, 842, 840, 3, 2, 2, 2, 842, 843, 3, 2,
	2, 2, 843, 845, 3, 2, 2, 2, 844, 842, 3, 2, 2, 2, 845, 846, 7, 5, 2, 2,
	846, 21, 3, 2, 2, 2, 847, 848, 5, 150, 76, 2, 848, 849, 7, 215, 2, 2, 849,
	850, 5, 86, 44, 2, 850, 23, 3, 2, 2, 2, 851, 852, 5, 150, 76, 2, 852, 853,
	5, 116, 59, 2, 853, 25, 3, 2, 2, 2, 854, 856, 5, 28, 15, 2, 855, 854, 3,
	2, 2, 2, 856, 859, 3, 2, 2, 2, 857, 855, 3, 2, 2, 2, 857, 858, 3, 2, 2,
	2, 858, 27, 3, 2, 2, 2, 859, 857, 3, 2, 2, 2, 860, 861, 7, 103, 2, 2, 861,
	865, 5, 40, 21, 2, 862, 865, 5, 42, 22, 2, 863, 865, 5, 44, 23, 2, 864,
	860, 3, 2, 2, 2, 864, 862, 3, 2, 2, 2, 864, 863, 3, 2, 2, 2, 865, 29, 3,
	2, 2, 2, 866, 868, 5, 32, 17, 2, 867, 866, 3, 2, 2, 2, 868, 871, 3, 2,
	2, 2, 869, 867, 3, 2, 2, 2, 869, 870, 3, 2, 2, 2, 870, 31, 3, 2, 2, 2,
	871, 869, 3, 2, 2, 2, 872, 873, 5, 44, 23, 2, 873, 33, 3, 2, 2, 2, 874,
	877, 5, 36, 19, 2, 875, 877, 5, 38, 20, 2, 876, 874, 3, 2, 2, 2, 876, 875,
	3, 2, 2, 2, 877, 35, 3, 2, 2, 2, 878, 879, 7, 157, 2, 2, 879, 880, 5, 86,
	44, 2, 880, 37, 3, 2, 2, 2, 881, 884, 7, 68, 2, 2, 882, 883, 7, 117, 2,
	2, 883, 885, 5, 46, 24, 2, 884, 882, 3, 2, 2, 2, 884, 885, 3, 2, 2, 2,
	885, 39, 3, 2, 2, 2, 886, 889, 7, 178, 2, 2, 887, 889, 5, 150, 76, 2, 888,
	886, 3, 2, 2, 2, 888, 887, 3, 2, 2, 2, 889, 41, 3, 2, 2, 2, 890, 894, 7,
	55, 2, 2, 891, 892, 7, 126, 2, 2, 892, 894, 7, 55, 2, 2, 893, 890, 3, 2,
	2, 2, 893, 891, 3, 2, 2, 2, 894, 43, 3, 2, 2, 2, 895, 896, 7, 158, 2, 2,
	896, 897, 7, 127, 2, 2, 897, 898, 7, 131, 2, 2, 898, 899, 7, 127, 2, 2,
	899, 905, 7, 92, 2, 2, 900, 901, 7, 27, 2, 2, 901, 902, 7, 131, 2, 2, 902,
	903, 7, 127, 2, 2, 903, 905, 7, 92, 2, 2, 904, 895, 3, 2, 2, 2, 904, 900,
	3, 2, 2, 2, 905, 45, 3, 2, 2, 2, 906, 907, 5, 150, 76, 2, 907, 47, 3, 2,
	2, 2, 908, 919, 5, 50, 26, 2, 909, 910, 7, 135, 2, 2, 910, 911, 7, 25,
	2, 2, 911, 916, 5, 54, 28, 2, 912, 913, 7, 6, 2, 2, 913, 915, 5, 54, 28,
	2, 914, 912, 3, 2, 2, 2, 915, 918, 3, 2, 2, 2, 916, 914, 3, 2, 2, 2, 916,
	917, 3, 2, 2, 2, 917, 920, 3, 2, 2, 2, 918, 916, 3, 2, 2, 2, 919, 909,
	3, 2, 2, 2, 919, 920, 3, 2, 2, 2, 920, 926, 3, 2, 2, 2, 921, 922, 7, 130,
	2, 2, 922, 924, 7, 230, 2, 2, 923, 925, 9, 6, 2, 2, 924, 923, 3, 2, 2,
	2, 924, 925, 3, 2, 2, 2, 925, 927, 3, 2, 2, 2, 926, 921, 3, 2, 2, 2, 926,
	927, 3, 2, 2, 2, 927, 930, 3, 2, 2, 2, 928, 929, 7, 109, 2, 2, 929, 931,
	9, 7, 2, 2, 930, 928, 3, 2, 2, 2, 930, 931, 3, 2, 2, 2, 931, 49, 3, 2,
	2, 2, 932, 933, 8, 26, 1, 2, 933, 934, 5, 52, 27, 2, 934, 949, 3, 2, 2,
	2, 935, 936, 12, 4, 2, 2, 936, 938, 7, 94, 2, 2, 937, 939, 5, 66, 34, 2,
	938, 937, 3, 2, 2, 2, 938, 939, 3, 2, 2, 2, 939, 940, 3, 2, 2, 2, 940,
	948, 5, 50, 26, 5, 941, 942, 12, 3, 2, 2, 942, 944, 9, 8, 2, 2, 943, 945,
	5, 66, 34, 2, 944, 943, 3, 2, 2, 2, 944, 945, 3, 2, 2, 2, 945, 946, 3,
	2, 2, 2, 946, 948, 5, 50, 26, 4, 947, 935, 3, 2, 2, 2, 947, 941, 3, 2,
	2, 2, 948, 951, 3, 2, 2, 2, 949, 947, 3, 2, 2, 2, 949, 950, 3, 2, 2, 2,
	950, 51, 3, 2, 2, 2, 951, 949, 3, 2, 2, 2, 952, 969, 5, 56, 29, 2, 953,
	954, 7, 183, 2, 2, 954, 969, 5, 142, 72, 2, 955, 956, 7, 205, 2, 2, 956,
	961, 5, 86, 44, 2, 957, 958, 7, 6, 2, 2, 958, 960, 5, 86, 44, 2, 959, 957,
	3, 2, 2, 2, 960, 963, 3, 2, 2, 2, 961, 959, 3, 2, 2, 2, 961, 962, 3, 2,
	2, 2, 962, 969, 3, 2, 2, 2, 963, 961, 3, 2, 2, 2, 964, 965, 7, 4, 2, 2,
	965, 966, 5, 48, 25, 2, 966, 967, 7, 5, 2, 2, 967, 969, 3, 2, 2, 2, 968,
	952, 3, 2, 2, 2, 968, 953, 3, 2, 2, 2, 968, 955, 3, 2, 2, 2, 968, 964,
	3, 2, 2, 2, 969, 53, 3, 2, 2, 2, 970, 972, 5, 86, 44, 2, 971, 973, 9, 9,
	2, 2, 972, 971, 3, 2, 2, 2, 972, 973, 3, 2, 2, 2, 973, 976, 3, 2, 2, 2,
	974, 975, 7, 129, 2, 2, 975, 977, 9, 10, 2, 2, 976, 974, 3, 2, 2, 2, 976,
	977, 3, 2, 2, 2, 977, 55, 3, 2, 2, 2, 978, 980, 7, 171, 2, 2, 979, 981,
	5, 66, 34, 2, 980, 979, 3, 2, 2, 2, 980, 981, 3, 2, 2, 2, 981, 982, 3,
	2, 2, 2, 982, 987, 5, 68, 35, 2, 983, 984, 7, 6, 2, 2, 984, 986, 5, 68,
	35, 2, 985, 983, 3, 2, 2, 2, 986, 989, 3, 2, 2, 2, 987, 985, 3, 2, 2, 2,
	987, 988, 3, 2, 2, 2, 988, 999, 3, 2, 2, 2, 989, 987, 3, 2, 2, 2, 990,
	991, 7, 75, 2, 2, 991, 996, 5, 70, 36, 2, 992, 993, 7, 6, 2, 2, 993, 995,
	5, 70, 36, 2, 994, 992, 3, 2, 2, 2, 995, 998, 3, 2, 2, 2, 996, 994, 3,
	2, 2, 2, 996, 997, 3, 2, 2, 2, 997, 1000, 3, 2, 2, 2, 998, 996, 3, 2, 2,
	2, 999, 990, 3, 2, 2, 2, 999, 1000, 3, 2, 2, 2, 1000, 1003, 3, 2, 2, 2,
	1001, 1002, 7, 209, 2, 2, 1002, 1004, 5, 88, 45, 2, 1003, 1001, 3, 2, 2,
	2, 1003, 1004, 3, 2, 2, 2, 1004, 1008, 3, 2, 2, 2, 1005, 1006, 7, 83, 2,
	2, 1006, 1007, 7, 25, 2, 2, 1007, 1009, 5, 58, 30, 2, 1008, 1005, 3, 2,
	2, 2, 1008, 1009, 3, 2, 2, 2, 1009, 1012, 3, 2, 2, 2, 1010, 1011, 7, 85,
	2, 2, 1011, 1013, 5, 88, 45, 2, 1012, 1010, 3, 2, 2, 2, 1012, 1013, 3,
	2, 2, 2, 1013, 57, 3, 2, 2, 2, 1014, 1016, 5, 66, 34, 2, 1015, 1014, 3,
	2, 2, 2, 1015, 1016, 3, 2, 2, 2, 1016, 1017, 3, 2, 2, 2, 1017, 1022, 5,
	60, 31, 2, 1018, 1019, 7, 6, 2, 2, 1019, 1021, 5, 60, 31, 2, 1020, 1018,
	3, 2, 2, 2, 1021, 1024, 3, 2, 2, 2, 1022, 1020, 3, 2, 2, 2, 1022, 1023,
	3, 2, 2, 2, 1023, 59, 3, 2, 2, 2, 1024, 1022, 3, 2, 2, 2, 1025, 1066, 5,
	62, 32, 2, 1026, 1027, 7, 164, 2, 2, 1027, 1036, 7, 4, 2, 2, 1028, 1033,
	5, 86, 44, 2, 1029, 1030, 7, 6, 2, 2, 1030, 1032, 5, 86, 44, 2, 1031, 1029,
	3, 2, 2, 2, 1032, 1035, 3, 2, 2, 2, 1033, 1031, 3, 2, 2, 2, 1033, 1034,
	3, 2, 2, 2, 1034, 1037, 3, 2, 2, 2, 1035, 1033, 3, 2, 2, 2, 1036, 1028,
	3, 2, 2, 2, 1036, 1037, 3, 2, 2, 2, 1037, 1038, 3, 2, 2, 2, 1038, 1066,
	7, 5, 2, 2, 1039, 1040, 7, 40, 2, 2, 1040, 1049, 7, 4, 2, 2, 1041, 1046,
	5, 86, 44, 2, 1042, 1043, 7, 6, 2, 2, 1043, 1045, 5, 86, 44, 2, 1044, 1042,
	3, 2, 2, 2, 1045, 1048, 3, 2, 2, 2, 1046, 1044, 3, 2, 2, 2, 1046, 1047,
	3, 2, 2, 2, 1047, 1050, 3, 2, 2, 2, 1048, 1046, 3, 2, 2, 2, 1049, 1041,
	3, 2, 2, 2, 1049, 1050, 3, 2, 2, 2, 1050, 1051, 3, 2, 2, 2, 1051, 1066,
	7, 5, 2, 2, 1052, 1053, 7, 84, 2, 2, 1053, 1054, 7, 175, 2, 2, 1054, 1055,
	7, 4, 2, 2, 1055, 1060, 5, 62, 32, 2, 1056, 1057, 7, 6, 2, 2, 1057, 1059,
	5, 62, 32, 2, 1058, 1056, 3, 2, 2, 2, 1059, 1062, 3, 2, 2, 2, 1060, 1058,
	3, 2, 2, 2, 1060, 1061, 3, 2, 2, 2, 1061, 1063, 3, 2, 2, 2, 1062, 1060,
	3, 2, 2, 2, 1063, 1064, 7, 5, 2, 2, 1064, 1066, 3, 2, 2, 2, 1065, 1025,
	3, 2, 2, 2, 1065, 1026, 3, 2, 2, 2, 1065, 1039, 3, 2, 2, 2, 1065, 1052,
	3, 2, 2, 2, 1066, 61, 3, 2, 2, 2, 1067, 1076, 7, 4, 2, 2, 1068, 1073, 5,
	86, 44, 2, 1069, 1070, 7, 6, 2, 2, 1070, 1072, 5, 86, 44, 2, 1071, 1069,
	3, 2, 2, 2, 1072, 1075, 3, 2, 2, 2, 1073, 1071, 3, 2, 2, 2, 1073, 1074,
	3, 2, 2, 2, 1074, 1077, 3, 2, 2, 2, 1075, 1073, 3, 2, 2, 2, 1076, 1068,
	3, 2, 2, 2, 1076, 1077, 3, 2, 2, 2, 1077, 1078, 3, 2, 2, 2, 1078, 1081,
	7, 5, 2, 2, 1079, 1081, 5, 86, 44, 2, 1080, 1067, 3, 2, 2, 2, 1080, 1079,
	3, 2, 2, 2, 1081, 63, 3, 2, 2, 2, 1082, 1084, 5, 150, 76, 2, 1083, 1085,
	5, 82, 42, 2, 1084, 1083, 3, 2, 2, 2, 1084, 1085, 3, 2, 2, 2, 1085, 1086,
	3, 2, 2, 2, 1086, 1087, 7, 20, 2, 2, 1087, 1088, 7, 4, 2, 2, 1088, 1089,
	5, 10, 6, 2, 1089, 1090, 7, 5, 2, 2, 1090, 65, 3, 2, 2, 2, 1091, 1092,
	9, 11, 2, 2, 1092, 67, 3, 2, 2, 2, 1093, 1098, 5, 86, 44, 2, 1094, 1096,
	7, 20, 2, 2, 1095, 1094, 3, 2, 2, 2, 1095, 1096, 3, 2, 2, 2, 1096, 1097,
	3, 2, 2, 2, 1097, 1099, 5, 150, 76, 2, 1098, 1095, 3, 2, 2, 2, 1098, 1099,
	3, 2, 2, 2, 1099, 1106, 3, 2, 2, 2, 1100, 1101, 5, 142, 72, 2, 1101, 1102,
	7, 3, 2, 2, 1102, 1103, 7, 223, 2, 2, 1103, 1106, 3, 2, 2, 2, 1104, 1106,
	7, 223, 2, 2, 1105, 1093, 3, 2, 2, 2, 1105, 1100, 3, 2, 2, 2, 1105, 1104,
	3, 2, 2, 2, 1106, 69, 3, 2, 2, 2, 1107, 1108, 8, 36, 1, 2, 1108, 1109,
	5, 76, 39, 2, 1109, 1128, 3, 2, 2, 2, 1110, 1124, 12, 4, 2, 2, 1111, 1112,
	7, 39, 2, 2, 1112, 1113, 7, 102, 2, 2, 1113, 1125, 5, 76, 39, 2, 1114,
	1115, 5, 72, 37, 2, 1115, 1116, 7, 102, 2, 2, 1116, 1117, 5, 70, 36, 2,
	1117, 1118, 5, 74, 38, 2, 1118, 1125, 3, 2, 2, 2, 1119, 1120, 7, 118, 2,
	2, 1120, 1121, 5, 72, 37, 2, 1121, 1122, 7, 102, 2, 2, 1122, 1123, 5, 76,
	39, 2, 1123, 1125, 3, 2, 2, 2, 1124, 1111, 3, 2, 2, 2, 1124, 1114, 3, 2,
	2, 2, 1124, 1119, 3, 2, 2, 2, 1125, 1127, 3, 2, 2, 2, 1126, 1110, 3, 2,
	2, 2, 1127, 1130, 3, 2, 2, 2, 1128, 1126, 3, 2, 2, 2, 1128, 1129, 3, 2,
	2, 2, 1129, 71, 3, 2, 2, 2, 1130, 1128, 3, 2, 2, 2, 1131, 1133, 7, 91,
	2, 2, 1132, 1131, 3, 2, 2, 2, 1132, 1133, 3, 2, 2, 2, 1133, 1147, 3, 2,
	2, 2, 1134, 1136, 7, 106, 2, 2, 1135, 1137, 7, 137, 2, 2, 1136, 1135, 3,
	2, 2, 2, 1136, 1137, 3, 2, 2, 2, 1137, 1147, 3, 2, 2, 2, 1138, 1140, 7,
	160, 2, 2, 1139, 1141, 7, 137, 2, 2, 1140, 1139, 3, 2, 2, 2, 1140, 1141,
	3, 2, 2, 2, 1141, 1147, 3, 2, 2, 2, 1142, 1144, 7, 76, 2, 2, 1143, 1145,
	7, 137, 2, 2, 1144, 1143, 3, 2, 2, 2, 1144, 1145, 3, 2, 2, 2, 1145, 1147,
	3, 2, 2, 2, 1146, 1132, 3, 2, 2, 2, 1146, 1134, 3, 2, 2, 2, 1146, 1138,
	3, 2, 2, 2, 1146, 1142, 3, 2, 2, 2, 1147, 73, 3, 2, 2, 2, 1148, 1149, 7,
	131, 2, 2, 1149, 1163, 5, 88, 45, 2, 1150, 1151, 7, 203, 2, 2, 1151, 1152,
	7, 4, 2, 2, 1152, 1157, 5, 150, 76, 2, 1153, 1154, 7, 6, 2, 2, 1154, 1156,
	5, 150, 76, 2, 1155, 1153, 3, 2, 2, 2, 1156, 1159, 3, 2, 2, 2, 1157, 1155,
	3, 2, 2, 2, 1157, 1158, 3, 2, 2, 2, 1158, 1160, 3, 2, 2, 2, 1159, 1157,
	3, 2, 2, 2, 1160, 1161, 7, 5, 2, 2, 1161, 1163, 3, 2, 2, 2, 1162, 1148,
	3, 2, 2, 2, 1162, 1150, 3, 2, 2, 2, 1163, 75, 3, 2, 2, 2, 1164, 1171, 5,
	80, 41, 2, 1165, 1166, 7, 185, 2, 2, 1166, 1167, 5, 78, 40, 2, 1167, 1168,
	7, 4, 2, 2, 1168, 1169, 5, 86, 44, 2, 1169, 1170, 7, 5, 2, 2, 1170, 1172,
	3, 2, 2, 2, 1171, 1165, 3, 2, 2, 2, 1171, 1172, 3, 2, 2, 2, 1172, 77, 3,
	2, 2, 2, 1173, 1174, 9, 12, 2, 2, 1174, 79, 3, 2, 2, 2, 1175, 1183, 5,
	84, 43, 2, 1176, 1178, 7, 20, 2, 2, 1177, 1176, 3, 2, 2, 2, 1177, 1178,
	3, 2, 2, 2, 1178, 1179, 3, 2, 2, 2, 1179, 1181, 5, 150, 76, 2, 1180, 1182,
	5, 82, 42, 2, 1181, 1180, 3, 2, 2, 2, 1181, 1182, 3, 2, 2, 2, 1182, 1184,
	3, 2, 2, 2, 1183, 1177, 3, 2, 2, 2, 1183, 1184, 3, 2, 2, 2, 1184, 81, 3,
	2, 2, 2, 1185, 1186, 7, 4, 2, 2, 1186, 1191, 5, 150, 76, 2, 1187, 1188,
	7, 6, 2, 2, 1188, 1190, 5, 150, 76, 2, 1189, 1187, 3, 2, 2, 2, 1190, 1193,
	3, 2, 2, 2, 1191, 1189, 3, 2, 2, 2, 1191, 1192, 3, 2, 2, 2, 1192, 1194,
	3, 2, 2, 2, 1193, 1191, 3, 2, 2, 2, 1194, 1195, 7, 5, 2, 2, 1195, 83, 3,
	2, 2, 2, 1196, 1226, 5, 142, 72, 2, 1197, 1198, 7, 4, 2, 2, 1198, 1199,
	5, 10, 6, 2, 1199, 1200, 7, 5, 2, 2, 1200, 1226, 3, 2, 2, 2, 1201, 1202,
	7, 200, 2, 2, 1202, 1203, 7, 4, 2, 2, 1203, 1208, 5, 86, 44, 2, 1204, 1205,
	7, 6, 2, 2, 1205, 1207, 5, 86, 44, 2, 1206, 1204, 3, 2, 2, 2, 1207, 1210,
	3, 2, 2, 2, 1208, 1206, 3, 2, 2, 2, 1208, 1209, 3, 2, 2, 2, 1209, 1211,
	3, 2, 2, 2, 1210, 1208, 3, 2, 2, 2, 1211, 1214, 7, 5, 2, 2, 1212, 1213,
	7, 210, 2, 2, 1213, 1215, 7, 136, 2, 2, 1214, 1212, 3, 2, 2, 2, 1214, 1215,
	3, 2, 2, 2, 1215, 1226, 3, 2, 2, 2, 1216, 1217, 7, 105, 2, 2, 1217, 1218,
	7, 4, 2, 2, 1218, 1219, 5, 10, 6, 2, 1219, 1220, 7, 5, 2, 2, 1220, 1226,
	3, 2, 2, 2, 1221, 1222, 7, 4, 2, 2, 1222, 1223, 5, 70, 36, 2, 1223, 1224,
	7, 5, 2, 2, 1224, 1226, 3, 2, 2, 2, 1225, 1196, 3, 2, 2, 2, 1225, 1197,
	3, 2, 2, 2, 1225, 1201, 3, 2, 2, 2, 1225, 1216, 3, 2, 2, 2, 1225, 1221,
	3, 2, 2, 2, 1226, 85, 3, 2, 2, 2, 1227, 1228, 5, 88, 45, 2, 1228, 87, 3,
	2, 2, 2, 1229, 1230, 8, 45, 1, 2, 1230, 1232, 5, 92, 47, 2, 1231, 1233,
	5, 90, 46, 2, 1232, 1231, 3, 2, 2, 2, 1232, 1233, 3, 2, 2, 2, 1233, 1237,
	3, 2, 2, 2, 1234, 1235, 7, 126, 2, 2, 1235, 1237, 5, 88, 45, 5, 1236, 1229,
	3, 2, 2, 2, 1236, 1234, 3, 2, 2, 2, 1237, 1246, 3, 2, 2, 2, 1238, 1239,
	12, 4, 2, 2, 1239, 1240, 7, 17, 2, 2, 1240, 1245, 5, 88, 45, 5, 1241, 1242,
	12, 3, 2, 2, 1242, 1243, 7, 134, 2, 2, 1243, 1245, 5, 88, 45, 4, 1244,
	1238, 3, 2, 2, 2, 1244, 1241, 3, 2, 2, 2, 1245, 1248, 3, 2, 2, 2, 1246,
	1244, 3, 2, 2, 2, 1246, 1247, 3, 2, 2, 2, 1247, 89, 3, 2, 2, 2, 1248, 1246,
	3, 2, 2, 2, 1249, 1250, 5, 102, 52, 2, 1250, 1251, 5, 92, 47, 2, 1251,
	1311, 3, 2, 2, 2, 1252, 1253, 5, 102, 52, 2, 1253, 1254, 5, 104, 53, 2,
	1254, 1255, 7, 4, 2, 2, 1255, 1256, 5, 10, 6, 2, 1256, 1257, 7, 5, 2, 2,
	1257, 1311, 3, 2, 2, 2, 1258, 1260, 7, 126, 2, 2, 1259, 1258, 3, 2, 2,
	2, 1259, 1260, 3, 2, 2, 2, 1260, 1261, 3, 2, 2, 2, 1261, 1262, 7, 24, 2,
	2, 1262, 1263, 5, 92, 47, 2, 1263, 1264, 7, 17, 2, 2, 1264, 1265, 5, 92,
	47, 2, 1265, 1311, 3, 2, 2, 2, 1266, 1268, 7, 126, 2, 2, 1267, 1266, 3,
	2, 2, 2, 1267, 1268, 3, 2, 2, 2, 1268, 1269, 3, 2, 2, 2, 1269, 1270, 7,
	89, 2, 2, 1270, 1271, 7, 4, 2, 2, 1271, 1276, 5, 86, 44, 2, 1272, 1273,
	7, 6, 2, 2, 1273, 1275, 5, 86, 44, 2, 1274, 1272, 3, 2, 2, 2, 1275, 1278,
	3, 2, 2, 2, 1276, 1274, 3, 2, 2, 2, 1276, 1277, 3, 2, 2, 2, 1277, 1279,
	3, 2, 2, 2, 1278, 1276, 3, 2, 2, 2, 1279, 1280, 7, 5, 2, 2, 1280, 1311,
	3, 2, 2, 2, 1281, 1283, 7, 126, 2, 2, 1282, 1281, 3, 2, 2, 2, 1282, 1283,
	3, 2, 2, 2, 1283, 1284, 3, 2, 2, 2, 1284, 1285, 7, 89, 2, 2, 1285, 1286,
	7, 4, 2, 2, 1286, 1287, 5, 10, 6, 2, 1287, 1288, 7, 5, 2, 2, 1288, 1311,
	3, 2, 2, 2, 1289, 1291, 7, 126, 2, 2, 1290, 1289, 3, 2, 2, 2, 1290, 1291,
	3, 2, 2, 2, 1291, 1292, 3, 2, 2, 2, 1292, 1293, 7, 108, 2, 2, 1293, 1296,
	5, 92, 47, 2, 1294, 1295, 7, 61, 2, 2, 1295, 1297, 5, 92, 47, 2, 1296,
	1294, 3, 2, 2, 2, 1296, 1297, 3, 2, 2, 2, 1297, 1311, 3, 2, 2, 2, 1298,
	1300, 7, 99, 2, 2, 1299, 1301, 7, 126, 2, 2, 1300, 1299, 3, 2, 2, 2, 1300,
	1301, 3, 2, 2, 2, 1301, 1302, 3, 2, 2, 2, 1302, 1311, 7, 127, 2, 2, 1303,
	1305, 7, 99, 2, 2, 1304, 1306, 7, 126, 2, 2, 1305, 1304, 3, 2, 2, 2, 1305,
	1306, 3, 2, 2, 2, 1306, 1307, 3, 2, 2, 2, 1307, 1308, 7, 56, 2, 2, 1308,
	1309, 7, 75, 2, 2, 1309, 1311, 5, 92, 47, 2, 1310, 1249, 3, 2, 2, 2, 1310,
	1252, 3, 2, 2, 2, 1310, 1259, 3, 2, 2, 2, 1310, 1267, 3, 2, 2, 2, 1310,
	1282, 3, 2, 2, 2, 1310, 1290, 3, 2, 2, 2, 1310, 1298, 3, 2, 2, 2, 1310,
	1303, 3, 2, 2, 2, 1311, 91, 3, 2, 2, 2, 1312, 1313, 8, 47, 1, 2, 1313,
	1317, 5, 94, 48, 2, 1314, 1315, 9, 13, 2, 2, 1315, 1317, 5, 92, 47, 6,
	1316, 1312, 3, 2, 2, 2, 1316, 1314, 3, 2, 2, 2, 1317, 1332, 3, 2, 2, 2,
	1318, 1319, 12, 5, 2, 2, 1319, 1320, 9, 14, 2, 2, 1320, 1331, 5, 92, 47,
	6, 1321, 1322, 12, 4, 2, 2, 1322, 1323, 9, 13, 2, 2, 1323, 1331, 5, 92,
	47, 5, 1324, 1325, 12, 3, 2, 2, 1325, 1326, 7, 226, 2, 2, 1326, 1331, 5,
	92, 47, 4, 1327, 1328, 12, 7, 2, 2, 1328, 1329, 7, 22, 2, 2, 1329, 1331,
	5, 100, 51, 2, 1330, 1318, 3, 2, 2, 2, 1330, 1321, 3, 2, 2, 2, 1330, 1324,
	3, 2, 2, 2, 1330, 1327, 3, 2, 2, 2, 1331, 1334, 3, 2, 2, 2, 1332, 1330,
	3, 2, 2, 2, 1332, 1333, 3, 2, 2, 2, 1333, 93, 3, 2, 2, 2, 1334, 1332, 3,
	2, 2, 2, 1335, 1336, 8, 48, 1, 2, 1336, 1575, 7, 127, 2, 2, 1337, 1575,
	5, 108, 55, 2, 1338, 1339, 5, 150, 76, 2, 1339, 1340, 5, 96, 49, 2, 1340,
	1575, 3, 2, 2, 2, 1341, 1342, 7, 239, 2, 2, 1342, 1575, 5, 96, 49, 2, 1343,
	1575, 5, 152, 77, 2, 1344, 1575, 5, 106, 54, 2, 1345, 1575, 5, 96, 49,
	2, 1346, 1575, 7, 229, 2, 2, 1347, 1575, 7, 7, 2, 2, 1348, 1349, 7, 142,
	2, 2, 1349, 1350, 7, 4, 2, 2, 1350, 1351, 5, 92, 47, 2, 1351, 1352, 7,
	89, 2, 2, 1352, 1353, 5, 92, 47, 2, 1353, 1354, 7, 5, 2, 2, 1354, 1575,
	3, 2, 2, 2, 1355, 1356, 7, 4, 2, 2, 1356, 1359, 5, 86, 44, 2, 1357, 1358,
	7, 6, 2, 2, 1358, 1360, 5, 86, 44, 2, 1359, 1357, 3, 2, 2, 2, 1360, 1361,
	3, 2, 2, 2, 1361, 1359, 3, 2, 2, 2, 1361, 1362, 3, 2, 2, 2, 1362, 1363,
	3, 2, 2, 2, 1363, 1364, 7, 5, 2, 2, 1364, 1575, 3, 2, 2, 2, 1365, 1366,
	7, 165, 2, 2, 1366, 1367, 7, 4, 2, 2, 1367, 1372, 5, 86, 44, 2, 1368, 1369,
	7, 6, 2, 2, 1369, 1371, 5, 86, 44, 2, 1370, 1368, 3, 2, 2, 2, 1371, 1374,
	3, 2, 2, 2, 1372, 1370, 3, 2, 2, 2, 1372, 1373, 3, 2, 2, 2, 1373, 1375,
	3, 2, 2, 2, 1374, 1372, 3, 2, 2, 2, 1375, 1376, 7, 5, 2, 2, 1376, 1575,
	3, 2, 2, 2, 1377, 1378, 5, 142, 72, 2, 1378, 1379, 7, 4, 2, 2, 1379, 1380,
	7, 223, 2, 2, 1380, 1382, 7, 5, 2, 2, 1381, 1383, 5, 124, 63, 2, 1382,
	1381, 3, 2, 2, 2, 1382, 1383, 3, 2, 2, 2, 1383, 1385, 3, 2, 2, 2, 1384,
	1386, 5, 126, 64, 2, 1385, 1384, 3, 2, 2, 2, 1385, 1386, 3, 2, 2, 2, 1386,
	1575, 3, 2, 2, 2, 1387, 1388, 5, 142, 72, 2, 1388, 1400, 7, 4, 2, 2, 1389,
	1391, 5, 66, 34, 2, 1390, 1389, 3, 2, 2, 2, 1390, 1391, 3, 2, 2, 2, 1391,
	1392, 3, 2, 2, 2, 1392, 1397, 5, 86, 44, 2, 1393, 1394, 7, 6, 2, 2, 1394,
	1396, 5, 86, 44, 2, 1395, 1393, 3, 2, 2, 2, 1396, 1399, 3, 2, 2, 2, 1397,
	1395, 3, 2, 2, 2, 1397, 1398, 3, 2, 2, 2, 1398, 1401, 3, 2, 2, 2, 1399,
	1397, 3, 2, 2, 2, 1400, 1390, 3, 2, 2, 2, 1400, 1401, 3, 2, 2, 2, 1401,
	1412, 3, 2, 2, 2, 1402, 1403, 7, 135, 2, 2, 1403, 1404, 7, 25, 2, 2, 1404,
	1409, 5, 54, 28, 2, 1405, 1406, 7, 6, 2, 2, 1406, 1408, 5, 54, 28, 2, 1407,
	1405, 3, 2, 2, 2, 1408, 1411, 3, 2, 2, 2, 1409, 1407, 3, 2, 2, 2, 1409,
	1410, 3, 2, 2, 2, 1410, 1413, 3, 2, 2, 2, 1411, 1409, 3, 2, 2, 2, 1412,
	1402, 3, 2, 2, 2, 1412, 1413, 3, 2, 2, 2, 1413, 1414, 3, 2, 2, 2, 1414,
	1416, 7, 5, 2, 2, 1415, 1417, 5, 124, 63, 2, 1416, 1415, 3, 2, 2, 2, 1416,
	1417, 3, 2, 2, 2, 1417, 1422, 3, 2, 2, 2, 1418, 1420, 5, 98, 50, 2, 1419,
	1418, 3, 2, 2, 2, 1419, 1420, 3, 2, 2, 2, 1420, 1421, 3, 2, 2, 2, 1421,
	1423, 5, 126, 64, 2, 1422, 1419, 3, 2, 2, 2, 1422, 1423, 3, 2, 2, 2, 1423,
	1575, 3, 2, 2, 2, 1424, 1425, 5, 150, 76, 2, 1425, 1426, 7, 8, 2, 2, 1426,
	1427, 5, 86, 44, 2, 1427, 1575, 3, 2, 2, 2, 1428, 1437, 7, 4, 2, 2, 1429,
	1434, 5, 150, 76, 2, 1430, 1431, 7, 6, 2, 2, 1431, 1433, 5, 150, 76, 2,
	1432, 1430, 3, 2, 2, 2, 1433, 1436, 3, 2, 2, 2, 1434, 1432, 3, 2, 2, 2,
	1434, 1435, 3, 2, 2, 2, 1435, 1438, 3, 2, 2, 2, 1436, 1434, 3, 2, 2, 2,
	1437, 1429, 3, 2, 2, 2, 1437, 1438, 3, 2, 2, 2, 1438, 1439, 3, 2, 2, 2,
	1439, 1440, 7, 5, 2, 2, 1440, 1441, 7, 8, 2, 2, 1441, 1575, 5, 86, 44,
	2, 1442, 1443, 7, 4, 2, 2, 1443, 1444, 5, 10, 6, 2, 1444, 1445, 7, 5, 2,
	2, 1445, 1575, 3, 2, 2, 2, 1446, 1447, 7, 65, 2, 2, 1447, 1448, 7, 4, 2,
	2, 1448, 1449, 5, 10, 6, 2, 1449, 1450, 7, 5, 2, 2, 1450, 1575, 3, 2, 2,
	2, 1451, 1452, 7, 29, 2, 2, 1452, 1454, 5, 92, 47, 2, 1453, 1455, 5, 122,
	62, 2, 1454, 1453, 3, 2, 2, 2, 1455, 1456, 3, 2, 2, 2, 1456, 1454, 3, 2,
	2, 2, 1456, 1457, 3, 2, 2, 2, 1457, 1460, 3, 2, 2, 2, 1458, 1459, 7, 59,
	2, 2, 1459, 1461, 5, 86, 44, 2, 1460, 1458, 3, 2, 2, 2, 1460, 1461, 3,
	2, 2, 2, 1461, 1462, 3, 2, 2, 2, 1462, 1463, 7, 60, 2, 2, 1463, 1575, 3,
	2, 2, 2, 1464, 1466, 7, 29, 2, 2, 1465, 1467, 5, 122, 62, 2, 1466, 1465,
	3, 2, 2, 2, 1467, 1468, 3, 2, 2, 2, 1468, 1466, 3, 2, 2, 2, 1468, 1469,
	3, 2, 2, 2, 1469, 1472, 3, 2, 2, 2, 1470, 1471, 7, 59, 2, 2, 1471, 1473,
	5, 86, 44, 2, 1472, 1470, 3, 2, 2, 2, 1472, 1473, 3, 2, 2, 2, 1473, 1474,
	3, 2, 2, 2, 1474, 1475, 7, 60, 2, 2, 1475, 1575, 3, 2, 2, 2, 1476, 1477,
	7, 30, 2, 2, 1477, 1478, 7, 4, 2, 2, 1478, 1479, 5, 86, 44, 2, 1479, 1480,
	7, 20, 2, 2, 1480, 1481, 5, 116, 59, 2, 1481, 1482, 7, 5, 2, 2, 1482, 1575,
	3, 2, 2, 2, 1483, 1484, 7, 194, 2, 2, 1484, 1485, 7, 4, 2, 2, 1485, 1486,
	5, 86, 44, 2, 1486, 1487, 7, 20, 2, 2, 1487, 1488, 5, 116, 59, 2, 1488,
	1489, 7, 5, 2, 2, 1489, 1575, 3, 2, 2, 2, 1490, 1491, 7, 19, 2, 2, 1491,
	1500, 7, 9, 2, 2, 1492, 1497, 5, 86, 44, 2, 1493, 1494, 7, 6, 2, 2, 1494,
	1496, 5, 86, 44, 2, 1495, 1493, 3, 2, 2, 2, 1496, 1499, 3, 2, 2, 2, 1497,
	1495, 3, 2, 2, 2, 1497, 1498, 3, 2, 2, 2, 1498, 1501, 3, 2, 2, 2, 1499,
	1497, 3, 2, 2, 2, 1500, 1492, 3, 2, 2, 2, 1500, 1501, 3, 2, 2, 2, 1501,
	1502, 3, 2, 2, 2, 1502, 1575, 7, 10, 2, 2, 1503, 1575, 5, 150, 76, 2, 1504,
	1575, 7, 42, 2, 2, 1505, 1509, 7, 44, 2, 2, 1506, 1507, 7, 4, 2, 2, 1507,
	1508, 7, 230, 2, 2, 1508, 1510, 7, 5, 2, 2, 1509, 1506, 3, 2, 2, 2, 1509,
	1510, 3, 2, 2, 2, 1510, 1575, 3, 2, 2, 2, 1511, 1515, 7, 45, 2, 2, 1512,
	1513, 7, 4, 2, 2, 1513, 1514, 7, 230, 2, 2, 1514, 1516, 7, 5, 2, 2, 1515,
	1512, 3, 2, 2, 2, 1515, 1516, 3, 2, 2, 2, 1516, 1575, 3, 2, 2, 2, 1517,
	1521, 7, 110, 2, 2, 1518, 1519, 7, 4, 2, 2, 1519, 1520, 7, 230, 2, 2, 1520,
	1522, 7, 5, 2, 2, 1521, 1518, 3, 2, 2, 2, 1521, 1522, 3, 2, 2, 2, 1522,
	1575, 3, 2, 2, 2, 1523, 1527, 7, 111, 2, 2, 1524, 1525, 7, 4, 2, 2, 1525,
	1526, 7, 230, 2, 2, 1526, 1528, 7, 5, 2, 2, 1527, 1524, 3, 2, 2, 2, 1527,
	1528, 3, 2, 2, 2, 1528, 1575, 3, 2, 2, 2, 1529, 1575, 7, 46, 2, 2, 1530,
	1531, 7, 181, 2, 2, 1531, 1532, 7, 4, 2, 2, 1532, 1533, 5, 92, 47, 2, 1533,
	1534, 7, 75, 2, 2, 1534, 1537, 5, 92, 47, 2, 1535, 1536, 7, 73, 2, 2, 1536,
	1538, 5, 92, 47, 2, 1537, 1535, 3, 2, 2, 2, 1537, 1538, 3, 2, 2, 2, 1538,
	1539, 3, 2, 2, 2, 1539, 1540, 7, 5, 2, 2, 1540, 1575, 3, 2, 2, 2, 1541,
	1542, 7, 125, 2, 2, 1542, 1543, 7, 4, 2, 2, 1543, 1546, 5, 92, 47, 2, 1544,
	1545, 7, 6, 2, 2, 1545, 1547, 5, 112, 57, 2, 1546, 1544, 3, 2, 2, 2, 1546,
	1547, 3, 2, 2, 2, 1547, 1548, 3, 2, 2, 2, 1548, 1549, 7, 5, 2, 2, 1549,
	1575, 3, 2, 2, 2, 1550, 1551, 7, 67, 2, 2, 1551, 1552, 7, 4, 2, 2, 1552,
	1553, 5, 150, 76, 2, 1553, 1554, 7, 75, 2, 2, 1554, 1555, 5, 92, 47, 2,
	1555, 1556, 7, 5, 2, 2, 1556, 1575, 3, 2, 2, 2, 1557, 1558, 7, 4, 2, 2,
	1558, 1559, 5, 86, 44, 2, 1559, 1560, 7, 5, 2, 2, 1560, 1575, 3, 2, 2,
	2, 1561, 1562, 7, 84, 2, 2, 1562, 1571, 7, 4, 2, 2, 1563, 1568, 5, 142,
	72, 2, 1564, 1565, 7, 6, 2, 2, 1565, 1567, 5, 142, 72, 2, 1566, 1564, 3,
	2, 2, 2, 1567, 1570, 3, 2, 2, 2, 1568, 1566, 3, 2, 2, 2, 1568, 1569, 3,
	2, 2, 2, 1569, 1572, 3, 2, 2, 2, 1570, 1568, 3, 2, 2, 2, 1571, 1563, 3,
	2, 2, 2, 1571, 1572, 3, 2, 2, 2, 1572, 1573, 3, 2, 2, 2, 1573, 1575, 7,
	5, 2, 2, 1574, 1335, 3, 2, 2, 2, 1574, 1337, 3, 2, 2, 2, 1574, 1338, 3,
	2, 2, 2, 1574, 1341, 3, 2, 2, 2, 1574, 1343, 3, 2, 2, 2, 1574, 1344, 3,
	2, 2, 2, 1574, 1345, 3, 2, 2, 2, 1574, 1346, 3, 2, 2, 2, 1574, 1347, 3,
	2, 2, 2, 1574, 1348, 3, 2, 2, 2, 1574, 1355, 3, 2, 2, 2, 1574, 1365, 3,
	2, 2, 2, 1574, 1377, 3, 2, 2, 2, 1574, 1387, 3, 2, 2, 2, 1574, 1424, 3,
	2, 2, 2, 1574, 1428, 3, 2, 2, 2, 1574, 1442, 3, 2, 2, 2, 1574, 1446, 3,
	2, 2, 2, 1574, 1451, 3, 2, 2, 2, 1574, 1464, 3, 2, 2, 2, 1574, 1476, 3,
	2, 2, 2, 1574, 1483, 3, 2, 2, 2, 1574, 1490, 3, 2, 2, 2, 1574, 1503, 3,
	2, 2, 2, 1574, 1504, 3, 2, 2, 2, 1574, 1505, 3, 2, 2, 2, 1574, 1511, 3,
	2, 2, 2, 1574, 1517, 3, 2, 2, 2, 1574, 1523, 3, 2, 2, 2, 1574, 1529, 3,
	2, 2, 2, 1574, 1530, 3, 2, 2, 2, 1574, 1541, 3, 2, 2, 2, 1574, 1550, 3,
	2, 2, 2, 1574, 1557, 3, 2, 2, 2, 1574, 1561, 3, 2, 2, 2, 1575, 1586, 3,
	2, 2, 2, 1576, 1577, 12, 16, 2, 2, 1577, 1578, 7, 9, 2, 2, 1578, 1579,
	5, 92, 47, 2, 1579, 1580, 7, 10, 2, 2, 1580, 1585, 3, 2, 2, 2, 1581, 1582,
	12, 14, 2, 2, 1582, 1583, 7, 3, 2, 2, 1583, 1585, 5, 150, 76, 2, 1584,
	1576, 3, 2, 2, 2, 1584, 1581, 3, 2, 2, 2, 1585, 1588, 3, 2, 2, 2, 1586,
	1584, 3, 2, 2, 2, 1586, 1587, 3, 2, 2, 2, 1587, 95, 3, 2, 2, 2, 1588, 1586,
	3, 2, 2, 2, 1589, 1596, 7, 227, 2, 2, 1590, 1593, 7, 228, 2, 2, 1591, 1592,
	7, 196, 2, 2, 1592, 1594, 7, 227, 2, 2, 1593, 1591, 3, 2, 2, 2, 1593, 1594,
	3, 2, 2, 2, 1594, 1596, 3, 2, 2, 2, 1595, 1589, 3, 2, 2, 2, 1595, 1590,
	3, 2, 2, 2, 1596, 97, 3, 2, 2, 2, 1597, 1598, 7, 88, 2, 2, 1598, 1602,
	7, 129, 2, 2, 1599, 1600, 7, 155, 2, 2, 1600, 1602, 7, 129, 2, 2, 1601,
	1597, 3, 2, 2, 2, 1601, 1599, 3, 2, 2, 2, 1602, 99, 3, 2, 2, 2, 1603, 1604,
	7, 189, 2, 2, 1604, 1605, 7, 214, 2, 2, 1605, 1610, 5, 108, 55, 2, 1606,
	1607, 7, 189, 2, 2, 1607, 1608, 7, 214, 2, 2, 1608, 1610, 5, 96, 49, 2,
	1609, 1603, 3, 2, 2, 2, 1609, 1606, 3, 2, 2, 2, 1610, 101, 3, 2, 2, 2,
	1611, 1612, 9, 15, 2, 2, 1612, 103, 3, 2, 2, 2, 1613, 1614, 9, 16, 2, 2,
	1614, 105, 3, 2, 2, 2, 1615, 1616, 9, 17, 2, 2, 1616, 107, 3, 2, 2, 2,
	1617, 1619, 7, 95, 2, 2, 1618, 1620, 9, 13, 2, 2, 1619, 1618, 3, 2, 2,
	2, 1619, 1620, 3, 2, 2, 2, 1620, 1621, 3, 2, 2, 2, 1621, 1622, 5, 96, 49,
	2, 1622, 1625, 5, 110, 56, 2, 1623, 1624, 7, 191, 2, 2, 1624, 1626, 5,
	110, 56, 2, 1625, 1623, 3, 2, 2, 2, 1625, 1626, 3, 2, 2, 2, 1626, 109,
	3, 2, 2, 2, 1627, 1628, 9, 18, 2, 2, 1628, 111, 3, 2, 2, 2, 1629, 1630,
	9, 19, 2, 2, 1630, 113, 3, 2, 2, 2, 1631, 1640, 7, 4, 2, 2, 1632, 1637,
	5, 116, 59, 2, 1633, 1634, 7, 6, 2, 2, 1634, 1636, 5, 116, 59, 2, 1635,
	1633, 3, 2, 2, 2, 1636, 1639, 3, 2, 2, 2, 1637, 1635, 3, 2, 2, 2, 1637,
	1638, 3, 2, 2, 2, 1638, 1641, 3, 2, 2, 2, 1639, 1637, 3, 2, 2, 2, 1640,
	1632, 3, 2, 2, 2, 1640, 1641, 3, 2, 2, 2, 1641, 1642, 3, 2, 2, 2, 1642,
	1643, 7, 5, 2, 2, 1643, 115, 3, 2, 2, 2, 1644, 1645, 8, 59, 1, 2, 1645,
	1646, 7, 19, 2, 2, 1646, 1647, 7, 217, 2, 2, 1647, 1648, 5, 116, 59, 2,
	1648, 1649, 7, 219, 2, 2, 1649, 1692, 3, 2, 2, 2, 1650, 1651, 7, 113, 2,
	2, 1651, 1652, 7, 217, 2, 2, 1652, 1653, 5, 116, 59, 2, 1653, 1654, 7,
	6, 2, 2, 1654, 1655, 5, 116, 59, 2, 1655, 1656, 7, 219, 2, 2, 1656, 1692,
	3, 2, 2, 2, 1657, 1658, 7, 165, 2, 2, 1658, 1659, 7, 4, 2, 2, 1659, 1660,
	5, 150, 76, 2, 1660, 1667, 5, 116, 59, 2, 1661, 1662, 7, 6, 2, 2, 1662,
	1663, 5, 150, 76, 2, 1663, 1664, 5, 116, 59, 2, 1664, 1666, 3, 2, 2, 2,
	1665, 1661, 3, 2, 2, 2, 1666, 1669, 3, 2, 2, 2, 1667, 1665, 3, 2, 2, 2,
	1667, 1668, 3, 2, 2, 2, 1668, 1670, 3, 2, 2, 2, 1669, 1667, 3, 2, 2, 2,
	1670, 1671, 7, 5, 2, 2, 1671, 1692, 3, 2, 2, 2, 1672, 1684, 5, 120, 61,
	2, 1673, 1674, 7, 4, 2, 2, 1674, 1679, 5, 118, 60, 2, 1675, 1676, 7, 6,
	2, 2, 1676, 1678, 5, 118, 60, 2, 1677, 1675, 3, 2, 2, 2, 1678, 1681, 3,
	2, 2, 2, 1679, 1677, 3, 2, 2, 2, 1679, 1680, 3, 2, 2, 2, 1680, 1682, 3,
	2, 2, 2, 1681, 1679, 3, 2, 2, 2, 1682, 1683, 7, 5, 2, 2, 1683, 1685, 3,
	2, 2, 2, 1684, 1673, 3, 2, 2, 2, 1684, 1685, 3, 2, 2, 2, 1685, 1692, 3,
	2, 2, 2, 1686, 1687, 7, 95, 2, 2, 1687, 1688, 5, 110, 56, 2, 1688, 1689,
	7, 191, 2, 2, 1689, 1690, 5, 110, 56, 2, 1690, 1692, 3, 2, 2, 2, 1691,
	1644, 3, 2, 2, 2, 1691, 1650, 3, 2, 2, 2, 1691, 1657, 3, 2, 2, 2, 1691,
	1672, 3, 2, 2, 2, 1691, 1686, 3, 2, 2, 2, 1692, 1697, 3, 2, 2, 2, 1693,
	1694, 12, 8, 2, 2, 1694, 1696, 7, 19, 2, 2, 1695, 1693, 3, 2, 2, 2, 1696,
	1699, 3, 2, 2, 2, 1697, 1695, 3, 2, 2, 2, 1697, 1698, 3, 2, 2, 2, 1698,
	117, 3, 2, 2, 2, 1699, 1697, 3, 2, 2, 2, 1700, 1703, 7, 230, 2, 2, 1701,
	1703, 5, 116, 59, 2, 1702, 1700, 3, 2, 2, 2, 1702, 1701, 3, 2, 2, 2, 1703,
	119, 3, 2, 2, 2, 1704, 1709, 7, 237, 2, 2, 1705, 1709, 7, 238, 2, 2, 1706,
	1709, 7, 239, 2, 2, 1707, 1709, 5, 142, 72, 2, 1708, 1704, 3, 2, 2, 2,
	1708, 1705, 3, 2, 2, 2, 1708, 1706, 3, 2, 2, 2, 1708, 1707, 3, 2, 2, 2,
	1709, 121, 3, 2, 2, 2, 1710, 1711, 7, 208, 2, 2, 1711, 1712, 5, 86, 44,
	2, 1712, 1713, 7, 188, 2, 2, 1713, 1714, 5, 86, 44, 2, 1714, 123, 3, 2,
	2, 2, 1715, 1716, 7, 70, 2, 2, 1716, 1717, 7, 4, 2, 2, 1717, 1718, 7, 209,
	2, 2, 1718, 1719, 5, 88, 45, 2, 1719, 1720, 7, 5, 2, 2, 1720, 125, 3, 2,
	2, 2, 1721, 1722, 7, 139, 2, 2, 1722, 1733, 7, 4, 2, 2, 1723, 1724, 7,
	140, 2, 2, 1724, 1725, 7, 25, 2, 2, 1725, 1730, 5, 86, 44, 2, 1726, 1727,
	7, 6, 2, 2, 1727, 1729, 5, 86, 44, 2, 1728, 1726, 3, 2, 2, 2, 1729, 1732,
	3, 2, 2, 2, 1730, 1728, 3, 2, 2, 2, 1730, 1731, 3, 2, 2, 2, 1731, 1734,
	3, 2, 2, 2, 1732, 1730, 3, 2, 2, 2, 1733, 1723, 3, 2, 2, 2, 1733, 1734,
	3, 2, 2, 2, 1734, 1745, 3, 2, 2, 2, 1735, 1736, 7, 135, 2, 2, 1736, 1737,
	7, 25, 2, 2, 1737, 1742, 5, 54, 28, 2, 1738, 1739, 7, 6, 2, 2, 1739, 1741,
	5, 54, 28, 2, 1740, 1738, 3, 2, 2, 2, 1741, 1744, 3, 2, 2, 2, 1742, 1740,
	3, 2, 2, 2, 1742, 1743, 3, 2, 2, 2, 1743, 1746, 3, 2, 2, 2, 1744, 1742,
	3, 2, 2, 2, 1745, 1735, 3, 2, 2, 2, 1745, 1746, 3, 2, 2, 2, 1746, 1748,
	3, 2, 2, 2, 1747, 1749, 5, 128, 65, 2, 1748, 1747, 3, 2, 2, 2, 1748, 1749,
	3, 2, 2, 2, 1749, 1750, 3, 2, 2, 2, 1750, 1751, 7, 5, 2, 2, 1751, 127,
	3, 2, 2, 2, 1752, 1753, 7, 147, 2, 2, 1753, 1769, 5, 130, 66, 2, 1754,
	1755, 7, 166, 2, 2, 1755, 1769, 5, 130, 66, 2, 1756, 1757, 7, 147, 2, 2,
	1757, 1758, 7, 24, 2, 2, 1758, 1759, 5, 130, 66, 2, 1759, 1760, 7, 17,
	2, 2, 1760, 1761, 5, 130, 66, 2, 1761, 1769, 3, 2, 2, 2, 1762, 1763, 7,
	166, 2, 2, 1763, 1764, 7, 24, 2, 2, 1764, 1765, 5, 130, 66, 2, 1765, 1766,
	7, 17, 2, 2, 1766, 1767, 5, 130, 66, 2, 1767, 1769, 3, 2, 2, 2, 1768, 1752,
	3, 2, 2, 2, 1768, 1754, 3, 2, 2, 2, 1768, 1756, 3, 2, 2, 2, 1768, 1762,
	3, 2, 2, 2, 1769, 129, 3, 2, 2, 2, 1770, 1771, 7, 197, 2, 2, 1771, 1780,
	7, 143, 2, 2, 1772, 1773, 7, 197, 2, 2, 1773, 1780, 7, 72, 2, 2, 1774,
	1775, 7, 41, 2, 2, 1775, 1780, 7, 165, 2, 2, 1776, 1777, 5, 86, 44, 2,
	1777, 1778, 9, 20, 2, 2, 1778, 1780, 3, 2, 2, 2, 1779, 1770, 3, 2, 2, 2,
	1779, 1772, 3, 2, 2, 2, 1779, 1774, 3, 2, 2, 2, 1779, 1776, 3, 2, 2, 2,
	1780, 131, 3, 2, 2, 2, 1781, 1782, 7, 74, 2, 2, 1782, 1786, 9, 21, 2, 2,
	1783, 1784, 7, 195, 2, 2, 1784, 1786, 9, 22, 2, 2, 1785, 1781, 3, 2, 2,
	2, 1785, 1783, 3, 2, 2, 2, 1786, 133, 3, 2, 2, 2, 1787, 1788, 7, 100, 2,
	2, 1788, 1789, 7, 107, 2, 2, 1789, 1793, 5, 136, 69, 2, 1790, 1791, 7,
	148, 2, 2, 1791, 1793, 9, 23, 2, 2, 1792, 1787, 3, 2, 2, 2, 1792, 1790,
	3, 2, 2, 2, 1793, 135, 3, 2, 2, 2, 1794, 1795, 7, 148, 2, 2, 1795, 1802,
	7, 198, 2, 2, 1796, 1797, 7, 148, 2, 2, 1797, 1802, 7, 36, 2, 2, 1798,
	1799, 7, 152, 2, 2, 1799, 1802, 7, 148, 2, 2, 1800, 1802, 7, 172, 2, 2,
	1801, 1794, 3, 2, 2, 2, 1801, 1796, 3, 2, 2, 2, 1801, 1798, 3, 2, 2, 2,
	1801, 1800, 3, 2, 2, 2, 1802, 137, 3, 2, 2, 2, 1803, 1809, 5, 86, 44, 2,
	1804, 1805, 5, 150, 76, 2, 1805, 1806, 7, 11, 2, 2, 1806, 1807, 5, 86,
	44, 2, 1807, 1809, 3, 2, 2, 2, 1808, 1803, 3, 2, 2, 2, 1808, 1804, 3, 2,
	2, 2, 1809, 139, 3, 2, 2, 2, 1810, 1815, 7, 171, 2, 2, 1811, 1815, 7, 52,
	2, 2, 1812, 1815, 7, 93, 2, 2, 1813, 1815, 5, 150, 76, 2, 1814, 1810, 3,
	2, 2, 2, 1814, 1811, 3, 2, 2, 2, 1814, 1812, 3, 2, 2, 2, 1814, 1813, 3,
	2, 2, 2, 1815, 141, 3, 2, 2, 2, 1816, 1821, 5, 150, 76, 2, 1817, 1818,
	7, 3, 2, 2, 1818, 1820, 5, 150, 76, 2, 1819, 1817, 3, 2, 2, 2, 1820, 1823,
	3, 2, 2, 2, 1821, 1819, 3, 2, 2, 2, 1821, 1822, 3, 2, 2, 2, 1822, 143,
	3, 2, 2, 2, 1823, 1821, 3, 2, 2, 2, 1824, 1828, 7, 46, 2, 2, 1825, 1828,
	7, 43, 2, 2, 1826, 1828, 5, 146, 74, 2, 1827, 1824, 3, 2, 2, 2, 1827, 1825,
	3, 2, 2, 2, 1827, 1826, 3, 2, 2, 2, 1828, 145, 3, 2, 2, 2, 1829, 1830,
	7, 202, 2, 2, 1830, 1835, 5, 150, 76, 2, 1831, 1832, 7, 161, 2, 2, 1832,
	1835, 5, 150, 76, 2, 1833, 1835, 5, 150, 76, 2, 1834, 1829, 3, 2, 2, 2,
	1834, 1831, 3, 2, 2, 2, 1834, 1833, 3, 2, 2, 2, 1835, 147, 3, 2, 2, 2,
	1836, 1841, 5, 150, 76, 2, 1837, 1838, 7, 6, 2, 2, 1838, 1840, 5, 150,
	76, 2, 1839, 1837, 3, 2, 2, 2, 1840, 1843, 3, 2, 2, 2, 1841, 1839, 3, 2,
	2, 2, 1841, 1842, 3, 2, 2, 2, 1842, 149, 3, 2, 2, 2, 1843, 1841, 3, 2,
	2, 2, 1844, 1850, 7, 233, 2, 2, 1845, 1850, 7, 235, 2, 2, 1846, 1850, 5,
	154, 78, 2, 1847, 1850, 7, 236, 2, 2, 1848, 1850, 7, 234, 2, 2, 1849, 1844,
	3, 2, 2, 2, 1849, 1845, 3, 2, 2, 2, 1849, 1846, 3, 2, 2, 2, 1849, 1847,
	3, 2, 2, 2, 1849, 1848, 3, 2, 2, 2, 1850, 151, 3, 2, 2, 2, 1851, 1855,
	7, 231, 2, 2, 1852, 1855, 7, 232, 2, 2, 1853, 1855, 7, 230, 2, 2, 1854,
	1851, 3, 2, 2, 2, 1854, 1852, 3, 2, 2, 2, 1854, 1853, 3, 2, 2, 2, 1855,
	153, 3, 2, 2, 2, 1856, 1857, 9, 24, 2, 2, 1857, 155, 3, 2, 2, 2, 240, 178,
	183, 189, 193, 207, 211, 215, 219, 227, 231, 234, 241, 250, 256, 260, 266,
	273, 282, 288, 299, 306, 316, 323, 331, 339, 347, 359, 365, 370, 376, 385,
	394, 399, 403, 411, 418, 431, 434, 444, 447, 454, 463, 469, 474, 478, 488,
	491, 501, 514, 520, 525, 531, 540, 546, 553, 561, 566, 570, 578, 584, 591,
	596, 600, 610, 613, 617, 620, 628, 633, 654, 660, 666, 668, 674, 680, 682,
	688, 707, 712, 719, 731, 733, 753, 756, 760, 764, 782, 785, 793, 796, 802,
	809, 814, 820, 824, 828, 834, 842, 857, 864, 869, 876, 884, 888, 893, 904,
	916, 919, 924, 926, 930, 938, 944, 947, 949, 961, 968, 972, 976, 980, 987,
	996, 999, 1003, 1008, 1012, 1015, 1022, 1033, 1036, 1046, 1049, 1060, 1065,
	1073, 1076, 1080, 1084, 1095, 1098, 1105, 1124, 1128, 1132, 1136, 1140,
	1144, 1146, 1157, 1162, 1171, 1177, 1181, 1183, 1191, 1208, 1214, 1225,
	1232, 1236, 1244, 1246, 1259, 1267, 1276, 1282, 1290, 1296, 1300, 1305,
	1310, 1316, 1330, 1332, 1361, 1372, 1382, 1385, 1390, 1397, 1400, 1409,
	1412, 1416, 1419, 1422, 1434, 1437, 1456, 1460, 1468, 1472, 1497, 1500,
	1509, 1515, 1521, 1527, 1537, 1546, 1568, 1571, 1574, 1584, 1586, 1593,
	1595, 1601, 1609, 1619, 1625, 1637, 1640, 1667, 1679, 1684, 1691, 1697,
	1702, 1708, 1730, 1733, 1742, 1745, 1748, 1768, 1779, 1785, 1792, 1801,
	1808, 1814, 1821, 1827, 1834, 1841, 1849, 1854,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "'.'", "'('", "')'", "','", "'?'", "'->'", "'['", "']'", "'=>'", "'ADD'",
	"'ADMIN'", "'ALL'", "'ALTER'", "'ANALYZE'", "'AND'", "'ANY'", "'ARRAY'",
	"'AS'", "'ASC'", "'AT'", "'BERNOULLI'", "'BETWEEN'", "'BY'", "'CALL'",
	"'CALLED'", "'CASCADE'", "'CASE'", "'CAST'", "'CATALOGS'", "'COLUMN'",
	"'COLUMNS'", "'COMMENT'", "'COMMIT'", "'COMMITTED'", "'CONSTRAINT'", "'CREATE'",
	"'CROSS'", "'CUBE'", "'CURRENT'", "'CURRENT_DATE'", "'CURRENT_ROLE'", "'CURRENT_TIME'",
	"'CURRENT_TIMESTAMP'", "'CURRENT_USER'", "'DATA'", "'DATE'", "'DAY'", "'DEALLOCATE'",
	"'DEFINER'", "'DELETE'", "'DESC'", "'DESCRIBE'", "'DETERMINISTIC'", "'DISTINCT'",
	"'DISTRIBUTED'", "'DROP'", "'ELSE'", "'END'", "'ESCAPE'", "'EXCEPT'", "'EXCLUDING'",
	"'EXECUTE'", "'EXISTS'", "'EXPLAIN'", "'EXTRACT'", "'EXTERNAL'", "'FALSE'",
	"'FILTER'", "'FIRST'", "'FOLLOWING'", "'FOR'", "'FORMAT'", "'FROM'", "'FULL'",
	"'FUNCTION'", "'FUNCTIONS'", "'GRANT'", "'GRANTED'", "'GRANTS'", "'GRAPHVIZ'",
	"'GROUP'", "'GROUPING'", "'HAVING'", "'HOUR'", "'IF'", "'IGNORE'", "'IN'",
	"'INCLUDING'", "'INNER'", "'INPUT'", "'INSERT'", "'INTERSECT'", "'INTERVAL'",
	"'INTO'", "'INVOKER'", "'IO'", "'IS'", "'ISOLATION'", "'JSON'", "'JOIN'",
	"'LANGUAGE'", "'LAST'", "'LATERAL'", "'LEFT'", "'LEVEL'", "'LIKE'", "'LIMIT'",
	"'LOCALTIME'", "'LOCALTIMESTAMP'", "'LOGICAL'", "'MAP'", "'MATERIALIZED'",
	"'MINUTE'", "'MONTH'", "'NAME'", "'NATURAL'", "'NFC'", "'NFD'", "'NFKC'",
	"'NFKD'", "'NO'", "'NONE'", "'NORMALIZE'", "'NOT'", "'NULL'", "'NULLIF'",
	"'NULLS'", "'OFFSET'", "'ON'", "'ONLY'", "'OPTION'", "'OR'", "'ORDER'",
	"'ORDINALITY'", "'OUTER'", "'OUTPUT'", "'OVER'", "'PARTITION'", "'PARTITIONS'",
	"'POSITION'", "'PRECEDING'", "'PREPARE'", "'PRIVILEGES'", "'PROPERTIES'",
	"'RANGE'", "'READ'", "'RECURSIVE'", "'REFRESH'", "'RENAME'", "'REPEATABLE'",
	"'REPLACE'", "'RESET'", "'RESPECT'", "'RESTRICT'", "'RETURN'", "'RETURNS'",
	"'REVOKE'", "'RIGHT'", "'ROLE'", "'ROLES'", "'ROLLBACK'", "'ROLLUP'", "'ROW'",
	"'ROWS'", "'SCHEMA'", "'SCHEMAS'", "'SECOND'", "'SECURITY'", "'SELECT'",
	"'SERIALIZABLE'", "'SESSION'", "'SET'", "'SETS'", "'SHOW'", "'SOME'", "'SQL'",
	"'START'", "'STATS'", "'SUBSTRING'", "'SYSTEM'", "'TABLE'", "'TABLES'",
	"'TABLESAMPLE'", "'TEMPORARY'", "'TEXT'", "'THEN'", "'TIME'", "'TIMESTAMP'",
	"'TO'", "'TRANSACTION'", "'TRUE'", "'TRY_CAST'", "'TYPE'", "'UESCAPE'",
	"'UNBOUNDED'", "'UNCOMMITTED'", "'UNION'", "'UNNEST'", "'USE'", "'USER'",
	"'USING'", "'VALIDATE'", "'VALUES'", "'VERBOSE'", "'VIEW'", "'WHEN'", "'WHERE'",
	"'WITH'", "'WORK'", "'WRITE'", "'YEAR'", "'ZONE'", "'='", "", "'<'", "'<='",
	"'>'", "'>='", "'+'", "'-'", "'*'", "'/'", "'%'", "'||'",
}
var symbolicNames = []string{
	"", "", "", "", "", "", "", "", "", "", "ADD", "ADMIN", "ALL", "ALTER",
	"ANALYZE", "AND", "ANY", "ARRAY", "AS", "ASC", "AT", "BERNOULLI", "BETWEEN",
	"BY", "CALL", "CALLED", "CASCADE", "CASE", "CAST", "CATALOGS", "COLUMN",
	"COLUMNS", "COMMENT", "COMMIT", "COMMITTED", "CONSTRAINT", "CREATE", "CROSS",
	"CUBE", "CURRENT", "CURRENT_DATE", "CURRENT_ROLE", "CURRENT_TIME", "CURRENT_TIMESTAMP",
	"CURRENT_USER", "DATA", "DATE", "DAY", "DEALLOCATE", "DEFINER", "DELETE",
	"DESC", "DESCRIBE", "DETERMINISTIC", "DISTINCT", "DISTRIBUTED", "DROP",
	"ELSE", "END", "ESCAPE", "EXCEPT", "EXCLUDING", "EXECUTE", "EXISTS", "EXPLAIN",
	"EXTRACT", "EXTERNAL", "FALSE", "FILTER", "FIRST", "FOLLOWING", "FOR",
	"FORMAT", "FROM", "FULL", "FUNCTION", "FUNCTIONS", "GRANT", "GRANTED",
	"GRANTS", "GRAPHVIZ", "GROUP", "GROUPING", "HAVING", "HOUR", "IF", "IGNORE",
	"IN", "INCLUDING", "INNER", "INPUT", "INSERT", "INTERSECT", "INTERVAL",
	"INTO", "INVOKER", "IO", "IS", "ISOLATION", "JSON", "JOIN", "LANGUAGE",
	"LAST", "LATERAL", "LEFT", "LEVEL", "LIKE", "LIMIT", "LOCALTIME", "LOCALTIMESTAMP",
	"LOGICAL", "MAP", "MATERIALIZED", "MINUTE", "MONTH", "NAME", "NATURAL",
	"NFC", "NFD", "NFKC", "NFKD", "NO", "NONE", "NORMALIZE", "NOT", "NULL",
	"NULLIF", "NULLS", "OFFSET", "ON", "ONLY", "OPTION", "OR", "ORDER", "ORDINALITY",
	"OUTER", "OUTPUT", "OVER", "PARTITION", "PARTITIONS", "POSITION", "PRECEDING",
	"PREPARE", "PRIVILEGES", "PROPERTIES", "RANGE", "READ", "RECURSIVE", "REFRESH",
	"RENAME", "REPEATABLE", "REPLACE", "RESET", "RESPECT", "RESTRICT", "RETURN",
	"RETURNS", "REVOKE", "RIGHT", "ROLE", "ROLES", "ROLLBACK", "ROLLUP", "ROW",
	"ROWS", "SCHEMA", "SCHEMAS", "SECOND", "SECURITY", "SELECT", "SERIALIZABLE",
	"SESSION", "SET", "SETS", "SHOW", "SOME", "SQL", "START", "STATS", "SUBSTRING",
	"SYSTEM", "TABLE", "TABLES", "TABLESAMPLE", "TEMPORARY", "TEXT", "THEN",
	"TIME", "TIMESTAMP", "TO", "TRANSACTION", "TRUE", "TRY_CAST", "TYPE", "UESCAPE",
	"UNBOUNDED", "UNCOMMITTED", "UNION", "UNNEST", "USE", "USER", "USING",
	"VALIDATE", "VALUES", "VERBOSE", "VIEW", "WHEN", "WHERE", "WITH", "WORK",
	"WRITE", "YEAR", "ZONE", "EQ", "NEQ", "LT", "LTE", "GT", "GTE", "PLUS",
	"MINUS", "ASTERISK", "SLASH", "PERCENT", "CONCAT", "STRING", "UNICODE_STRING",
	"BINARY_LITERAL", "INTEGER_VALUE", "DECIMAL_VALUE", "DOUBLE_VALUE", "IDENTIFIER",
	"DIGIT_IDENTIFIER", "QUOTED_IDENTIFIER", "BACKQUOTED_IDENTIFIER", "TIME_WITH_TIME_ZONE",
	"TIMESTAMP_WITH_TIME_ZONE", "DOUBLE_PRECISION", "SIMPLE_COMMENT", "BRACKETED_COMMENT",
	"WS", "UNRECOGNIZED", "DELIMITER",
}

var ruleNames = []string{
	"singleStatement", "standaloneExpression", "standaloneRoutineBody", "statement",
	"query", "with", "tableElement", "columnDefinition", "likeClause", "properties",
	"property", "sqlParameterDeclaration", "routineCharacteristics", "routineCharacteristic",
	"alterRoutineCharacteristics", "alterRoutineCharacteristic", "routineBody",
	"returnStatement", "externalBodyReference", "language", "determinism",
	"nullCallClause", "externalRoutineName", "queryNoWith", "queryTerm", "queryPrimary",
	"sortItem", "querySpecification", "groupBy", "groupingElement", "groupingSet",
	"namedQuery", "setQuantifier", "selectItem", "relation", "joinType", "joinCriteria",
	"sampledRelation", "sampleType", "aliasedRelation", "columnAliases", "relationPrimary",
	"expression", "booleanExpression", "predicate", "valueExpression", "primaryExpression",
	"string_", "nullTreatment", "timeZoneSpecifier", "comparisonOperator",
	"comparisonQuantifier", "booleanValue", "interval", "intervalField", "normalForm",
	"types", "type_", "typeParameter", "baseType", "whenClause", "filter",
	"over", "windowFrame", "frameBound", "explainOption", "transactionMode",
	"levelOfIsolation", "callArgument", "privilege", "qualifiedName", "grantor",
	"principal", "roles", "identifier", "number", "nonReserved",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type SqlBaseParser struct {
	*antlr.BaseParser
}

func NewSqlBaseParser(input antlr.TokenStream) *SqlBaseParser {
	this := new(SqlBaseParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "SqlBase.g4"

	return this
}

// SqlBaseParser tokens.
const (
	SqlBaseParserEOF                      = antlr.TokenEOF
	SqlBaseParserT__0                     = 1
	SqlBaseParserT__1                     = 2
	SqlBaseParserT__2                     = 3
	SqlBaseParserT__3                     = 4
	SqlBaseParserT__4                     = 5
	SqlBaseParserT__5                     = 6
	SqlBaseParserT__6                     = 7
	SqlBaseParserT__7                     = 8
	SqlBaseParserT__8                     = 9
	SqlBaseParserADD                      = 10
	SqlBaseParserADMIN                    = 11
	SqlBaseParserALL                      = 12
	SqlBaseParserALTER                    = 13
	SqlBaseParserANALYZE                  = 14
	SqlBaseParserAND                      = 15
	SqlBaseParserANY                      = 16
	SqlBaseParserARRAY                    = 17
	SqlBaseParserAS                       = 18
	SqlBaseParserASC                      = 19
	SqlBaseParserAT                       = 20
	SqlBaseParserBERNOULLI                = 21
	SqlBaseParserBETWEEN                  = 22
	SqlBaseParserBY                       = 23
	SqlBaseParserCALL                     = 24
	SqlBaseParserCALLED                   = 25
	SqlBaseParserCASCADE                  = 26
	SqlBaseParserCASE                     = 27
	SqlBaseParserCAST                     = 28
	SqlBaseParserCATALOGS                 = 29
	SqlBaseParserCOLUMN                   = 30
	SqlBaseParserCOLUMNS                  = 31
	SqlBaseParserCOMMENT                  = 32
	SqlBaseParserCOMMIT                   = 33
	SqlBaseParserCOMMITTED                = 34
	SqlBaseParserCONSTRAINT               = 35
	SqlBaseParserCREATE                   = 36
	SqlBaseParserCROSS                    = 37
	SqlBaseParserCUBE                     = 38
	SqlBaseParserCURRENT                  = 39
	SqlBaseParserCURRENT_DATE             = 40
	SqlBaseParserCURRENT_ROLE             = 41
	SqlBaseParserCURRENT_TIME             = 42
	SqlBaseParserCURRENT_TIMESTAMP        = 43
	SqlBaseParserCURRENT_USER             = 44
	SqlBaseParserDATA                     = 45
	SqlBaseParserDATE                     = 46
	SqlBaseParserDAY                      = 47
	SqlBaseParserDEALLOCATE               = 48
	SqlBaseParserDEFINER                  = 49
	SqlBaseParserDELETE                   = 50
	SqlBaseParserDESC                     = 51
	SqlBaseParserDESCRIBE                 = 52
	SqlBaseParserDETERMINISTIC            = 53
	SqlBaseParserDISTINCT                 = 54
	SqlBaseParserDISTRIBUTED              = 55
	SqlBaseParserDROP                     = 56
	SqlBaseParserELSE                     = 57
	SqlBaseParserEND                      = 58
	SqlBaseParserESCAPE                   = 59
	SqlBaseParserEXCEPT                   = 60
	SqlBaseParserEXCLUDING                = 61
	SqlBaseParserEXECUTE                  = 62
	SqlBaseParserEXISTS                   = 63
	SqlBaseParserEXPLAIN                  = 64
	SqlBaseParserEXTRACT                  = 65
	SqlBaseParserEXTERNAL                 = 66
	SqlBaseParserFALSE                    = 67
	SqlBaseParserFILTER                   = 68
	SqlBaseParserFIRST                    = 69
	SqlBaseParserFOLLOWING                = 70
	SqlBaseParserFOR                      = 71
	SqlBaseParserFORMAT                   = 72
	SqlBaseParserFROM                     = 73
	SqlBaseParserFULL                     = 74
	SqlBaseParserFUNCTION                 = 75
	SqlBaseParserFUNCTIONS                = 76
	SqlBaseParserGRANT                    = 77
	SqlBaseParserGRANTED                  = 78
	SqlBaseParserGRANTS                   = 79
	SqlBaseParserGRAPHVIZ                 = 80
	SqlBaseParserGROUP                    = 81
	SqlBaseParserGROUPING                 = 82
	SqlBaseParserHAVING                   = 83
	SqlBaseParserHOUR                     = 84
	SqlBaseParserIF                       = 85
	SqlBaseParserIGNORE                   = 86
	SqlBaseParserIN                       = 87
	SqlBaseParserINCLUDING                = 88
	SqlBaseParserINNER                    = 89
	SqlBaseParserINPUT                    = 90
	SqlBaseParserINSERT                   = 91
	SqlBaseParserINTERSECT                = 92
	SqlBaseParserINTERVAL                 = 93
	SqlBaseParserINTO                     = 94
	SqlBaseParserINVOKER                  = 95
	SqlBaseParserIO                       = 96
	SqlBaseParserIS                       = 97
	SqlBaseParserISOLATION                = 98
	SqlBaseParserJSON                     = 99
	SqlBaseParserJOIN                     = 100
	SqlBaseParserLANGUAGE                 = 101
	SqlBaseParserLAST                     = 102
	SqlBaseParserLATERAL                  = 103
	SqlBaseParserLEFT                     = 104
	SqlBaseParserLEVEL                    = 105
	SqlBaseParserLIKE                     = 106
	SqlBaseParserLIMIT                    = 107
	SqlBaseParserLOCALTIME                = 108
	SqlBaseParserLOCALTIMESTAMP           = 109
	SqlBaseParserLOGICAL                  = 110
	SqlBaseParserMAP                      = 111
	SqlBaseParserMATERIALIZED             = 112
	SqlBaseParserMINUTE                   = 113
	SqlBaseParserMONTH                    = 114
	SqlBaseParserNAME                     = 115
	SqlBaseParserNATURAL                  = 116
	SqlBaseParserNFC                      = 117
	SqlBaseParserNFD                      = 118
	SqlBaseParserNFKC                     = 119
	SqlBaseParserNFKD                     = 120
	SqlBaseParserNO                       = 121
	SqlBaseParserNONE                     = 122
	SqlBaseParserNORMALIZE                = 123
	SqlBaseParserNOT                      = 124
	SqlBaseParserNULL                     = 125
	SqlBaseParserNULLIF                   = 126
	SqlBaseParserNULLS                    = 127
	SqlBaseParserOFFSET                   = 128
	SqlBaseParserON                       = 129
	SqlBaseParserONLY                     = 130
	SqlBaseParserOPTION                   = 131
	SqlBaseParserOR                       = 132
	SqlBaseParserORDER                    = 133
	SqlBaseParserORDINALITY               = 134
	SqlBaseParserOUTER                    = 135
	SqlBaseParserOUTPUT                   = 136
	SqlBaseParserOVER                     = 137
	SqlBaseParserPARTITION                = 138
	SqlBaseParserPARTITIONS               = 139
	SqlBaseParserPOSITION                 = 140
	SqlBaseParserPRECEDING                = 141
	SqlBaseParserPREPARE                  = 142
	SqlBaseParserPRIVILEGES               = 143
	SqlBaseParserPROPERTIES               = 144
	SqlBaseParserRANGE                    = 145
	SqlBaseParserREAD                     = 146
	SqlBaseParserRECURSIVE                = 147
	SqlBaseParserREFRESH                  = 148
	SqlBaseParserRENAME                   = 149
	SqlBaseParserREPEATABLE               = 150
	SqlBaseParserREPLACE                  = 151
	SqlBaseParserRESET                    = 152
	SqlBaseParserRESPECT                  = 153
	SqlBaseParserRESTRICT                 = 154
	SqlBaseParserRETURN                   = 155
	SqlBaseParserRETURNS                  = 156
	SqlBaseParserREVOKE                   = 157
	SqlBaseParserRIGHT                    = 158
	SqlBaseParserROLE                     = 159
	SqlBaseParserROLES                    = 160
	SqlBaseParserROLLBACK                 = 161
	SqlBaseParserROLLUP                   = 162
	SqlBaseParserROW                      = 163
	SqlBaseParserROWS                     = 164
	SqlBaseParserSCHEMA                   = 165
	SqlBaseParserSCHEMAS                  = 166
	SqlBaseParserSECOND                   = 167
	SqlBaseParserSECURITY                 = 168
	SqlBaseParserSELECT                   = 169
	SqlBaseParserSERIALIZABLE             = 170
	SqlBaseParserSESSION                  = 171
	SqlBaseParserSET                      = 172
	SqlBaseParserSETS                     = 173
	SqlBaseParserSHOW                     = 174
	SqlBaseParserSOME                     = 175
	SqlBaseParserSQL                      = 176
	SqlBaseParserSTART                    = 177
	SqlBaseParserSTATS                    = 178
	SqlBaseParserSUBSTRING                = 179
	SqlBaseParserSYSTEM                   = 180
	SqlBaseParserTABLE                    = 181
	SqlBaseParserTABLES                   = 182
	SqlBaseParserTABLESAMPLE              = 183
	SqlBaseParserTEMPORARY                = 184
	SqlBaseParserTEXT                     = 185
	SqlBaseParserTHEN                     = 186
	SqlBaseParserTIME                     = 187
	SqlBaseParserTIMESTAMP                = 188
	SqlBaseParserTO                       = 189
	SqlBaseParserTRANSACTION              = 190
	SqlBaseParserTRUE                     = 191
	SqlBaseParserTRY_CAST                 = 192
	SqlBaseParserTYPE                     = 193
	SqlBaseParserUESCAPE                  = 194
	SqlBaseParserUNBOUNDED                = 195
	SqlBaseParserUNCOMMITTED              = 196
	SqlBaseParserUNION                    = 197
	SqlBaseParserUNNEST                   = 198
	SqlBaseParserUSE                      = 199
	SqlBaseParserUSER                     = 200
	SqlBaseParserUSING                    = 201
	SqlBaseParserVALIDATE                 = 202
	SqlBaseParserVALUES                   = 203
	SqlBaseParserVERBOSE                  = 204
	SqlBaseParserVIEW                     = 205
	SqlBaseParserWHEN                     = 206
	SqlBaseParserWHERE                    = 207
	SqlBaseParserWITH                     = 208
	SqlBaseParserWORK                     = 209
	SqlBaseParserWRITE                    = 210
	SqlBaseParserYEAR                     = 211
	SqlBaseParserZONE                     = 212
	SqlBaseParserEQ                       = 213
	SqlBaseParserNEQ                      = 214
	SqlBaseParserLT                       = 215
	SqlBaseParserLTE                      = 216
	SqlBaseParserGT                       = 217
	SqlBaseParserGTE                      = 218
	SqlBaseParserPLUS                     = 219
	SqlBaseParserMINUS                    = 220
	SqlBaseParserASTERISK                 = 221
	SqlBaseParserSLASH                    = 222
	SqlBaseParserPERCENT                  = 223
	SqlBaseParserCONCAT                   = 224
	SqlBaseParserSTRING                   = 225
	SqlBaseParserUNICODE_STRING           = 226
	SqlBaseParserBINARY_LITERAL           = 227
	SqlBaseParserINTEGER_VALUE            = 228
	SqlBaseParserDECIMAL_VALUE            = 229
	SqlBaseParserDOUBLE_VALUE             = 230
	SqlBaseParserIDENTIFIER               = 231
	SqlBaseParserDIGIT_IDENTIFIER         = 232
	SqlBaseParserQUOTED_IDENTIFIER        = 233
	SqlBaseParserBACKQUOTED_IDENTIFIER    = 234
	SqlBaseParserTIME_WITH_TIME_ZONE      = 235
	SqlBaseParserTIMESTAMP_WITH_TIME_ZONE = 236
	SqlBaseParserDOUBLE_PRECISION         = 237
	SqlBaseParserSIMPLE_COMMENT           = 238
	SqlBaseParserBRACKETED_COMMENT        = 239
	SqlBaseParserWS                       = 240
	SqlBaseParserUNRECOGNIZED             = 241
	SqlBaseParserDELIMITER                = 242
)

// SqlBaseParser rules.
const (
	SqlBaseParserRULE_singleStatement             = 0
	SqlBaseParserRULE_standaloneExpression        = 1
	SqlBaseParserRULE_standaloneRoutineBody       = 2
	SqlBaseParserRULE_statement                   = 3
	SqlBaseParserRULE_query                       = 4
	SqlBaseParserRULE_with                        = 5
	SqlBaseParserRULE_tableElement                = 6
	SqlBaseParserRULE_columnDefinition            = 7
	SqlBaseParserRULE_likeClause                  = 8
	SqlBaseParserRULE_properties                  = 9
	SqlBaseParserRULE_property                    = 10
	SqlBaseParserRULE_sqlParameterDeclaration     = 11
	SqlBaseParserRULE_routineCharacteristics      = 12
	SqlBaseParserRULE_routineCharacteristic       = 13
	SqlBaseParserRULE_alterRoutineCharacteristics = 14
	SqlBaseParserRULE_alterRoutineCharacteristic  = 15
	SqlBaseParserRULE_routineBody                 = 16
	SqlBaseParserRULE_returnStatement             = 17
	SqlBaseParserRULE_externalBodyReference       = 18
	SqlBaseParserRULE_language                    = 19
	SqlBaseParserRULE_determinism                 = 20
	SqlBaseParserRULE_nullCallClause              = 21
	SqlBaseParserRULE_externalRoutineName         = 22
	SqlBaseParserRULE_queryNoWith                 = 23
	SqlBaseParserRULE_queryTerm                   = 24
	SqlBaseParserRULE_queryPrimary                = 25
	SqlBaseParserRULE_sortItem                    = 26
	SqlBaseParserRULE_querySpecification          = 27
	SqlBaseParserRULE_groupBy                     = 28
	SqlBaseParserRULE_groupingElement             = 29
	SqlBaseParserRULE_groupingSet                 = 30
	SqlBaseParserRULE_namedQuery                  = 31
	SqlBaseParserRULE_setQuantifier               = 32
	SqlBaseParserRULE_selectItem                  = 33
	SqlBaseParserRULE_relation                    = 34
	SqlBaseParserRULE_joinType                    = 35
	SqlBaseParserRULE_joinCriteria                = 36
	SqlBaseParserRULE_sampledRelation             = 37
	SqlBaseParserRULE_sampleType                  = 38
	SqlBaseParserRULE_aliasedRelation             = 39
	SqlBaseParserRULE_columnAliases               = 40
	SqlBaseParserRULE_relationPrimary             = 41
	SqlBaseParserRULE_expression                  = 42
	SqlBaseParserRULE_booleanExpression           = 43
	SqlBaseParserRULE_predicate                   = 44
	SqlBaseParserRULE_valueExpression             = 45
	SqlBaseParserRULE_primaryExpression           = 46
	SqlBaseParserRULE_string_                     = 47
	SqlBaseParserRULE_nullTreatment               = 48
	SqlBaseParserRULE_timeZoneSpecifier           = 49
	SqlBaseParserRULE_comparisonOperator          = 50
	SqlBaseParserRULE_comparisonQuantifier        = 51
	SqlBaseParserRULE_booleanValue                = 52
	SqlBaseParserRULE_interval                    = 53
	SqlBaseParserRULE_intervalField               = 54
	SqlBaseParserRULE_normalForm                  = 55
	SqlBaseParserRULE_types                       = 56
	SqlBaseParserRULE_type_                       = 57
	SqlBaseParserRULE_typeParameter               = 58
	SqlBaseParserRULE_baseType                    = 59
	SqlBaseParserRULE_whenClause                  = 60
	SqlBaseParserRULE_filter                      = 61
	SqlBaseParserRULE_over                        = 62
	SqlBaseParserRULE_windowFrame                 = 63
	SqlBaseParserRULE_frameBound                  = 64
	SqlBaseParserRULE_explainOption               = 65
	SqlBaseParserRULE_transactionMode             = 66
	SqlBaseParserRULE_levelOfIsolation            = 67
	SqlBaseParserRULE_callArgument                = 68
	SqlBaseParserRULE_privilege                   = 69
	SqlBaseParserRULE_qualifiedName               = 70
	SqlBaseParserRULE_grantor                     = 71
	SqlBaseParserRULE_principal                   = 72
	SqlBaseParserRULE_roles                       = 73
	SqlBaseParserRULE_identifier                  = 74
	SqlBaseParserRULE_number                      = 75
	SqlBaseParserRULE_nonReserved                 = 76
)

// ISingleStatementContext is an interface to support dynamic dispatch.
type ISingleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingleStatementContext differentiates from other interfaces.
	IsSingleStatementContext()
}

type SingleStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleStatementContext() *SingleStatementContext {
	var p = new(SingleStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_singleStatement
	return p
}

func (*SingleStatementContext) IsSingleStatementContext() {}

func NewSingleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleStatementContext {
	var p = new(SingleStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_singleStatement

	return p
}

func (s *SingleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SingleStatementContext) EOF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEOF, 0)
}

func (s *SingleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSingleStatement(s)
	}
}

func (s *SingleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSingleStatement(s)
	}
}

func (s *SingleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSingleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) SingleStatement() (localctx ISingleStatementContext) {
	localctx = NewSingleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, SqlBaseParserRULE_singleStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(154)
		p.Statement()
	}
	{
		p.SetState(155)
		p.Match(SqlBaseParserEOF)
	}

	return localctx
}

// IStandaloneExpressionContext is an interface to support dynamic dispatch.
type IStandaloneExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStandaloneExpressionContext differentiates from other interfaces.
	IsStandaloneExpressionContext()
}

type StandaloneExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStandaloneExpressionContext() *StandaloneExpressionContext {
	var p = new(StandaloneExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_standaloneExpression
	return p
}

func (*StandaloneExpressionContext) IsStandaloneExpressionContext() {}

func NewStandaloneExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StandaloneExpressionContext {
	var p = new(StandaloneExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_standaloneExpression

	return p
}

func (s *StandaloneExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *StandaloneExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StandaloneExpressionContext) EOF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEOF, 0)
}

func (s *StandaloneExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StandaloneExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StandaloneExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterStandaloneExpression(s)
	}
}

func (s *StandaloneExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitStandaloneExpression(s)
	}
}

func (s *StandaloneExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitStandaloneExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) StandaloneExpression() (localctx IStandaloneExpressionContext) {
	localctx = NewStandaloneExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, SqlBaseParserRULE_standaloneExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(157)
		p.Expression()
	}
	{
		p.SetState(158)
		p.Match(SqlBaseParserEOF)
	}

	return localctx
}

// IStandaloneRoutineBodyContext is an interface to support dynamic dispatch.
type IStandaloneRoutineBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStandaloneRoutineBodyContext differentiates from other interfaces.
	IsStandaloneRoutineBodyContext()
}

type StandaloneRoutineBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStandaloneRoutineBodyContext() *StandaloneRoutineBodyContext {
	var p = new(StandaloneRoutineBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_standaloneRoutineBody
	return p
}

func (*StandaloneRoutineBodyContext) IsStandaloneRoutineBodyContext() {}

func NewStandaloneRoutineBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StandaloneRoutineBodyContext {
	var p = new(StandaloneRoutineBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_standaloneRoutineBody

	return p
}

func (s *StandaloneRoutineBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *StandaloneRoutineBodyContext) RoutineBody() IRoutineBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRoutineBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRoutineBodyContext)
}

func (s *StandaloneRoutineBodyContext) EOF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEOF, 0)
}

func (s *StandaloneRoutineBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StandaloneRoutineBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StandaloneRoutineBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterStandaloneRoutineBody(s)
	}
}

func (s *StandaloneRoutineBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitStandaloneRoutineBody(s)
	}
}

func (s *StandaloneRoutineBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitStandaloneRoutineBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) StandaloneRoutineBody() (localctx IStandaloneRoutineBodyContext) {
	localctx = NewStandaloneRoutineBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, SqlBaseParserRULE_standaloneRoutineBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(160)
		p.RoutineBody()
	}
	{
		p.SetState(161)
		p.Match(SqlBaseParserEOF)
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) CopyFrom(ctx *StatementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ExplainContext struct {
	*StatementContext
}

func NewExplainContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExplainContext {
	var p = new(ExplainContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ExplainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXPLAIN, 0)
}

func (s *ExplainContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ExplainContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserANALYZE, 0)
}

func (s *ExplainContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVERBOSE, 0)
}

func (s *ExplainContext) AllExplainOption() []IExplainOptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExplainOptionContext)(nil)).Elem())
	var tst = make([]IExplainOptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExplainOptionContext)
		}
	}

	return tst
}

func (s *ExplainContext) ExplainOption(i int) IExplainOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExplainOptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExplainOptionContext)
}

func (s *ExplainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterExplain(s)
	}
}

func (s *ExplainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitExplain(s)
	}
}

func (s *ExplainContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitExplain(s)

	default:
		return t.VisitChildren(s)
	}
}

type PrepareContext struct {
	*StatementContext
}

func NewPrepareContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrepareContext {
	var p = new(PrepareContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *PrepareContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrepareContext) PREPARE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPREPARE, 0)
}

func (s *PrepareContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PrepareContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *PrepareContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *PrepareContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterPrepare(s)
	}
}

func (s *PrepareContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitPrepare(s)
	}
}

func (s *PrepareContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitPrepare(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropMaterializedViewContext struct {
	*StatementContext
}

func NewDropMaterializedViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropMaterializedViewContext {
	var p = new(DropMaterializedViewContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DropMaterializedViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropMaterializedViewContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDROP, 0)
}

func (s *DropMaterializedViewContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMATERIALIZED, 0)
}

func (s *DropMaterializedViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVIEW, 0)
}

func (s *DropMaterializedViewContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropMaterializedViewContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *DropMaterializedViewContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *DropMaterializedViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDropMaterializedView(s)
	}
}

func (s *DropMaterializedViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDropMaterializedView(s)
	}
}

func (s *DropMaterializedViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitDropMaterializedView(s)

	default:
		return t.VisitChildren(s)
	}
}

type UseContext struct {
	*StatementContext
	schema  IIdentifierContext
	catalog IIdentifierContext
}

func NewUseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UseContext {
	var p = new(UseContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *UseContext) GetSchema() IIdentifierContext { return s.schema }

func (s *UseContext) GetCatalog() IIdentifierContext { return s.catalog }

func (s *UseContext) SetSchema(v IIdentifierContext) { s.schema = v }

func (s *UseContext) SetCatalog(v IIdentifierContext) { s.catalog = v }

func (s *UseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseContext) USE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUSE, 0)
}

func (s *UseContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *UseContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterUse(s)
	}
}

func (s *UseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitUse(s)
	}
}

func (s *UseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitUse(s)

	default:
		return t.VisitChildren(s)
	}
}

type DeallocateContext struct {
	*StatementContext
}

func NewDeallocateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DeallocateContext {
	var p = new(DeallocateContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DeallocateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeallocateContext) DEALLOCATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDEALLOCATE, 0)
}

func (s *DeallocateContext) PREPARE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPREPARE, 0)
}

func (s *DeallocateContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DeallocateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDeallocate(s)
	}
}

func (s *DeallocateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDeallocate(s)
	}
}

func (s *DeallocateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitDeallocate(s)

	default:
		return t.VisitChildren(s)
	}
}

type RenameTableContext struct {
	*StatementContext
	from IQualifiedNameContext
	to   IQualifiedNameContext
}

func NewRenameTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RenameTableContext {
	var p = new(RenameTableContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *RenameTableContext) GetFrom() IQualifiedNameContext { return s.from }

func (s *RenameTableContext) GetTo() IQualifiedNameContext { return s.to }

func (s *RenameTableContext) SetFrom(v IQualifiedNameContext) { s.from = v }

func (s *RenameTableContext) SetTo(v IQualifiedNameContext) { s.to = v }

func (s *RenameTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameTableContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *RenameTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *RenameTableContext) RENAME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRENAME, 0)
}

func (s *RenameTableContext) TO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTO, 0)
}

func (s *RenameTableContext) AllQualifiedName() []IQualifiedNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem())
	var tst = make([]IQualifiedNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQualifiedNameContext)
		}
	}

	return tst
}

func (s *RenameTableContext) QualifiedName(i int) IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RenameTableContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *RenameTableContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *RenameTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRenameTable(s)
	}
}

func (s *RenameTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRenameTable(s)
	}
}

func (s *RenameTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitRenameTable(s)

	default:
		return t.VisitChildren(s)
	}
}

type CommitContext struct {
	*StatementContext
}

func NewCommitContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CommitContext {
	var p = new(CommitContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *CommitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommitContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMIT, 0)
}

func (s *CommitContext) WORK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWORK, 0)
}

func (s *CommitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCommit(s)
	}
}

func (s *CommitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCommit(s)
	}
}

func (s *CommitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitCommit(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateRoleContext struct {
	*StatementContext
	name IIdentifierContext
}

func NewCreateRoleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateRoleContext {
	var p = new(CreateRoleContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *CreateRoleContext) GetName() IIdentifierContext { return s.name }

func (s *CreateRoleContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRoleContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *CreateRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLE, 0)
}

func (s *CreateRoleContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateRoleContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *CreateRoleContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserADMIN, 0)
}

func (s *CreateRoleContext) Grantor() IGrantorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGrantorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGrantorContext)
}

func (s *CreateRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCreateRole(s)
	}
}

func (s *CreateRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCreateRole(s)
	}
}

func (s *CreateRoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitCreateRole(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowCreateFunctionContext struct {
	*StatementContext
}

func NewShowCreateFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateFunctionContext {
	var p = new(ShowCreateFunctionContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowCreateFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateFunctionContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowCreateFunctionContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *ShowCreateFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFUNCTION, 0)
}

func (s *ShowCreateFunctionContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowCreateFunctionContext) Types() ITypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypesContext)
}

func (s *ShowCreateFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowCreateFunction(s)
	}
}

func (s *ShowCreateFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowCreateFunction(s)
	}
}

func (s *ShowCreateFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitShowCreateFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropColumnContext struct {
	*StatementContext
	tableName IQualifiedNameContext
	column    IQualifiedNameContext
}

func NewDropColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropColumnContext {
	var p = new(DropColumnContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DropColumnContext) GetTableName() IQualifiedNameContext { return s.tableName }

func (s *DropColumnContext) GetColumn() IQualifiedNameContext { return s.column }

func (s *DropColumnContext) SetTableName(v IQualifiedNameContext) { s.tableName = v }

func (s *DropColumnContext) SetColumn(v IQualifiedNameContext) { s.column = v }

func (s *DropColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropColumnContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *DropColumnContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *DropColumnContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDROP, 0)
}

func (s *DropColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLUMN, 0)
}

func (s *DropColumnContext) AllQualifiedName() []IQualifiedNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem())
	var tst = make([]IQualifiedNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQualifiedNameContext)
		}
	}

	return tst
}

func (s *DropColumnContext) QualifiedName(i int) IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropColumnContext) AllIF() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserIF)
}

func (s *DropColumnContext) IF(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, i)
}

func (s *DropColumnContext) AllEXISTS() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserEXISTS)
}

func (s *DropColumnContext) EXISTS(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, i)
}

func (s *DropColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDropColumn(s)
	}
}

func (s *DropColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDropColumn(s)
	}
}

func (s *DropColumnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitDropColumn(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropViewContext struct {
	*StatementContext
}

func NewDropViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropViewContext {
	var p = new(DropViewContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DropViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropViewContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDROP, 0)
}

func (s *DropViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVIEW, 0)
}

func (s *DropViewContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropViewContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *DropViewContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *DropViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDropView(s)
	}
}

func (s *DropViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDropView(s)
	}
}

func (s *DropViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitDropView(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowTablesContext struct {
	*StatementContext
	pattern IString_Context
	escape  IString_Context
}

func NewShowTablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTablesContext {
	var p = new(ShowTablesContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowTablesContext) GetPattern() IString_Context { return s.pattern }

func (s *ShowTablesContext) GetEscape() IString_Context { return s.escape }

func (s *ShowTablesContext) SetPattern(v IString_Context) { s.pattern = v }

func (s *ShowTablesContext) SetEscape(v IString_Context) { s.escape = v }

func (s *ShowTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTablesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowTablesContext) TABLES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLES, 0)
}

func (s *ShowTablesContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowTablesContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIKE, 0)
}

func (s *ShowTablesContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *ShowTablesContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, 0)
}

func (s *ShowTablesContext) AllString_() []IString_Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IString_Context)(nil)).Elem())
	var tst = make([]IString_Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IString_Context)
		}
	}

	return tst
}

func (s *ShowTablesContext) String_(i int) IString_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *ShowTablesContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserESCAPE, 0)
}

func (s *ShowTablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowTables(s)
	}
}

func (s *ShowTablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowTables(s)
	}
}

func (s *ShowTablesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitShowTables(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowCatalogsContext struct {
	*StatementContext
	pattern IString_Context
}

func NewShowCatalogsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCatalogsContext {
	var p = new(ShowCatalogsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowCatalogsContext) GetPattern() IString_Context { return s.pattern }

func (s *ShowCatalogsContext) SetPattern(v IString_Context) { s.pattern = v }

func (s *ShowCatalogsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCatalogsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowCatalogsContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCATALOGS, 0)
}

func (s *ShowCatalogsContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIKE, 0)
}

func (s *ShowCatalogsContext) String_() IString_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *ShowCatalogsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowCatalogs(s)
	}
}

func (s *ShowCatalogsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowCatalogs(s)
	}
}

func (s *ShowCatalogsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitShowCatalogs(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowRolesContext struct {
	*StatementContext
}

func NewShowRolesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowRolesContext {
	var p = new(ShowRolesContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowRolesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRolesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowRolesContext) ROLES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLES, 0)
}

func (s *ShowRolesContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT, 0)
}

func (s *ShowRolesContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowRolesContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *ShowRolesContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, 0)
}

func (s *ShowRolesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowRoles(s)
	}
}

func (s *ShowRolesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowRoles(s)
	}
}

func (s *ShowRolesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitShowRoles(s)

	default:
		return t.VisitChildren(s)
	}
}

type RenameColumnContext struct {
	*StatementContext
	tableName IQualifiedNameContext
	from      IIdentifierContext
	to        IIdentifierContext
}

func NewRenameColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RenameColumnContext {
	var p = new(RenameColumnContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *RenameColumnContext) GetTableName() IQualifiedNameContext { return s.tableName }

func (s *RenameColumnContext) GetFrom() IIdentifierContext { return s.from }

func (s *RenameColumnContext) GetTo() IIdentifierContext { return s.to }

func (s *RenameColumnContext) SetTableName(v IQualifiedNameContext) { s.tableName = v }

func (s *RenameColumnContext) SetFrom(v IIdentifierContext) { s.from = v }

func (s *RenameColumnContext) SetTo(v IIdentifierContext) { s.to = v }

func (s *RenameColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameColumnContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *RenameColumnContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *RenameColumnContext) RENAME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRENAME, 0)
}

func (s *RenameColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLUMN, 0)
}

func (s *RenameColumnContext) TO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTO, 0)
}

func (s *RenameColumnContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RenameColumnContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *RenameColumnContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RenameColumnContext) AllIF() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserIF)
}

func (s *RenameColumnContext) IF(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, i)
}

func (s *RenameColumnContext) AllEXISTS() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserEXISTS)
}

func (s *RenameColumnContext) EXISTS(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, i)
}

func (s *RenameColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRenameColumn(s)
	}
}

func (s *RenameColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRenameColumn(s)
	}
}

func (s *RenameColumnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitRenameColumn(s)

	default:
		return t.VisitChildren(s)
	}
}

type RevokeRolesContext struct {
	*StatementContext
}

func NewRevokeRolesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeRolesContext {
	var p = new(RevokeRolesContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *RevokeRolesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeRolesContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREVOKE, 0)
}

func (s *RevokeRolesContext) Roles() IRolesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRolesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRolesContext)
}

func (s *RevokeRolesContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *RevokeRolesContext) AllPrincipal() []IPrincipalContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPrincipalContext)(nil)).Elem())
	var tst = make([]IPrincipalContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPrincipalContext)
		}
	}

	return tst
}

func (s *RevokeRolesContext) Principal(i int) IPrincipalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrincipalContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPrincipalContext)
}

func (s *RevokeRolesContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserADMIN, 0)
}

func (s *RevokeRolesContext) OPTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOPTION, 0)
}

func (s *RevokeRolesContext) FOR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOR, 0)
}

func (s *RevokeRolesContext) GRANTED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGRANTED, 0)
}

func (s *RevokeRolesContext) BY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBY, 0)
}

func (s *RevokeRolesContext) Grantor() IGrantorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGrantorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGrantorContext)
}

func (s *RevokeRolesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRevokeRoles(s)
	}
}

func (s *RevokeRolesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRevokeRoles(s)
	}
}

func (s *RevokeRolesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitRevokeRoles(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowCreateTableContext struct {
	*StatementContext
}

func NewShowCreateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateTableContext {
	var p = new(ShowCreateTableContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowCreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateTableContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowCreateTableContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *ShowCreateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *ShowCreateTableContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowCreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowCreateTable(s)
	}
}

func (s *ShowCreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowCreateTable(s)
	}
}

func (s *ShowCreateTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitShowCreateTable(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowColumnsContext struct {
	*StatementContext
}

func NewShowColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowColumnsContext {
	var p = new(ShowColumnsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowColumnsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowColumnsContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLUMNS, 0)
}

func (s *ShowColumnsContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowColumnsContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *ShowColumnsContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, 0)
}

func (s *ShowColumnsContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDESCRIBE, 0)
}

func (s *ShowColumnsContext) DESC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDESC, 0)
}

func (s *ShowColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowColumns(s)
	}
}

func (s *ShowColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowColumns(s)
	}
}

func (s *ShowColumnsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitShowColumns(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowRoleGrantsContext struct {
	*StatementContext
}

func NewShowRoleGrantsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowRoleGrantsContext {
	var p = new(ShowRoleGrantsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowRoleGrantsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRoleGrantsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowRoleGrantsContext) ROLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLE, 0)
}

func (s *ShowRoleGrantsContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGRANTS, 0)
}

func (s *ShowRoleGrantsContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowRoleGrantsContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *ShowRoleGrantsContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, 0)
}

func (s *ShowRoleGrantsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowRoleGrants(s)
	}
}

func (s *ShowRoleGrantsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowRoleGrants(s)
	}
}

func (s *ShowRoleGrantsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitShowRoleGrants(s)

	default:
		return t.VisitChildren(s)
	}
}

type AddColumnContext struct {
	*StatementContext
	tableName IQualifiedNameContext
	column    IColumnDefinitionContext
}

func NewAddColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddColumnContext {
	var p = new(AddColumnContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *AddColumnContext) GetTableName() IQualifiedNameContext { return s.tableName }

func (s *AddColumnContext) GetColumn() IColumnDefinitionContext { return s.column }

func (s *AddColumnContext) SetTableName(v IQualifiedNameContext) { s.tableName = v }

func (s *AddColumnContext) SetColumn(v IColumnDefinitionContext) { s.column = v }

func (s *AddColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddColumnContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *AddColumnContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *AddColumnContext) ADD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserADD, 0)
}

func (s *AddColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLUMN, 0)
}

func (s *AddColumnContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AddColumnContext) ColumnDefinition() IColumnDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *AddColumnContext) AllIF() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserIF)
}

func (s *AddColumnContext) IF(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, i)
}

func (s *AddColumnContext) AllEXISTS() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserEXISTS)
}

func (s *AddColumnContext) EXISTS(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, i)
}

func (s *AddColumnContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *AddColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterAddColumn(s)
	}
}

func (s *AddColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitAddColumn(s)
	}
}

func (s *AddColumnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitAddColumn(s)

	default:
		return t.VisitChildren(s)
	}
}

type ResetSessionContext struct {
	*StatementContext
}

func NewResetSessionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ResetSessionContext {
	var p = new(ResetSessionContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ResetSessionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResetSessionContext) RESET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRESET, 0)
}

func (s *ResetSessionContext) SESSION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSESSION, 0)
}

func (s *ResetSessionContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ResetSessionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterResetSession(s)
	}
}

func (s *ResetSessionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitResetSession(s)
	}
}

func (s *ResetSessionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitResetSession(s)

	default:
		return t.VisitChildren(s)
	}
}

type InsertIntoContext struct {
	*StatementContext
}

func NewInsertIntoContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InsertIntoContext {
	var p = new(InsertIntoContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *InsertIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertIntoContext) INSERT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINSERT, 0)
}

func (s *InsertIntoContext) INTO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTO, 0)
}

func (s *InsertIntoContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *InsertIntoContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *InsertIntoContext) ColumnAliases() IColumnAliasesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnAliasesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *InsertIntoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterInsertInto(s)
	}
}

func (s *InsertIntoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitInsertInto(s)
	}
}

func (s *InsertIntoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitInsertInto(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowSessionContext struct {
	*StatementContext
}

func NewShowSessionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowSessionContext {
	var p = new(ShowSessionContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowSessionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSessionContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowSessionContext) SESSION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSESSION, 0)
}

func (s *ShowSessionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowSession(s)
	}
}

func (s *ShowSessionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowSession(s)
	}
}

func (s *ShowSessionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitShowSession(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateSchemaContext struct {
	*StatementContext
}

func NewCreateSchemaContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateSchemaContext {
	var p = new(CreateSchemaContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *CreateSchemaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateSchemaContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *CreateSchemaContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSCHEMA, 0)
}

func (s *CreateSchemaContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateSchemaContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *CreateSchemaContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *CreateSchemaContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *CreateSchemaContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *CreateSchemaContext) Properties() IPropertiesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertiesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateSchemaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCreateSchema(s)
	}
}

func (s *CreateSchemaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCreateSchema(s)
	}
}

func (s *CreateSchemaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitCreateSchema(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExecuteContext struct {
	*StatementContext
}

func NewExecuteContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExecuteContext {
	var p = new(ExecuteContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ExecuteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecuteContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXECUTE, 0)
}

func (s *ExecuteContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExecuteContext) USING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUSING, 0)
}

func (s *ExecuteContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ExecuteContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExecuteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterExecute(s)
	}
}

func (s *ExecuteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitExecute(s)
	}
}

func (s *ExecuteContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitExecute(s)

	default:
		return t.VisitChildren(s)
	}
}

type RenameSchemaContext struct {
	*StatementContext
}

func NewRenameSchemaContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RenameSchemaContext {
	var p = new(RenameSchemaContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *RenameSchemaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameSchemaContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *RenameSchemaContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSCHEMA, 0)
}

func (s *RenameSchemaContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RenameSchemaContext) RENAME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRENAME, 0)
}

func (s *RenameSchemaContext) TO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTO, 0)
}

func (s *RenameSchemaContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RenameSchemaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRenameSchema(s)
	}
}

func (s *RenameSchemaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRenameSchema(s)
	}
}

func (s *RenameSchemaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitRenameSchema(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropRoleContext struct {
	*StatementContext
	name IIdentifierContext
}

func NewDropRoleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropRoleContext {
	var p = new(DropRoleContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DropRoleContext) GetName() IIdentifierContext { return s.name }

func (s *DropRoleContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRoleContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDROP, 0)
}

func (s *DropRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLE, 0)
}

func (s *DropRoleContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDropRole(s)
	}
}

func (s *DropRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDropRole(s)
	}
}

func (s *DropRoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitDropRole(s)

	default:
		return t.VisitChildren(s)
	}
}

type AnalyzeContext struct {
	*StatementContext
}

func NewAnalyzeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AnalyzeContext {
	var p = new(AnalyzeContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *AnalyzeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalyzeContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserANALYZE, 0)
}

func (s *AnalyzeContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AnalyzeContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *AnalyzeContext) Properties() IPropertiesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertiesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AnalyzeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterAnalyze(s)
	}
}

func (s *AnalyzeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitAnalyze(s)
	}
}

func (s *AnalyzeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitAnalyze(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetRoleContext struct {
	*StatementContext
	role IIdentifierContext
}

func NewSetRoleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetRoleContext {
	var p = new(SetRoleContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *SetRoleContext) GetRole() IIdentifierContext { return s.role }

func (s *SetRoleContext) SetRole(v IIdentifierContext) { s.role = v }

func (s *SetRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetRoleContext) SET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSET, 0)
}

func (s *SetRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLE, 0)
}

func (s *SetRoleContext) ALL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALL, 0)
}

func (s *SetRoleContext) NONE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNONE, 0)
}

func (s *SetRoleContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSetRole(s)
	}
}

func (s *SetRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSetRole(s)
	}
}

func (s *SetRoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSetRole(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateFunctionContext struct {
	*StatementContext
	functionName IQualifiedNameContext
	returnType   IType_Context
}

func NewCreateFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateFunctionContext {
	var p = new(CreateFunctionContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *CreateFunctionContext) GetFunctionName() IQualifiedNameContext { return s.functionName }

func (s *CreateFunctionContext) GetReturnType() IType_Context { return s.returnType }

func (s *CreateFunctionContext) SetFunctionName(v IQualifiedNameContext) { s.functionName = v }

func (s *CreateFunctionContext) SetReturnType(v IType_Context) { s.returnType = v }

func (s *CreateFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateFunctionContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *CreateFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFUNCTION, 0)
}

func (s *CreateFunctionContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRETURNS, 0)
}

func (s *CreateFunctionContext) RoutineCharacteristics() IRoutineCharacteristicsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRoutineCharacteristicsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRoutineCharacteristicsContext)
}

func (s *CreateFunctionContext) RoutineBody() IRoutineBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRoutineBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRoutineBodyContext)
}

func (s *CreateFunctionContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateFunctionContext) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *CreateFunctionContext) OR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOR, 0)
}

func (s *CreateFunctionContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREPLACE, 0)
}

func (s *CreateFunctionContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTEMPORARY, 0)
}

func (s *CreateFunctionContext) AllSqlParameterDeclaration() []ISqlParameterDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISqlParameterDeclarationContext)(nil)).Elem())
	var tst = make([]ISqlParameterDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISqlParameterDeclarationContext)
		}
	}

	return tst
}

func (s *CreateFunctionContext) SqlParameterDeclaration(i int) ISqlParameterDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISqlParameterDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISqlParameterDeclarationContext)
}

func (s *CreateFunctionContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMENT, 0)
}

func (s *CreateFunctionContext) String_() IString_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *CreateFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCreateFunction(s)
	}
}

func (s *CreateFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCreateFunction(s)
	}
}

func (s *CreateFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitCreateFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowGrantsContext struct {
	*StatementContext
}

func NewShowGrantsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowGrantsContext {
	var p = new(ShowGrantsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowGrantsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowGrantsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowGrantsContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGRANTS, 0)
}

func (s *ShowGrantsContext) ON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserON, 0)
}

func (s *ShowGrantsContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowGrantsContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *ShowGrantsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowGrants(s)
	}
}

func (s *ShowGrantsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowGrants(s)
	}
}

func (s *ShowGrantsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitShowGrants(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropSchemaContext struct {
	*StatementContext
}

func NewDropSchemaContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropSchemaContext {
	var p = new(DropSchemaContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DropSchemaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropSchemaContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDROP, 0)
}

func (s *DropSchemaContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSCHEMA, 0)
}

func (s *DropSchemaContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropSchemaContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *DropSchemaContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *DropSchemaContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCASCADE, 0)
}

func (s *DropSchemaContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRESTRICT, 0)
}

func (s *DropSchemaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDropSchema(s)
	}
}

func (s *DropSchemaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDropSchema(s)
	}
}

func (s *DropSchemaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitDropSchema(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowCreateViewContext struct {
	*StatementContext
}

func NewShowCreateViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateViewContext {
	var p = new(ShowCreateViewContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowCreateViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateViewContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowCreateViewContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *ShowCreateViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVIEW, 0)
}

func (s *ShowCreateViewContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowCreateViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowCreateView(s)
	}
}

func (s *ShowCreateViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowCreateView(s)
	}
}

func (s *ShowCreateViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitShowCreateView(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateTableContext struct {
	*StatementContext
}

func NewCreateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateTableContext {
	var p = new(CreateTableContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *CreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *CreateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *CreateTableContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateTableContext) AllTableElement() []ITableElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITableElementContext)(nil)).Elem())
	var tst = make([]ITableElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITableElementContext)
		}
	}

	return tst
}

func (s *CreateTableContext) TableElement(i int) ITableElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITableElementContext)
}

func (s *CreateTableContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *CreateTableContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *CreateTableContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *CreateTableContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMENT, 0)
}

func (s *CreateTableContext) String_() IString_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *CreateTableContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *CreateTableContext) Properties() IPropertiesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertiesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCreateTable(s)
	}
}

func (s *CreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCreateTable(s)
	}
}

func (s *CreateTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitCreateTable(s)

	default:
		return t.VisitChildren(s)
	}
}

type StartTransactionContext struct {
	*StatementContext
}

func NewStartTransactionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StartTransactionContext {
	var p = new(StartTransactionContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *StartTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartTransactionContext) START() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTART, 0)
}

func (s *StartTransactionContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRANSACTION, 0)
}

func (s *StartTransactionContext) AllTransactionMode() []ITransactionModeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITransactionModeContext)(nil)).Elem())
	var tst = make([]ITransactionModeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITransactionModeContext)
		}
	}

	return tst
}

func (s *StartTransactionContext) TransactionMode(i int) ITransactionModeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransactionModeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITransactionModeContext)
}

func (s *StartTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterStartTransaction(s)
	}
}

func (s *StartTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitStartTransaction(s)
	}
}

func (s *StartTransactionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitStartTransaction(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateTableAsSelectContext struct {
	*StatementContext
}

func NewCreateTableAsSelectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateTableAsSelectContext {
	var p = new(CreateTableAsSelectContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *CreateTableAsSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableAsSelectContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *CreateTableAsSelectContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *CreateTableAsSelectContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateTableAsSelectContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *CreateTableAsSelectContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *CreateTableAsSelectContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *CreateTableAsSelectContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *CreateTableAsSelectContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *CreateTableAsSelectContext) ColumnAliases() IColumnAliasesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnAliasesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *CreateTableAsSelectContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMENT, 0)
}

func (s *CreateTableAsSelectContext) String_() IString_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *CreateTableAsSelectContext) AllWITH() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserWITH)
}

func (s *CreateTableAsSelectContext) WITH(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, i)
}

func (s *CreateTableAsSelectContext) Properties() IPropertiesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertiesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateTableAsSelectContext) DATA() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATA, 0)
}

func (s *CreateTableAsSelectContext) NO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNO, 0)
}

func (s *CreateTableAsSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCreateTableAsSelect(s)
	}
}

func (s *CreateTableAsSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCreateTableAsSelect(s)
	}
}

func (s *CreateTableAsSelectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitCreateTableAsSelect(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowStatsContext struct {
	*StatementContext
}

func NewShowStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowStatsContext {
	var p = new(ShowStatsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStatsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTATS, 0)
}

func (s *ShowStatsContext) FOR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOR, 0)
}

func (s *ShowStatsContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowStatsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowStats(s)
	}
}

func (s *ShowStatsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowStats(s)
	}
}

func (s *ShowStatsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitShowStats(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropFunctionContext struct {
	*StatementContext
}

func NewDropFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropFunctionContext {
	var p = new(DropFunctionContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DropFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFunctionContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDROP, 0)
}

func (s *DropFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFUNCTION, 0)
}

func (s *DropFunctionContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropFunctionContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTEMPORARY, 0)
}

func (s *DropFunctionContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *DropFunctionContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *DropFunctionContext) Types() ITypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypesContext)
}

func (s *DropFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDropFunction(s)
	}
}

func (s *DropFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDropFunction(s)
	}
}

func (s *DropFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitDropFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type RevokeContext struct {
	*StatementContext
	grantee IPrincipalContext
}

func NewRevokeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeContext {
	var p = new(RevokeContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *RevokeContext) GetGrantee() IPrincipalContext { return s.grantee }

func (s *RevokeContext) SetGrantee(v IPrincipalContext) { s.grantee = v }

func (s *RevokeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREVOKE, 0)
}

func (s *RevokeContext) ON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserON, 0)
}

func (s *RevokeContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RevokeContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *RevokeContext) Principal() IPrincipalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrincipalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrincipalContext)
}

func (s *RevokeContext) AllPrivilege() []IPrivilegeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPrivilegeContext)(nil)).Elem())
	var tst = make([]IPrivilegeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPrivilegeContext)
		}
	}

	return tst
}

func (s *RevokeContext) Privilege(i int) IPrivilegeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrivilegeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPrivilegeContext)
}

func (s *RevokeContext) ALL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALL, 0)
}

func (s *RevokeContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPRIVILEGES, 0)
}

func (s *RevokeContext) GRANT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGRANT, 0)
}

func (s *RevokeContext) OPTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOPTION, 0)
}

func (s *RevokeContext) FOR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOR, 0)
}

func (s *RevokeContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *RevokeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRevoke(s)
	}
}

func (s *RevokeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRevoke(s)
	}
}

func (s *RevokeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitRevoke(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateTypeContext struct {
	*StatementContext
}

func NewCreateTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateTypeContext {
	var p = new(CreateTypeContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *CreateTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTypeContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *CreateTypeContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTYPE, 0)
}

func (s *CreateTypeContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateTypeContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *CreateTypeContext) AllSqlParameterDeclaration() []ISqlParameterDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISqlParameterDeclarationContext)(nil)).Elem())
	var tst = make([]ISqlParameterDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISqlParameterDeclarationContext)
		}
	}

	return tst
}

func (s *CreateTypeContext) SqlParameterDeclaration(i int) ISqlParameterDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISqlParameterDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISqlParameterDeclarationContext)
}

func (s *CreateTypeContext) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *CreateTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCreateType(s)
	}
}

func (s *CreateTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCreateType(s)
	}
}

func (s *CreateTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitCreateType(s)

	default:
		return t.VisitChildren(s)
	}
}

type DeleteContext struct {
	*StatementContext
}

func NewDeleteContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DeleteContext {
	var p = new(DeleteContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DeleteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteContext) DELETE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDELETE, 0)
}

func (s *DeleteContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *DeleteContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DeleteContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWHERE, 0)
}

func (s *DeleteContext) BooleanExpression() IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *DeleteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDelete(s)
	}
}

func (s *DeleteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDelete(s)
	}
}

func (s *DeleteContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitDelete(s)

	default:
		return t.VisitChildren(s)
	}
}

type DescribeInputContext struct {
	*StatementContext
}

func NewDescribeInputContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeInputContext {
	var p = new(DescribeInputContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DescribeInputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeInputContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDESCRIBE, 0)
}

func (s *DescribeInputContext) INPUT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINPUT, 0)
}

func (s *DescribeInputContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DescribeInputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDescribeInput(s)
	}
}

func (s *DescribeInputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDescribeInput(s)
	}
}

func (s *DescribeInputContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitDescribeInput(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowStatsForQueryContext struct {
	*StatementContext
}

func NewShowStatsForQueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowStatsForQueryContext {
	var p = new(ShowStatsForQueryContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowStatsForQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStatsForQueryContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowStatsForQueryContext) STATS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTATS, 0)
}

func (s *ShowStatsForQueryContext) FOR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOR, 0)
}

func (s *ShowStatsForQueryContext) QuerySpecification() IQuerySpecificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuerySpecificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *ShowStatsForQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowStatsForQuery(s)
	}
}

func (s *ShowStatsForQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowStatsForQuery(s)
	}
}

func (s *ShowStatsForQueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitShowStatsForQuery(s)

	default:
		return t.VisitChildren(s)
	}
}

type StatementDefaultContext struct {
	*StatementContext
}

func NewStatementDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StatementDefaultContext {
	var p = new(StatementDefaultContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *StatementDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementDefaultContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *StatementDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterStatementDefault(s)
	}
}

func (s *StatementDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitStatementDefault(s)
	}
}

func (s *StatementDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitStatementDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateMaterializedViewContext struct {
	*StatementContext
}

func NewCreateMaterializedViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateMaterializedViewContext {
	var p = new(CreateMaterializedViewContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *CreateMaterializedViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateMaterializedViewContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *CreateMaterializedViewContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMATERIALIZED, 0)
}

func (s *CreateMaterializedViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVIEW, 0)
}

func (s *CreateMaterializedViewContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateMaterializedViewContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *CreateMaterializedViewContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *CreateMaterializedViewContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *CreateMaterializedViewContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *CreateMaterializedViewContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *CreateMaterializedViewContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMENT, 0)
}

func (s *CreateMaterializedViewContext) String_() IString_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *CreateMaterializedViewContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *CreateMaterializedViewContext) Properties() IPropertiesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertiesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateMaterializedViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCreateMaterializedView(s)
	}
}

func (s *CreateMaterializedViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCreateMaterializedView(s)
	}
}

func (s *CreateMaterializedViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitCreateMaterializedView(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterFunctionContext struct {
	*StatementContext
}

func NewAlterFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterFunctionContext {
	var p = new(AlterFunctionContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *AlterFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterFunctionContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *AlterFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFUNCTION, 0)
}

func (s *AlterFunctionContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AlterFunctionContext) AlterRoutineCharacteristics() IAlterRoutineCharacteristicsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterRoutineCharacteristicsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlterRoutineCharacteristicsContext)
}

func (s *AlterFunctionContext) Types() ITypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypesContext)
}

func (s *AlterFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterAlterFunction(s)
	}
}

func (s *AlterFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitAlterFunction(s)
	}
}

func (s *AlterFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitAlterFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetSessionContext struct {
	*StatementContext
}

func NewSetSessionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetSessionContext {
	var p = new(SetSessionContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *SetSessionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetSessionContext) SET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSET, 0)
}

func (s *SetSessionContext) SESSION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSESSION, 0)
}

func (s *SetSessionContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *SetSessionContext) EQ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEQ, 0)
}

func (s *SetSessionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetSessionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSetSession(s)
	}
}

func (s *SetSessionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSetSession(s)
	}
}

func (s *SetSessionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSetSession(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateViewContext struct {
	*StatementContext
}

func NewCreateViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateViewContext {
	var p = new(CreateViewContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *CreateViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateViewContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *CreateViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVIEW, 0)
}

func (s *CreateViewContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateViewContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *CreateViewContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *CreateViewContext) OR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOR, 0)
}

func (s *CreateViewContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREPLACE, 0)
}

func (s *CreateViewContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSECURITY, 0)
}

func (s *CreateViewContext) DEFINER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDEFINER, 0)
}

func (s *CreateViewContext) INVOKER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINVOKER, 0)
}

func (s *CreateViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCreateView(s)
	}
}

func (s *CreateViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCreateView(s)
	}
}

func (s *CreateViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitCreateView(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowSchemasContext struct {
	*StatementContext
	pattern IString_Context
	escape  IString_Context
}

func NewShowSchemasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowSchemasContext {
	var p = new(ShowSchemasContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowSchemasContext) GetPattern() IString_Context { return s.pattern }

func (s *ShowSchemasContext) GetEscape() IString_Context { return s.escape }

func (s *ShowSchemasContext) SetPattern(v IString_Context) { s.pattern = v }

func (s *ShowSchemasContext) SetEscape(v IString_Context) { s.escape = v }

func (s *ShowSchemasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSchemasContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowSchemasContext) SCHEMAS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSCHEMAS, 0)
}

func (s *ShowSchemasContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowSchemasContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIKE, 0)
}

func (s *ShowSchemasContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *ShowSchemasContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, 0)
}

func (s *ShowSchemasContext) AllString_() []IString_Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IString_Context)(nil)).Elem())
	var tst = make([]IString_Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IString_Context)
		}
	}

	return tst
}

func (s *ShowSchemasContext) String_(i int) IString_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *ShowSchemasContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserESCAPE, 0)
}

func (s *ShowSchemasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowSchemas(s)
	}
}

func (s *ShowSchemasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowSchemas(s)
	}
}

func (s *ShowSchemasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitShowSchemas(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropTableContext struct {
	*StatementContext
}

func NewDropTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropTableContext {
	var p = new(DropTableContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DropTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTableContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDROP, 0)
}

func (s *DropTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *DropTableContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropTableContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *DropTableContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *DropTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDropTable(s)
	}
}

func (s *DropTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDropTable(s)
	}
}

func (s *DropTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitDropTable(s)

	default:
		return t.VisitChildren(s)
	}
}

type RollbackContext struct {
	*StatementContext
}

func NewRollbackContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RollbackContext {
	var p = new(RollbackContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *RollbackContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollbackContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLLBACK, 0)
}

func (s *RollbackContext) WORK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWORK, 0)
}

func (s *RollbackContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRollback(s)
	}
}

func (s *RollbackContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRollback(s)
	}
}

func (s *RollbackContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitRollback(s)

	default:
		return t.VisitChildren(s)
	}
}

type GrantRolesContext struct {
	*StatementContext
}

func NewGrantRolesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantRolesContext {
	var p = new(GrantRolesContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *GrantRolesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantRolesContext) GRANT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGRANT, 0)
}

func (s *GrantRolesContext) Roles() IRolesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRolesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRolesContext)
}

func (s *GrantRolesContext) TO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTO, 0)
}

func (s *GrantRolesContext) AllPrincipal() []IPrincipalContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPrincipalContext)(nil)).Elem())
	var tst = make([]IPrincipalContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPrincipalContext)
		}
	}

	return tst
}

func (s *GrantRolesContext) Principal(i int) IPrincipalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrincipalContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPrincipalContext)
}

func (s *GrantRolesContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *GrantRolesContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserADMIN, 0)
}

func (s *GrantRolesContext) OPTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOPTION, 0)
}

func (s *GrantRolesContext) GRANTED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGRANTED, 0)
}

func (s *GrantRolesContext) BY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBY, 0)
}

func (s *GrantRolesContext) Grantor() IGrantorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGrantorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGrantorContext)
}

func (s *GrantRolesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterGrantRoles(s)
	}
}

func (s *GrantRolesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitGrantRoles(s)
	}
}

func (s *GrantRolesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitGrantRoles(s)

	default:
		return t.VisitChildren(s)
	}
}

type CallContext struct {
	*StatementContext
}

func NewCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CallContext {
	var p = new(CallContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *CallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallContext) CALL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCALL, 0)
}

func (s *CallContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CallContext) AllCallArgument() []ICallArgumentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICallArgumentContext)(nil)).Elem())
	var tst = make([]ICallArgumentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICallArgumentContext)
		}
	}

	return tst
}

func (s *CallContext) CallArgument(i int) ICallArgumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallArgumentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICallArgumentContext)
}

func (s *CallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCall(s)
	}
}

func (s *CallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCall(s)
	}
}

func (s *CallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type RefreshMaterializedViewContext struct {
	*StatementContext
}

func NewRefreshMaterializedViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RefreshMaterializedViewContext {
	var p = new(RefreshMaterializedViewContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *RefreshMaterializedViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshMaterializedViewContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREFRESH, 0)
}

func (s *RefreshMaterializedViewContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMATERIALIZED, 0)
}

func (s *RefreshMaterializedViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVIEW, 0)
}

func (s *RefreshMaterializedViewContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RefreshMaterializedViewContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWHERE, 0)
}

func (s *RefreshMaterializedViewContext) BooleanExpression() IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *RefreshMaterializedViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRefreshMaterializedView(s)
	}
}

func (s *RefreshMaterializedViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRefreshMaterializedView(s)
	}
}

func (s *RefreshMaterializedViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitRefreshMaterializedView(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowCreateMaterializedViewContext struct {
	*StatementContext
}

func NewShowCreateMaterializedViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateMaterializedViewContext {
	var p = new(ShowCreateMaterializedViewContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowCreateMaterializedViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateMaterializedViewContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowCreateMaterializedViewContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *ShowCreateMaterializedViewContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMATERIALIZED, 0)
}

func (s *ShowCreateMaterializedViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVIEW, 0)
}

func (s *ShowCreateMaterializedViewContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowCreateMaterializedViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowCreateMaterializedView(s)
	}
}

func (s *ShowCreateMaterializedViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowCreateMaterializedView(s)
	}
}

func (s *ShowCreateMaterializedViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitShowCreateMaterializedView(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowFunctionsContext struct {
	*StatementContext
	pattern IString_Context
	escape  IString_Context
}

func NewShowFunctionsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowFunctionsContext {
	var p = new(ShowFunctionsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowFunctionsContext) GetPattern() IString_Context { return s.pattern }

func (s *ShowFunctionsContext) GetEscape() IString_Context { return s.escape }

func (s *ShowFunctionsContext) SetPattern(v IString_Context) { s.pattern = v }

func (s *ShowFunctionsContext) SetEscape(v IString_Context) { s.escape = v }

func (s *ShowFunctionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowFunctionsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowFunctionsContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFUNCTIONS, 0)
}

func (s *ShowFunctionsContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIKE, 0)
}

func (s *ShowFunctionsContext) AllString_() []IString_Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IString_Context)(nil)).Elem())
	var tst = make([]IString_Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IString_Context)
		}
	}

	return tst
}

func (s *ShowFunctionsContext) String_(i int) IString_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *ShowFunctionsContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserESCAPE, 0)
}

func (s *ShowFunctionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowFunctions(s)
	}
}

func (s *ShowFunctionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowFunctions(s)
	}
}

func (s *ShowFunctionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitShowFunctions(s)

	default:
		return t.VisitChildren(s)
	}
}

type DescribeOutputContext struct {
	*StatementContext
}

func NewDescribeOutputContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeOutputContext {
	var p = new(DescribeOutputContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DescribeOutputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeOutputContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDESCRIBE, 0)
}

func (s *DescribeOutputContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOUTPUT, 0)
}

func (s *DescribeOutputContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DescribeOutputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDescribeOutput(s)
	}
}

func (s *DescribeOutputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDescribeOutput(s)
	}
}

func (s *DescribeOutputContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitDescribeOutput(s)

	default:
		return t.VisitChildren(s)
	}
}

type GrantContext struct {
	*StatementContext
	grantee IPrincipalContext
}

func NewGrantContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantContext {
	var p = new(GrantContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *GrantContext) GetGrantee() IPrincipalContext { return s.grantee }

func (s *GrantContext) SetGrantee(v IPrincipalContext) { s.grantee = v }

func (s *GrantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserGRANT)
}

func (s *GrantContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGRANT, i)
}

func (s *GrantContext) ON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserON, 0)
}

func (s *GrantContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *GrantContext) TO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTO, 0)
}

func (s *GrantContext) Principal() IPrincipalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrincipalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrincipalContext)
}

func (s *GrantContext) AllPrivilege() []IPrivilegeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPrivilegeContext)(nil)).Elem())
	var tst = make([]IPrivilegeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPrivilegeContext)
		}
	}

	return tst
}

func (s *GrantContext) Privilege(i int) IPrivilegeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrivilegeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPrivilegeContext)
}

func (s *GrantContext) ALL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALL, 0)
}

func (s *GrantContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPRIVILEGES, 0)
}

func (s *GrantContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *GrantContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *GrantContext) OPTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOPTION, 0)
}

func (s *GrantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterGrant(s)
	}
}

func (s *GrantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitGrant(s)
	}
}

func (s *GrantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitGrant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, SqlBaseParserRULE_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(791)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext()) {
	case 1:
		localctx = NewStatementDefaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(163)
			p.Query()
		}

	case 2:
		localctx = NewUseContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(164)
			p.Match(SqlBaseParserUSE)
		}
		{
			p.SetState(165)

			var _x = p.Identifier()

			localctx.(*UseContext).schema = _x
		}

	case 3:
		localctx = NewUseContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(166)
			p.Match(SqlBaseParserUSE)
		}
		{
			p.SetState(167)

			var _x = p.Identifier()

			localctx.(*UseContext).catalog = _x
		}
		{
			p.SetState(168)
			p.Match(SqlBaseParserT__0)
		}
		{
			p.SetState(169)

			var _x = p.Identifier()

			localctx.(*UseContext).schema = _x
		}

	case 4:
		localctx = NewCreateSchemaContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(171)
			p.Match(SqlBaseParserCREATE)
		}
		{
			p.SetState(172)
			p.Match(SqlBaseParserSCHEMA)
		}
		p.SetState(176)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(173)
				p.Match(SqlBaseParserIF)
			}
			{
				p.SetState(174)
				p.Match(SqlBaseParserNOT)
			}
			{
				p.SetState(175)
				p.Match(SqlBaseParserEXISTS)
			}

		}
		{
			p.SetState(178)
			p.QualifiedName()
		}
		p.SetState(181)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWITH {
			{
				p.SetState(179)
				p.Match(SqlBaseParserWITH)
			}
			{
				p.SetState(180)
				p.Properties()
			}

		}

	case 5:
		localctx = NewDropSchemaContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(183)
			p.Match(SqlBaseParserDROP)
		}
		{
			p.SetState(184)
			p.Match(SqlBaseParserSCHEMA)
		}
		p.SetState(187)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(185)
				p.Match(SqlBaseParserIF)
			}
			{
				p.SetState(186)
				p.Match(SqlBaseParserEXISTS)
			}

		}
		{
			p.SetState(189)
			p.QualifiedName()
		}
		p.SetState(191)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserCASCADE || _la == SqlBaseParserRESTRICT {
			{
				p.SetState(190)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBaseParserCASCADE || _la == SqlBaseParserRESTRICT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	case 6:
		localctx = NewRenameSchemaContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(193)
			p.Match(SqlBaseParserALTER)
		}
		{
			p.SetState(194)
			p.Match(SqlBaseParserSCHEMA)
		}
		{
			p.SetState(195)
			p.QualifiedName()
		}
		{
			p.SetState(196)
			p.Match(SqlBaseParserRENAME)
		}
		{
			p.SetState(197)
			p.Match(SqlBaseParserTO)
		}
		{
			p.SetState(198)
			p.Identifier()
		}

	case 7:
		localctx = NewCreateTableAsSelectContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(200)
			p.Match(SqlBaseParserCREATE)
		}
		{
			p.SetState(201)
			p.Match(SqlBaseParserTABLE)
		}
		p.SetState(205)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(202)
				p.Match(SqlBaseParserIF)
			}
			{
				p.SetState(203)
				p.Match(SqlBaseParserNOT)
			}
			{
				p.SetState(204)
				p.Match(SqlBaseParserEXISTS)
			}

		}
		{
			p.SetState(207)
			p.QualifiedName()
		}
		p.SetState(209)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserT__1 {
			{
				p.SetState(208)
				p.ColumnAliases()
			}

		}
		p.SetState(213)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserCOMMENT {
			{
				p.SetState(211)
				p.Match(SqlBaseParserCOMMENT)
			}
			{
				p.SetState(212)
				p.String_()
			}

		}
		p.SetState(217)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWITH {
			{
				p.SetState(215)
				p.Match(SqlBaseParserWITH)
			}
			{
				p.SetState(216)
				p.Properties()
			}

		}
		{
			p.SetState(219)
			p.Match(SqlBaseParserAS)
		}
		p.SetState(225)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(220)
				p.Query()
			}

		case 2:
			{
				p.SetState(221)
				p.Match(SqlBaseParserT__1)
			}
			{
				p.SetState(222)
				p.Query()
			}
			{
				p.SetState(223)
				p.Match(SqlBaseParserT__2)
			}

		}
		p.SetState(232)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWITH {
			{
				p.SetState(227)
				p.Match(SqlBaseParserWITH)
			}
			p.SetState(229)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBaseParserNO {
				{
					p.SetState(228)
					p.Match(SqlBaseParserNO)
				}

			}
			{
				p.SetState(231)
				p.Match(SqlBaseParserDATA)
			}

		}

	case 8:
		localctx = NewCreateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(234)
			p.Match(SqlBaseParserCREATE)
		}
		{
			p.SetState(235)
			p.Match(SqlBaseParserTABLE)
		}
		p.SetState(239)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 11, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(236)
				p.Match(SqlBaseParserIF)
			}
			{
				p.SetState(237)
				p.Match(SqlBaseParserNOT)
			}
			{
				p.SetState(238)
				p.Match(SqlBaseParserEXISTS)
			}

		}
		{
			p.SetState(241)
			p.QualifiedName()
		}
		{
			p.SetState(242)
			p.Match(SqlBaseParserT__1)
		}
		{
			p.SetState(243)
			p.TableElement()
		}
		p.SetState(248)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__3 {
			{
				p.SetState(244)
				p.Match(SqlBaseParserT__3)
			}
			{
				p.SetState(245)
				p.TableElement()
			}

			p.SetState(250)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(251)
			p.Match(SqlBaseParserT__2)
		}
		p.SetState(254)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserCOMMENT {
			{
				p.SetState(252)
				p.Match(SqlBaseParserCOMMENT)
			}
			{
				p.SetState(253)
				p.String_()
			}

		}
		p.SetState(258)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWITH {
			{
				p.SetState(256)
				p.Match(SqlBaseParserWITH)
			}
			{
				p.SetState(257)
				p.Properties()
			}

		}

	case 9:
		localctx = NewDropTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(260)
			p.Match(SqlBaseParserDROP)
		}
		{
			p.SetState(261)
			p.Match(SqlBaseParserTABLE)
		}
		p.SetState(264)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(262)
				p.Match(SqlBaseParserIF)
			}
			{
				p.SetState(263)
				p.Match(SqlBaseParserEXISTS)
			}

		}
		{
			p.SetState(266)
			p.QualifiedName()
		}

	case 10:
		localctx = NewInsertIntoContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(267)
			p.Match(SqlBaseParserINSERT)
		}
		{
			p.SetState(268)
			p.Match(SqlBaseParserINTO)
		}
		{
			p.SetState(269)
			p.QualifiedName()
		}
		p.SetState(271)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(270)
				p.ColumnAliases()
			}

		}
		{
			p.SetState(273)
			p.Query()
		}

	case 11:
		localctx = NewDeleteContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(275)
			p.Match(SqlBaseParserDELETE)
		}
		{
			p.SetState(276)
			p.Match(SqlBaseParserFROM)
		}
		{
			p.SetState(277)
			p.QualifiedName()
		}
		p.SetState(280)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWHERE {
			{
				p.SetState(278)
				p.Match(SqlBaseParserWHERE)
			}
			{
				p.SetState(279)
				p.booleanExpression(0)
			}

		}

	case 12:
		localctx = NewRenameTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(282)
			p.Match(SqlBaseParserALTER)
		}
		{
			p.SetState(283)
			p.Match(SqlBaseParserTABLE)
		}
		p.SetState(286)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(284)
				p.Match(SqlBaseParserIF)
			}
			{
				p.SetState(285)
				p.Match(SqlBaseParserEXISTS)
			}

		}
		{
			p.SetState(288)

			var _x = p.QualifiedName()

			localctx.(*RenameTableContext).from = _x
		}
		{
			p.SetState(289)
			p.Match(SqlBaseParserRENAME)
		}
		{
			p.SetState(290)
			p.Match(SqlBaseParserTO)
		}
		{
			p.SetState(291)

			var _x = p.QualifiedName()

			localctx.(*RenameTableContext).to = _x
		}

	case 13:
		localctx = NewRenameColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(293)
			p.Match(SqlBaseParserALTER)
		}
		{
			p.SetState(294)
			p.Match(SqlBaseParserTABLE)
		}
		p.SetState(297)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(295)
				p.Match(SqlBaseParserIF)
			}
			{
				p.SetState(296)
				p.Match(SqlBaseParserEXISTS)
			}

		}
		{
			p.SetState(299)

			var _x = p.QualifiedName()

			localctx.(*RenameColumnContext).tableName = _x
		}
		{
			p.SetState(300)
			p.Match(SqlBaseParserRENAME)
		}
		{
			p.SetState(301)
			p.Match(SqlBaseParserCOLUMN)
		}
		p.SetState(304)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(302)
				p.Match(SqlBaseParserIF)
			}
			{
				p.SetState(303)
				p.Match(SqlBaseParserEXISTS)
			}

		}
		{
			p.SetState(306)

			var _x = p.Identifier()

			localctx.(*RenameColumnContext).from = _x
		}
		{
			p.SetState(307)
			p.Match(SqlBaseParserTO)
		}
		{
			p.SetState(308)

			var _x = p.Identifier()

			localctx.(*RenameColumnContext).to = _x
		}

	case 14:
		localctx = NewDropColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(310)
			p.Match(SqlBaseParserALTER)
		}
		{
			p.SetState(311)
			p.Match(SqlBaseParserTABLE)
		}
		p.SetState(314)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(312)
				p.Match(SqlBaseParserIF)
			}
			{
				p.SetState(313)
				p.Match(SqlBaseParserEXISTS)
			}

		}
		{
			p.SetState(316)

			var _x = p.QualifiedName()

			localctx.(*DropColumnContext).tableName = _x
		}
		{
			p.SetState(317)
			p.Match(SqlBaseParserDROP)
		}
		{
			p.SetState(318)
			p.Match(SqlBaseParserCOLUMN)
		}
		p.SetState(321)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(319)
				p.Match(SqlBaseParserIF)
			}
			{
				p.SetState(320)
				p.Match(SqlBaseParserEXISTS)
			}

		}
		{
			p.SetState(323)

			var _x = p.QualifiedName()

			localctx.(*DropColumnContext).column = _x
		}

	case 15:
		localctx = NewAddColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(325)
			p.Match(SqlBaseParserALTER)
		}
		{
			p.SetState(326)
			p.Match(SqlBaseParserTABLE)
		}
		p.SetState(329)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(327)
				p.Match(SqlBaseParserIF)
			}
			{
				p.SetState(328)
				p.Match(SqlBaseParserEXISTS)
			}

		}
		{
			p.SetState(331)

			var _x = p.QualifiedName()

			localctx.(*AddColumnContext).tableName = _x
		}
		{
			p.SetState(332)
			p.Match(SqlBaseParserADD)
		}
		{
			p.SetState(333)
			p.Match(SqlBaseParserCOLUMN)
		}
		p.SetState(337)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(334)
				p.Match(SqlBaseParserIF)
			}
			{
				p.SetState(335)
				p.Match(SqlBaseParserNOT)
			}
			{
				p.SetState(336)
				p.Match(SqlBaseParserEXISTS)
			}

		}
		{
			p.SetState(339)

			var _x = p.ColumnDefinition()

			localctx.(*AddColumnContext).column = _x
		}

	case 16:
		localctx = NewAnalyzeContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(341)
			p.Match(SqlBaseParserANALYZE)
		}
		{
			p.SetState(342)
			p.QualifiedName()
		}
		p.SetState(345)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWITH {
			{
				p.SetState(343)
				p.Match(SqlBaseParserWITH)
			}
			{
				p.SetState(344)
				p.Properties()
			}

		}

	case 17:
		localctx = NewCreateTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(347)
			p.Match(SqlBaseParserCREATE)
		}
		{
			p.SetState(348)
			p.Match(SqlBaseParserTYPE)
		}
		{
			p.SetState(349)
			p.QualifiedName()
		}
		{
			p.SetState(350)
			p.Match(SqlBaseParserAS)
		}
		p.SetState(363)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SqlBaseParserT__1:
			{
				p.SetState(351)
				p.Match(SqlBaseParserT__1)
			}
			{
				p.SetState(352)
				p.SqlParameterDeclaration()
			}
			p.SetState(357)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__3 {
				{
					p.SetState(353)
					p.Match(SqlBaseParserT__3)
				}
				{
					p.SetState(354)
					p.SqlParameterDeclaration()
				}

				p.SetState(359)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(360)
				p.Match(SqlBaseParserT__2)
			}

		case SqlBaseParserADD, SqlBaseParserADMIN, SqlBaseParserALL, SqlBaseParserANALYZE, SqlBaseParserANY, SqlBaseParserARRAY, SqlBaseParserASC, SqlBaseParserAT, SqlBaseParserBERNOULLI, SqlBaseParserCALL, SqlBaseParserCALLED, SqlBaseParserCASCADE, SqlBaseParserCATALOGS, SqlBaseParserCOLUMN, SqlBaseParserCOLUMNS, SqlBaseParserCOMMENT, SqlBaseParserCOMMIT, SqlBaseParserCOMMITTED, SqlBaseParserCURRENT, SqlBaseParserCURRENT_ROLE, SqlBaseParserDATA, SqlBaseParserDATE, SqlBaseParserDAY, SqlBaseParserDEFINER, SqlBaseParserDESC, SqlBaseParserDETERMINISTIC, SqlBaseParserDISTRIBUTED, SqlBaseParserEXCLUDING, SqlBaseParserEXPLAIN, SqlBaseParserEXTERNAL, SqlBaseParserFILTER, SqlBaseParserFIRST, SqlBaseParserFOLLOWING, SqlBaseParserFORMAT, SqlBaseParserFUNCTION, SqlBaseParserFUNCTIONS, SqlBaseParserGRANT, SqlBaseParserGRANTED, SqlBaseParserGRANTS, SqlBaseParserGRAPHVIZ, SqlBaseParserHOUR, SqlBaseParserIF, SqlBaseParserIGNORE, SqlBaseParserINCLUDING, SqlBaseParserINPUT, SqlBaseParserINTERVAL, SqlBaseParserINVOKER, SqlBaseParserIO, SqlBaseParserISOLATION, SqlBaseParserJSON, SqlBaseParserLANGUAGE, SqlBaseParserLAST, SqlBaseParserLATERAL, SqlBaseParserLEVEL, SqlBaseParserLIMIT, SqlBaseParserLOGICAL, SqlBaseParserMAP, SqlBaseParserMATERIALIZED, SqlBaseParserMINUTE, SqlBaseParserMONTH, SqlBaseParserNAME, SqlBaseParserNFC, SqlBaseParserNFD, SqlBaseParserNFKC, SqlBaseParserNFKD, SqlBaseParserNO, SqlBaseParserNONE, SqlBaseParserNULLIF, SqlBaseParserNULLS, SqlBaseParserOFFSET, SqlBaseParserONLY, SqlBaseParserOPTION, SqlBaseParserORDINALITY, SqlBaseParserOUTPUT, SqlBaseParserOVER, SqlBaseParserPARTITION, SqlBaseParserPARTITIONS, SqlBaseParserPOSITION, SqlBaseParserPRECEDING, SqlBaseParserPRIVILEGES, SqlBaseParserPROPERTIES, SqlBaseParserRANGE, SqlBaseParserREAD, SqlBaseParserREFRESH, SqlBaseParserRENAME, SqlBaseParserREPEATABLE, SqlBaseParserREPLACE, SqlBaseParserRESET, SqlBaseParserRESPECT, SqlBaseParserRESTRICT, SqlBaseParserRETURN, SqlBaseParserRETURNS, SqlBaseParserREVOKE, SqlBaseParserROLE, SqlBaseParserROLES, SqlBaseParserROLLBACK, SqlBaseParserROW, SqlBaseParserROWS, SqlBaseParserSCHEMA, SqlBaseParserSCHEMAS, SqlBaseParserSECOND, SqlBaseParserSECURITY, SqlBaseParserSERIALIZABLE, SqlBaseParserSESSION, SqlBaseParserSET, SqlBaseParserSETS, SqlBaseParserSHOW, SqlBaseParserSOME, SqlBaseParserSQL, SqlBaseParserSTART, SqlBaseParserSTATS, SqlBaseParserSUBSTRING, SqlBaseParserSYSTEM, SqlBaseParserTABLES, SqlBaseParserTABLESAMPLE, SqlBaseParserTEMPORARY, SqlBaseParserTEXT, SqlBaseParserTIME, SqlBaseParserTIMESTAMP, SqlBaseParserTO, SqlBaseParserTRANSACTION, SqlBaseParserTRY_CAST, SqlBaseParserTYPE, SqlBaseParserUNBOUNDED, SqlBaseParserUNCOMMITTED, SqlBaseParserUSE, SqlBaseParserUSER, SqlBaseParserVALIDATE, SqlBaseParserVERBOSE, SqlBaseParserVIEW, SqlBaseParserWORK, SqlBaseParserWRITE, SqlBaseParserYEAR, SqlBaseParserZONE, SqlBaseParserIDENTIFIER, SqlBaseParserDIGIT_IDENTIFIER, SqlBaseParserQUOTED_IDENTIFIER, SqlBaseParserBACKQUOTED_IDENTIFIER, SqlBaseParserTIME_WITH_TIME_ZONE, SqlBaseParserTIMESTAMP_WITH_TIME_ZONE, SqlBaseParserDOUBLE_PRECISION:
			{
				p.SetState(362)
				p.type_(0)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 18:
		localctx = NewCreateViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(365)
			p.Match(SqlBaseParserCREATE)
		}
		p.SetState(368)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserOR {
			{
				p.SetState(366)
				p.Match(SqlBaseParserOR)
			}
			{
				p.SetState(367)
				p.Match(SqlBaseParserREPLACE)
			}

		}
		{
			p.SetState(370)
			p.Match(SqlBaseParserVIEW)
		}
		{
			p.SetState(371)
			p.QualifiedName()
		}
		p.SetState(374)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserSECURITY {
			{
				p.SetState(372)
				p.Match(SqlBaseParserSECURITY)
			}
			{
				p.SetState(373)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBaseParserDEFINER || _la == SqlBaseParserINVOKER) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(376)
			p.Match(SqlBaseParserAS)
		}
		{
			p.SetState(377)
			p.Query()
		}

	case 19:
		localctx = NewDropViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(379)
			p.Match(SqlBaseParserDROP)
		}
		{
			p.SetState(380)
			p.Match(SqlBaseParserVIEW)
		}
		p.SetState(383)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(381)
				p.Match(SqlBaseParserIF)
			}
			{
				p.SetState(382)
				p.Match(SqlBaseParserEXISTS)
			}

		}
		{
			p.SetState(385)
			p.QualifiedName()
		}

	case 20:
		localctx = NewCreateMaterializedViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(386)
			p.Match(SqlBaseParserCREATE)
		}
		{
			p.SetState(387)
			p.Match(SqlBaseParserMATERIALIZED)
		}
		{
			p.SetState(388)
			p.Match(SqlBaseParserVIEW)
		}
		p.SetState(392)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(389)
				p.Match(SqlBaseParserIF)
			}
			{
				p.SetState(390)
				p.Match(SqlBaseParserNOT)
			}
			{
				p.SetState(391)
				p.Match(SqlBaseParserEXISTS)
			}

		}
		{
			p.SetState(394)
			p.QualifiedName()
		}
		p.SetState(397)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserCOMMENT {
			{
				p.SetState(395)
				p.Match(SqlBaseParserCOMMENT)
			}
			{
				p.SetState(396)
				p.String_()
			}

		}
		p.SetState(401)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWITH {
			{
				p.SetState(399)
				p.Match(SqlBaseParserWITH)
			}
			{
				p.SetState(400)
				p.Properties()
			}

		}
		{
			p.SetState(403)
			p.Match(SqlBaseParserAS)
		}
		p.SetState(409)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(404)
				p.Query()
			}

		case 2:
			{
				p.SetState(405)
				p.Match(SqlBaseParserT__1)
			}
			{
				p.SetState(406)
				p.Query()
			}
			{
				p.SetState(407)
				p.Match(SqlBaseParserT__2)
			}

		}

	case 21:
		localctx = NewDropMaterializedViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(411)
			p.Match(SqlBaseParserDROP)
		}
		{
			p.SetState(412)
			p.Match(SqlBaseParserMATERIALIZED)
		}
		{
			p.SetState(413)
			p.Match(SqlBaseParserVIEW)
		}
		p.SetState(416)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(414)
				p.Match(SqlBaseParserIF)
			}
			{
				p.SetState(415)
				p.Match(SqlBaseParserEXISTS)
			}

		}
		{
			p.SetState(418)
			p.QualifiedName()
		}

	case 22:
		localctx = NewRefreshMaterializedViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(419)
			p.Match(SqlBaseParserREFRESH)
		}
		{
			p.SetState(420)
			p.Match(SqlBaseParserMATERIALIZED)
		}
		{
			p.SetState(421)
			p.Match(SqlBaseParserVIEW)
		}
		{
			p.SetState(422)
			p.QualifiedName()
		}
		{
			p.SetState(423)
			p.Match(SqlBaseParserWHERE)
		}
		{
			p.SetState(424)
			p.booleanExpression(0)
		}

	case 23:
		localctx = NewCreateFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(426)
			p.Match(SqlBaseParserCREATE)
		}
		p.SetState(429)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserOR {
			{
				p.SetState(427)
				p.Match(SqlBaseParserOR)
			}
			{
				p.SetState(428)
				p.Match(SqlBaseParserREPLACE)
			}

		}
		p.SetState(432)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserTEMPORARY {
			{
				p.SetState(431)
				p.Match(SqlBaseParserTEMPORARY)
			}

		}
		{
			p.SetState(434)
			p.Match(SqlBaseParserFUNCTION)
		}
		{
			p.SetState(435)

			var _x = p.QualifiedName()

			localctx.(*CreateFunctionContext).functionName = _x
		}
		{
			p.SetState(436)
			p.Match(SqlBaseParserT__1)
		}
		p.SetState(445)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-10)&-(0x1f+1)) == 0 && ((1<<uint((_la-10)))&((1<<(SqlBaseParserADD-10))|(1<<(SqlBaseParserADMIN-10))|(1<<(SqlBaseParserALL-10))|(1<<(SqlBaseParserANALYZE-10))|(1<<(SqlBaseParserANY-10))|(1<<(SqlBaseParserARRAY-10))|(1<<(SqlBaseParserASC-10))|(1<<(SqlBaseParserAT-10))|(1<<(SqlBaseParserBERNOULLI-10))|(1<<(SqlBaseParserCALL-10))|(1<<(SqlBaseParserCALLED-10))|(1<<(SqlBaseParserCASCADE-10))|(1<<(SqlBaseParserCATALOGS-10))|(1<<(SqlBaseParserCOLUMN-10))|(1<<(SqlBaseParserCOLUMNS-10))|(1<<(SqlBaseParserCOMMENT-10))|(1<<(SqlBaseParserCOMMIT-10))|(1<<(SqlBaseParserCOMMITTED-10))|(1<<(SqlBaseParserCURRENT-10))|(1<<(SqlBaseParserCURRENT_ROLE-10)))) != 0) || (((_la-45)&-(0x1f+1)) == 0 && ((1<<uint((_la-45)))&((1<<(SqlBaseParserDATA-45))|(1<<(SqlBaseParserDATE-45))|(1<<(SqlBaseParserDAY-45))|(1<<(SqlBaseParserDEFINER-45))|(1<<(SqlBaseParserDESC-45))|(1<<(SqlBaseParserDETERMINISTIC-45))|(1<<(SqlBaseParserDISTRIBUTED-45))|(1<<(SqlBaseParserEXCLUDING-45))|(1<<(SqlBaseParserEXPLAIN-45))|(1<<(SqlBaseParserEXTERNAL-45))|(1<<(SqlBaseParserFILTER-45))|(1<<(SqlBaseParserFIRST-45))|(1<<(SqlBaseParserFOLLOWING-45))|(1<<(SqlBaseParserFORMAT-45))|(1<<(SqlBaseParserFUNCTION-45))|(1<<(SqlBaseParserFUNCTIONS-45)))) != 0) || (((_la-77)&-(0x1f+1)) == 0 && ((1<<uint((_la-77)))&((1<<(SqlBaseParserGRANT-77))|(1<<(SqlBaseParserGRANTED-77))|(1<<(SqlBaseParserGRANTS-77))|(1<<(SqlBaseParserGRAPHVIZ-77))|(1<<(SqlBaseParserHOUR-77))|(1<<(SqlBaseParserIF-77))|(1<<(SqlBaseParserIGNORE-77))|(1<<(SqlBaseParserINCLUDING-77))|(1<<(SqlBaseParserINPUT-77))|(1<<(SqlBaseParserINTERVAL-77))|(1<<(SqlBaseParserINVOKER-77))|(1<<(SqlBaseParserIO-77))|(1<<(SqlBaseParserISOLATION-77))|(1<<(SqlBaseParserJSON-77))|(1<<(SqlBaseParserLANGUAGE-77))|(1<<(SqlBaseParserLAST-77))|(1<<(SqlBaseParserLATERAL-77))|(1<<(SqlBaseParserLEVEL-77))|(1<<(SqlBaseParserLIMIT-77)))) != 0) || (((_la-110)&-(0x1f+1)) == 0 && ((1<<uint((_la-110)))&((1<<(SqlBaseParserLOGICAL-110))|(1<<(SqlBaseParserMAP-110))|(1<<(SqlBaseParserMATERIALIZED-110))|(1<<(SqlBaseParserMINUTE-110))|(1<<(SqlBaseParserMONTH-110))|(1<<(SqlBaseParserNAME-110))|(1<<(SqlBaseParserNFC-110))|(1<<(SqlBaseParserNFD-110))|(1<<(SqlBaseParserNFKC-110))|(1<<(SqlBaseParserNFKD-110))|(1<<(SqlBaseParserNO-110))|(1<<(SqlBaseParserNONE-110))|(1<<(SqlBaseParserNULLIF-110))|(1<<(SqlBaseParserNULLS-110))|(1<<(SqlBaseParserOFFSET-110))|(1<<(SqlBaseParserONLY-110))|(1<<(SqlBaseParserOPTION-110))|(1<<(SqlBaseParserORDINALITY-110))|(1<<(SqlBaseParserOUTPUT-110))|(1<<(SqlBaseParserOVER-110))|(1<<(SqlBaseParserPARTITION-110))|(1<<(SqlBaseParserPARTITIONS-110))|(1<<(SqlBaseParserPOSITION-110))|(1<<(SqlBaseParserPRECEDING-110)))) != 0) || (((_la-143)&-(0x1f+1)) == 0 && ((1<<uint((_la-143)))&((1<<(SqlBaseParserPRIVILEGES-143))|(1<<(SqlBaseParserPROPERTIES-143))|(1<<(SqlBaseParserRANGE-143))|(1<<(SqlBaseParserREAD-143))|(1<<(SqlBaseParserREFRESH-143))|(1<<(SqlBaseParserRENAME-143))|(1<<(SqlBaseParserREPEATABLE-143))|(1<<(SqlBaseParserREPLACE-143))|(1<<(SqlBaseParserRESET-143))|(1<<(SqlBaseParserRESPECT-143))|(1<<(SqlBaseParserRESTRICT-143))|(1<<(SqlBaseParserRETURN-143))|(1<<(SqlBaseParserRETURNS-143))|(1<<(SqlBaseParserREVOKE-143))|(1<<(SqlBaseParserROLE-143))|(1<<(SqlBaseParserROLES-143))|(1<<(SqlBaseParserROLLBACK-143))|(1<<(SqlBaseParserROW-143))|(1<<(SqlBaseParserROWS-143))|(1<<(SqlBaseParserSCHEMA-143))|(1<<(SqlBaseParserSCHEMAS-143))|(1<<(SqlBaseParserSECOND-143))|(1<<(SqlBaseParserSECURITY-143))|(1<<(SqlBaseParserSERIALIZABLE-143))|(1<<(SqlBaseParserSESSION-143))|(1<<(SqlBaseParserSET-143))|(1<<(SqlBaseParserSETS-143))|(1<<(SqlBaseParserSHOW-143)))) != 0) || (((_la-175)&-(0x1f+1)) == 0 && ((1<<uint((_la-175)))&((1<<(SqlBaseParserSOME-175))|(1<<(SqlBaseParserSQL-175))|(1<<(SqlBaseParserSTART-175))|(1<<(SqlBaseParserSTATS-175))|(1<<(SqlBaseParserSUBSTRING-175))|(1<<(SqlBaseParserSYSTEM-175))|(1<<(SqlBaseParserTABLES-175))|(1<<(SqlBaseParserTABLESAMPLE-175))|(1<<(SqlBaseParserTEMPORARY-175))|(1<<(SqlBaseParserTEXT-175))|(1<<(SqlBaseParserTIME-175))|(1<<(SqlBaseParserTIMESTAMP-175))|(1<<(SqlBaseParserTO-175))|(1<<(SqlBaseParserTRANSACTION-175))|(1<<(SqlBaseParserTRY_CAST-175))|(1<<(SqlBaseParserTYPE-175))|(1<<(SqlBaseParserUNBOUNDED-175))|(1<<(SqlBaseParserUNCOMMITTED-175))|(1<<(SqlBaseParserUSE-175))|(1<<(SqlBaseParserUSER-175))|(1<<(SqlBaseParserVALIDATE-175))|(1<<(SqlBaseParserVERBOSE-175))|(1<<(SqlBaseParserVIEW-175)))) != 0) || (((_la-209)&-(0x1f+1)) == 0 && ((1<<uint((_la-209)))&((1<<(SqlBaseParserWORK-209))|(1<<(SqlBaseParserWRITE-209))|(1<<(SqlBaseParserYEAR-209))|(1<<(SqlBaseParserZONE-209))|(1<<(SqlBaseParserIDENTIFIER-209))|(1<<(SqlBaseParserDIGIT_IDENTIFIER-209))|(1<<(SqlBaseParserQUOTED_IDENTIFIER-209))|(1<<(SqlBaseParserBACKQUOTED_IDENTIFIER-209)))) != 0) {
			{
				p.SetState(437)
				p.SqlParameterDeclaration()
			}
			p.SetState(442)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__3 {
				{
					p.SetState(438)
					p.Match(SqlBaseParserT__3)
				}
				{
					p.SetState(439)
					p.SqlParameterDeclaration()
				}

				p.SetState(444)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(447)
			p.Match(SqlBaseParserT__2)
		}
		{
			p.SetState(448)
			p.Match(SqlBaseParserRETURNS)
		}
		{
			p.SetState(449)

			var _x = p.type_(0)

			localctx.(*CreateFunctionContext).returnType = _x
		}
		p.SetState(452)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserCOMMENT {
			{
				p.SetState(450)
				p.Match(SqlBaseParserCOMMENT)
			}
			{
				p.SetState(451)
				p.String_()
			}

		}
		{
			p.SetState(454)
			p.RoutineCharacteristics()
		}
		{
			p.SetState(455)
			p.RoutineBody()
		}

	case 24:
		localctx = NewAlterFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(457)
			p.Match(SqlBaseParserALTER)
		}
		{
			p.SetState(458)
			p.Match(SqlBaseParserFUNCTION)
		}
		{
			p.SetState(459)
			p.QualifiedName()
		}
		p.SetState(461)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserT__1 {
			{
				p.SetState(460)
				p.Types()
			}

		}
		{
			p.SetState(463)
			p.AlterRoutineCharacteristics()
		}

	case 25:
		localctx = NewDropFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(465)
			p.Match(SqlBaseParserDROP)
		}
		p.SetState(467)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserTEMPORARY {
			{
				p.SetState(466)
				p.Match(SqlBaseParserTEMPORARY)
			}

		}
		{
			p.SetState(469)
			p.Match(SqlBaseParserFUNCTION)
		}
		p.SetState(472)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(470)
				p.Match(SqlBaseParserIF)
			}
			{
				p.SetState(471)
				p.Match(SqlBaseParserEXISTS)
			}

		}
		{
			p.SetState(474)
			p.QualifiedName()
		}
		p.SetState(476)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserT__1 {
			{
				p.SetState(475)
				p.Types()
			}

		}

	case 26:
		localctx = NewCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(478)
			p.Match(SqlBaseParserCALL)
		}
		{
			p.SetState(479)
			p.QualifiedName()
		}
		{
			p.SetState(480)
			p.Match(SqlBaseParserT__1)
		}
		p.SetState(489)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SqlBaseParserT__1)|(1<<SqlBaseParserT__4)|(1<<SqlBaseParserADD)|(1<<SqlBaseParserADMIN)|(1<<SqlBaseParserALL)|(1<<SqlBaseParserANALYZE)|(1<<SqlBaseParserANY)|(1<<SqlBaseParserARRAY)|(1<<SqlBaseParserASC)|(1<<SqlBaseParserAT)|(1<<SqlBaseParserBERNOULLI)|(1<<SqlBaseParserCALL)|(1<<SqlBaseParserCALLED)|(1<<SqlBaseParserCASCADE)|(1<<SqlBaseParserCASE)|(1<<SqlBaseParserCAST)|(1<<SqlBaseParserCATALOGS)|(1<<SqlBaseParserCOLUMN)|(1<<SqlBaseParserCOLUMNS))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(SqlBaseParserCOMMENT-32))|(1<<(SqlBaseParserCOMMIT-32))|(1<<(SqlBaseParserCOMMITTED-32))|(1<<(SqlBaseParserCURRENT-32))|(1<<(SqlBaseParserCURRENT_DATE-32))|(1<<(SqlBaseParserCURRENT_ROLE-32))|(1<<(SqlBaseParserCURRENT_TIME-32))|(1<<(SqlBaseParserCURRENT_TIMESTAMP-32))|(1<<(SqlBaseParserCURRENT_USER-32))|(1<<(SqlBaseParserDATA-32))|(1<<(SqlBaseParserDATE-32))|(1<<(SqlBaseParserDAY-32))|(1<<(SqlBaseParserDEFINER-32))|(1<<(SqlBaseParserDESC-32))|(1<<(SqlBaseParserDETERMINISTIC-32))|(1<<(SqlBaseParserDISTRIBUTED-32))|(1<<(SqlBaseParserEXCLUDING-32))|(1<<(SqlBaseParserEXISTS-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(SqlBaseParserEXPLAIN-64))|(1<<(SqlBaseParserEXTRACT-64))|(1<<(SqlBaseParserEXTERNAL-64))|(1<<(SqlBaseParserFALSE-64))|(1<<(SqlBaseParserFILTER-64))|(1<<(SqlBaseParserFIRST-64))|(1<<(SqlBaseParserFOLLOWING-64))|(1<<(SqlBaseParserFORMAT-64))|(1<<(SqlBaseParserFUNCTION-64))|(1<<(SqlBaseParserFUNCTIONS-64))|(1<<(SqlBaseParserGRANT-64))|(1<<(SqlBaseParserGRANTED-64))|(1<<(SqlBaseParserGRANTS-64))|(1<<(SqlBaseParserGRAPHVIZ-64))|(1<<(SqlBaseParserGROUPING-64))|(1<<(SqlBaseParserHOUR-64))|(1<<(SqlBaseParserIF-64))|(1<<(SqlBaseParserIGNORE-64))|(1<<(SqlBaseParserINCLUDING-64))|(1<<(SqlBaseParserINPUT-64))|(1<<(SqlBaseParserINTERVAL-64))|(1<<(SqlBaseParserINVOKER-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(SqlBaseParserIO-96))|(1<<(SqlBaseParserISOLATION-96))|(1<<(SqlBaseParserJSON-96))|(1<<(SqlBaseParserLANGUAGE-96))|(1<<(SqlBaseParserLAST-96))|(1<<(SqlBaseParserLATERAL-96))|(1<<(SqlBaseParserLEVEL-96))|(1<<(SqlBaseParserLIMIT-96))|(1<<(SqlBaseParserLOCALTIME-96))|(1<<(SqlBaseParserLOCALTIMESTAMP-96))|(1<<(SqlBaseParserLOGICAL-96))|(1<<(SqlBaseParserMAP-96))|(1<<(SqlBaseParserMATERIALIZED-96))|(1<<(SqlBaseParserMINUTE-96))|(1<<(SqlBaseParserMONTH-96))|(1<<(SqlBaseParserNAME-96))|(1<<(SqlBaseParserNFC-96))|(1<<(SqlBaseParserNFD-96))|(1<<(SqlBaseParserNFKC-96))|(1<<(SqlBaseParserNFKD-96))|(1<<(SqlBaseParserNO-96))|(1<<(SqlBaseParserNONE-96))|(1<<(SqlBaseParserNORMALIZE-96))|(1<<(SqlBaseParserNOT-96))|(1<<(SqlBaseParserNULL-96))|(1<<(SqlBaseParserNULLIF-96))|(1<<(SqlBaseParserNULLS-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(SqlBaseParserOFFSET-128))|(1<<(SqlBaseParserONLY-128))|(1<<(SqlBaseParserOPTION-128))|(1<<(SqlBaseParserORDINALITY-128))|(1<<(SqlBaseParserOUTPUT-128))|(1<<(SqlBaseParserOVER-128))|(1<<(SqlBaseParserPARTITION-128))|(1<<(SqlBaseParserPARTITIONS-128))|(1<<(SqlBaseParserPOSITION-128))|(1<<(SqlBaseParserPRECEDING-128))|(1<<(SqlBaseParserPRIVILEGES-128))|(1<<(SqlBaseParserPROPERTIES-128))|(1<<(SqlBaseParserRANGE-128))|(1<<(SqlBaseParserREAD-128))|(1<<(SqlBaseParserREFRESH-128))|(1<<(SqlBaseParserRENAME-128))|(1<<(SqlBaseParserREPEATABLE-128))|(1<<(SqlBaseParserREPLACE-128))|(1<<(SqlBaseParserRESET-128))|(1<<(SqlBaseParserRESPECT-128))|(1<<(SqlBaseParserRESTRICT-128))|(1<<(SqlBaseParserRETURN-128))|(1<<(SqlBaseParserRETURNS-128))|(1<<(SqlBaseParserREVOKE-128))|(1<<(SqlBaseParserROLE-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(SqlBaseParserROLES-160))|(1<<(SqlBaseParserROLLBACK-160))|(1<<(SqlBaseParserROW-160))|(1<<(SqlBaseParserROWS-160))|(1<<(SqlBaseParserSCHEMA-160))|(1<<(SqlBaseParserSCHEMAS-160))|(1<<(SqlBaseParserSECOND-160))|(1<<(SqlBaseParserSECURITY-160))|(1<<(SqlBaseParserSERIALIZABLE-160))|(1<<(SqlBaseParserSESSION-160))|(1<<(SqlBaseParserSET-160))|(1<<(SqlBaseParserSETS-160))|(1<<(SqlBaseParserSHOW-160))|(1<<(SqlBaseParserSOME-160))|(1<<(SqlBaseParserSQL-160))|(1<<(SqlBaseParserSTART-160))|(1<<(SqlBaseParserSTATS-160))|(1<<(SqlBaseParserSUBSTRING-160))|(1<<(SqlBaseParserSYSTEM-160))|(1<<(SqlBaseParserTABLES-160))|(1<<(SqlBaseParserTABLESAMPLE-160))|(1<<(SqlBaseParserTEMPORARY-160))|(1<<(SqlBaseParserTEXT-160))|(1<<(SqlBaseParserTIME-160))|(1<<(SqlBaseParserTIMESTAMP-160))|(1<<(SqlBaseParserTO-160))|(1<<(SqlBaseParserTRANSACTION-160))|(1<<(SqlBaseParserTRUE-160)))) != 0) || (((_la-192)&-(0x1f+1)) == 0 && ((1<<uint((_la-192)))&((1<<(SqlBaseParserTRY_CAST-192))|(1<<(SqlBaseParserTYPE-192))|(1<<(SqlBaseParserUNBOUNDED-192))|(1<<(SqlBaseParserUNCOMMITTED-192))|(1<<(SqlBaseParserUSE-192))|(1<<(SqlBaseParserUSER-192))|(1<<(SqlBaseParserVALIDATE-192))|(1<<(SqlBaseParserVERBOSE-192))|(1<<(SqlBaseParserVIEW-192))|(1<<(SqlBaseParserWORK-192))|(1<<(SqlBaseParserWRITE-192))|(1<<(SqlBaseParserYEAR-192))|(1<<(SqlBaseParserZONE-192))|(1<<(SqlBaseParserPLUS-192))|(1<<(SqlBaseParserMINUS-192)))) != 0) || (((_la-225)&-(0x1f+1)) == 0 && ((1<<uint((_la-225)))&((1<<(SqlBaseParserSTRING-225))|(1<<(SqlBaseParserUNICODE_STRING-225))|(1<<(SqlBaseParserBINARY_LITERAL-225))|(1<<(SqlBaseParserINTEGER_VALUE-225))|(1<<(SqlBaseParserDECIMAL_VALUE-225))|(1<<(SqlBaseParserDOUBLE_VALUE-225))|(1<<(SqlBaseParserIDENTIFIER-225))|(1<<(SqlBaseParserDIGIT_IDENTIFIER-225))|(1<<(SqlBaseParserQUOTED_IDENTIFIER-225))|(1<<(SqlBaseParserBACKQUOTED_IDENTIFIER-225))|(1<<(SqlBaseParserDOUBLE_PRECISION-225)))) != 0) {
			{
				p.SetState(481)
				p.CallArgument()
			}
			p.SetState(486)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__3 {
				{
					p.SetState(482)
					p.Match(SqlBaseParserT__3)
				}
				{
					p.SetState(483)
					p.CallArgument()
				}

				p.SetState(488)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(491)
			p.Match(SqlBaseParserT__2)
		}

	case 27:
		localctx = NewCreateRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(493)
			p.Match(SqlBaseParserCREATE)
		}
		{
			p.SetState(494)
			p.Match(SqlBaseParserROLE)
		}
		{
			p.SetState(495)

			var _x = p.Identifier()

			localctx.(*CreateRoleContext).name = _x
		}
		p.SetState(499)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWITH {
			{
				p.SetState(496)
				p.Match(SqlBaseParserWITH)
			}
			{
				p.SetState(497)
				p.Match(SqlBaseParserADMIN)
			}
			{
				p.SetState(498)
				p.Grantor()
			}

		}

	case 28:
		localctx = NewDropRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(501)
			p.Match(SqlBaseParserDROP)
		}
		{
			p.SetState(502)
			p.Match(SqlBaseParserROLE)
		}
		{
			p.SetState(503)

			var _x = p.Identifier()

			localctx.(*DropRoleContext).name = _x
		}

	case 29:
		localctx = NewGrantRolesContext(p, localctx)
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(504)
			p.Match(SqlBaseParserGRANT)
		}
		{
			p.SetState(505)
			p.Roles()
		}
		{
			p.SetState(506)
			p.Match(SqlBaseParserTO)
		}
		{
			p.SetState(507)
			p.Principal()
		}
		p.SetState(512)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__3 {
			{
				p.SetState(508)
				p.Match(SqlBaseParserT__3)
			}
			{
				p.SetState(509)
				p.Principal()
			}

			p.SetState(514)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(518)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWITH {
			{
				p.SetState(515)
				p.Match(SqlBaseParserWITH)
			}
			{
				p.SetState(516)
				p.Match(SqlBaseParserADMIN)
			}
			{
				p.SetState(517)
				p.Match(SqlBaseParserOPTION)
			}

		}
		p.SetState(523)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserGRANTED {
			{
				p.SetState(520)
				p.Match(SqlBaseParserGRANTED)
			}
			{
				p.SetState(521)
				p.Match(SqlBaseParserBY)
			}
			{
				p.SetState(522)
				p.Grantor()
			}

		}

	case 30:
		localctx = NewRevokeRolesContext(p, localctx)
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(525)
			p.Match(SqlBaseParserREVOKE)
		}
		p.SetState(529)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(526)
				p.Match(SqlBaseParserADMIN)
			}
			{
				p.SetState(527)
				p.Match(SqlBaseParserOPTION)
			}
			{
				p.SetState(528)
				p.Match(SqlBaseParserFOR)
			}

		}
		{
			p.SetState(531)
			p.Roles()
		}
		{
			p.SetState(532)
			p.Match(SqlBaseParserFROM)
		}
		{
			p.SetState(533)
			p.Principal()
		}
		p.SetState(538)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__3 {
			{
				p.SetState(534)
				p.Match(SqlBaseParserT__3)
			}
			{
				p.SetState(535)
				p.Principal()
			}

			p.SetState(540)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(544)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserGRANTED {
			{
				p.SetState(541)
				p.Match(SqlBaseParserGRANTED)
			}
			{
				p.SetState(542)
				p.Match(SqlBaseParserBY)
			}
			{
				p.SetState(543)
				p.Grantor()
			}

		}

	case 31:
		localctx = NewSetRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(546)
			p.Match(SqlBaseParserSET)
		}
		{
			p.SetState(547)
			p.Match(SqlBaseParserROLE)
		}
		p.SetState(551)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(548)
				p.Match(SqlBaseParserALL)
			}

		case 2:
			{
				p.SetState(549)
				p.Match(SqlBaseParserNONE)
			}

		case 3:
			{
				p.SetState(550)

				var _x = p.Identifier()

				localctx.(*SetRoleContext).role = _x
			}

		}

	case 32:
		localctx = NewGrantContext(p, localctx)
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(553)
			p.Match(SqlBaseParserGRANT)
		}
		p.SetState(564)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(554)
				p.Privilege()
			}
			p.SetState(559)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__3 {
				{
					p.SetState(555)
					p.Match(SqlBaseParserT__3)
				}
				{
					p.SetState(556)
					p.Privilege()
				}

				p.SetState(561)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		case 2:
			{
				p.SetState(562)
				p.Match(SqlBaseParserALL)
			}
			{
				p.SetState(563)
				p.Match(SqlBaseParserPRIVILEGES)
			}

		}
		{
			p.SetState(566)
			p.Match(SqlBaseParserON)
		}
		p.SetState(568)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserTABLE {
			{
				p.SetState(567)
				p.Match(SqlBaseParserTABLE)
			}

		}
		{
			p.SetState(570)
			p.QualifiedName()
		}
		{
			p.SetState(571)
			p.Match(SqlBaseParserTO)
		}
		{
			p.SetState(572)

			var _x = p.Principal()

			localctx.(*GrantContext).grantee = _x
		}
		p.SetState(576)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWITH {
			{
				p.SetState(573)
				p.Match(SqlBaseParserWITH)
			}
			{
				p.SetState(574)
				p.Match(SqlBaseParserGRANT)
			}
			{
				p.SetState(575)
				p.Match(SqlBaseParserOPTION)
			}

		}

	case 33:
		localctx = NewRevokeContext(p, localctx)
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(578)
			p.Match(SqlBaseParserREVOKE)
		}
		p.SetState(582)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(579)
				p.Match(SqlBaseParserGRANT)
			}
			{
				p.SetState(580)
				p.Match(SqlBaseParserOPTION)
			}
			{
				p.SetState(581)
				p.Match(SqlBaseParserFOR)
			}

		}
		p.SetState(594)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 61, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(584)
				p.Privilege()
			}
			p.SetState(589)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__3 {
				{
					p.SetState(585)
					p.Match(SqlBaseParserT__3)
				}
				{
					p.SetState(586)
					p.Privilege()
				}

				p.SetState(591)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		case 2:
			{
				p.SetState(592)
				p.Match(SqlBaseParserALL)
			}
			{
				p.SetState(593)
				p.Match(SqlBaseParserPRIVILEGES)
			}

		}
		{
			p.SetState(596)
			p.Match(SqlBaseParserON)
		}
		p.SetState(598)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserTABLE {
			{
				p.SetState(597)
				p.Match(SqlBaseParserTABLE)
			}

		}
		{
			p.SetState(600)
			p.QualifiedName()
		}
		{
			p.SetState(601)
			p.Match(SqlBaseParserFROM)
		}
		{
			p.SetState(602)

			var _x = p.Principal()

			localctx.(*RevokeContext).grantee = _x
		}

	case 34:
		localctx = NewShowGrantsContext(p, localctx)
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(604)
			p.Match(SqlBaseParserSHOW)
		}
		{
			p.SetState(605)
			p.Match(SqlBaseParserGRANTS)
		}
		p.SetState(611)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserON {
			{
				p.SetState(606)
				p.Match(SqlBaseParserON)
			}
			p.SetState(608)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBaseParserTABLE {
				{
					p.SetState(607)
					p.Match(SqlBaseParserTABLE)
				}

			}
			{
				p.SetState(610)
				p.QualifiedName()
			}

		}

	case 35:
		localctx = NewExplainContext(p, localctx)
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(613)
			p.Match(SqlBaseParserEXPLAIN)
		}
		p.SetState(615)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(614)
				p.Match(SqlBaseParserANALYZE)
			}

		}
		p.SetState(618)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserVERBOSE {
			{
				p.SetState(617)
				p.Match(SqlBaseParserVERBOSE)
			}

		}
		p.SetState(631)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(620)
				p.Match(SqlBaseParserT__1)
			}
			{
				p.SetState(621)
				p.ExplainOption()
			}
			p.SetState(626)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__3 {
				{
					p.SetState(622)
					p.Match(SqlBaseParserT__3)
				}
				{
					p.SetState(623)
					p.ExplainOption()
				}

				p.SetState(628)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(629)
				p.Match(SqlBaseParserT__2)
			}

		}
		{
			p.SetState(633)
			p.Statement()
		}

	case 36:
		localctx = NewShowCreateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(634)
			p.Match(SqlBaseParserSHOW)
		}
		{
			p.SetState(635)
			p.Match(SqlBaseParserCREATE)
		}
		{
			p.SetState(636)
			p.Match(SqlBaseParserTABLE)
		}
		{
			p.SetState(637)
			p.QualifiedName()
		}

	case 37:
		localctx = NewShowCreateViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(638)
			p.Match(SqlBaseParserSHOW)
		}
		{
			p.SetState(639)
			p.Match(SqlBaseParserCREATE)
		}
		{
			p.SetState(640)
			p.Match(SqlBaseParserVIEW)
		}
		{
			p.SetState(641)
			p.QualifiedName()
		}

	case 38:
		localctx = NewShowCreateMaterializedViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(642)
			p.Match(SqlBaseParserSHOW)
		}
		{
			p.SetState(643)
			p.Match(SqlBaseParserCREATE)
		}
		{
			p.SetState(644)
			p.Match(SqlBaseParserMATERIALIZED)
		}
		{
			p.SetState(645)
			p.Match(SqlBaseParserVIEW)
		}
		{
			p.SetState(646)
			p.QualifiedName()
		}

	case 39:
		localctx = NewShowCreateFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(647)
			p.Match(SqlBaseParserSHOW)
		}
		{
			p.SetState(648)
			p.Match(SqlBaseParserCREATE)
		}
		{
			p.SetState(649)
			p.Match(SqlBaseParserFUNCTION)
		}
		{
			p.SetState(650)
			p.QualifiedName()
		}
		p.SetState(652)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserT__1 {
			{
				p.SetState(651)
				p.Types()
			}

		}

	case 40:
		localctx = NewShowTablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(654)
			p.Match(SqlBaseParserSHOW)
		}
		{
			p.SetState(655)
			p.Match(SqlBaseParserTABLES)
		}
		p.SetState(658)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserFROM || _la == SqlBaseParserIN {
			{
				p.SetState(656)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBaseParserFROM || _la == SqlBaseParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(657)
				p.QualifiedName()
			}

		}
		p.SetState(666)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserLIKE {
			{
				p.SetState(660)
				p.Match(SqlBaseParserLIKE)
			}
			{
				p.SetState(661)

				var _x = p.String_()

				localctx.(*ShowTablesContext).pattern = _x
			}
			p.SetState(664)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBaseParserESCAPE {
				{
					p.SetState(662)
					p.Match(SqlBaseParserESCAPE)
				}
				{
					p.SetState(663)

					var _x = p.String_()

					localctx.(*ShowTablesContext).escape = _x
				}

			}

		}

	case 41:
		localctx = NewShowSchemasContext(p, localctx)
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(668)
			p.Match(SqlBaseParserSHOW)
		}
		{
			p.SetState(669)
			p.Match(SqlBaseParserSCHEMAS)
		}
		p.SetState(672)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserFROM || _la == SqlBaseParserIN {
			{
				p.SetState(670)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBaseParserFROM || _la == SqlBaseParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(671)
				p.Identifier()
			}

		}
		p.SetState(680)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserLIKE {
			{
				p.SetState(674)
				p.Match(SqlBaseParserLIKE)
			}
			{
				p.SetState(675)

				var _x = p.String_()

				localctx.(*ShowSchemasContext).pattern = _x
			}
			p.SetState(678)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBaseParserESCAPE {
				{
					p.SetState(676)
					p.Match(SqlBaseParserESCAPE)
				}
				{
					p.SetState(677)

					var _x = p.String_()

					localctx.(*ShowSchemasContext).escape = _x
				}

			}

		}

	case 42:
		localctx = NewShowCatalogsContext(p, localctx)
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(682)
			p.Match(SqlBaseParserSHOW)
		}
		{
			p.SetState(683)
			p.Match(SqlBaseParserCATALOGS)
		}
		p.SetState(686)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserLIKE {
			{
				p.SetState(684)
				p.Match(SqlBaseParserLIKE)
			}
			{
				p.SetState(685)

				var _x = p.String_()

				localctx.(*ShowCatalogsContext).pattern = _x
			}

		}

	case 43:
		localctx = NewShowColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(688)
			p.Match(SqlBaseParserSHOW)
		}
		{
			p.SetState(689)
			p.Match(SqlBaseParserCOLUMNS)
		}
		{
			p.SetState(690)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserFROM || _la == SqlBaseParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(691)
			p.QualifiedName()
		}

	case 44:
		localctx = NewShowStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(692)
			p.Match(SqlBaseParserSHOW)
		}
		{
			p.SetState(693)
			p.Match(SqlBaseParserSTATS)
		}
		{
			p.SetState(694)
			p.Match(SqlBaseParserFOR)
		}
		{
			p.SetState(695)
			p.QualifiedName()
		}

	case 45:
		localctx = NewShowStatsForQueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(696)
			p.Match(SqlBaseParserSHOW)
		}
		{
			p.SetState(697)
			p.Match(SqlBaseParserSTATS)
		}
		{
			p.SetState(698)
			p.Match(SqlBaseParserFOR)
		}
		{
			p.SetState(699)
			p.Match(SqlBaseParserT__1)
		}
		{
			p.SetState(700)
			p.QuerySpecification()
		}
		{
			p.SetState(701)
			p.Match(SqlBaseParserT__2)
		}

	case 46:
		localctx = NewShowRolesContext(p, localctx)
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(703)
			p.Match(SqlBaseParserSHOW)
		}
		p.SetState(705)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserCURRENT {
			{
				p.SetState(704)
				p.Match(SqlBaseParserCURRENT)
			}

		}
		{
			p.SetState(707)
			p.Match(SqlBaseParserROLES)
		}
		p.SetState(710)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserFROM || _la == SqlBaseParserIN {
			{
				p.SetState(708)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBaseParserFROM || _la == SqlBaseParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(709)
				p.Identifier()
			}

		}

	case 47:
		localctx = NewShowRoleGrantsContext(p, localctx)
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(712)
			p.Match(SqlBaseParserSHOW)
		}
		{
			p.SetState(713)
			p.Match(SqlBaseParserROLE)
		}
		{
			p.SetState(714)
			p.Match(SqlBaseParserGRANTS)
		}
		p.SetState(717)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserFROM || _la == SqlBaseParserIN {
			{
				p.SetState(715)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBaseParserFROM || _la == SqlBaseParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(716)
				p.Identifier()
			}

		}

	case 48:
		localctx = NewShowColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(719)
			p.Match(SqlBaseParserDESCRIBE)
		}
		{
			p.SetState(720)
			p.QualifiedName()
		}

	case 49:
		localctx = NewShowColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 49)
		{
			p.SetState(721)
			p.Match(SqlBaseParserDESC)
		}
		{
			p.SetState(722)
			p.QualifiedName()
		}

	case 50:
		localctx = NewShowFunctionsContext(p, localctx)
		p.EnterOuterAlt(localctx, 50)
		{
			p.SetState(723)
			p.Match(SqlBaseParserSHOW)
		}
		{
			p.SetState(724)
			p.Match(SqlBaseParserFUNCTIONS)
		}
		p.SetState(731)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserLIKE {
			{
				p.SetState(725)
				p.Match(SqlBaseParserLIKE)
			}
			{
				p.SetState(726)

				var _x = p.String_()

				localctx.(*ShowFunctionsContext).pattern = _x
			}
			p.SetState(729)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBaseParserESCAPE {
				{
					p.SetState(727)
					p.Match(SqlBaseParserESCAPE)
				}
				{
					p.SetState(728)

					var _x = p.String_()

					localctx.(*ShowFunctionsContext).escape = _x
				}

			}

		}

	case 51:
		localctx = NewShowSessionContext(p, localctx)
		p.EnterOuterAlt(localctx, 51)
		{
			p.SetState(733)
			p.Match(SqlBaseParserSHOW)
		}
		{
			p.SetState(734)
			p.Match(SqlBaseParserSESSION)
		}

	case 52:
		localctx = NewSetSessionContext(p, localctx)
		p.EnterOuterAlt(localctx, 52)
		{
			p.SetState(735)
			p.Match(SqlBaseParserSET)
		}
		{
			p.SetState(736)
			p.Match(SqlBaseParserSESSION)
		}
		{
			p.SetState(737)
			p.QualifiedName()
		}
		{
			p.SetState(738)
			p.Match(SqlBaseParserEQ)
		}
		{
			p.SetState(739)
			p.Expression()
		}

	case 53:
		localctx = NewResetSessionContext(p, localctx)
		p.EnterOuterAlt(localctx, 53)
		{
			p.SetState(741)
			p.Match(SqlBaseParserRESET)
		}
		{
			p.SetState(742)
			p.Match(SqlBaseParserSESSION)
		}
		{
			p.SetState(743)
			p.QualifiedName()
		}

	case 54:
		localctx = NewStartTransactionContext(p, localctx)
		p.EnterOuterAlt(localctx, 54)
		{
			p.SetState(744)
			p.Match(SqlBaseParserSTART)
		}
		{
			p.SetState(745)
			p.Match(SqlBaseParserTRANSACTION)
		}
		p.SetState(754)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserISOLATION || _la == SqlBaseParserREAD {
			{
				p.SetState(746)
				p.TransactionMode()
			}
			p.SetState(751)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__3 {
				{
					p.SetState(747)
					p.Match(SqlBaseParserT__3)
				}
				{
					p.SetState(748)
					p.TransactionMode()
				}

				p.SetState(753)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}

	case 55:
		localctx = NewCommitContext(p, localctx)
		p.EnterOuterAlt(localctx, 55)
		{
			p.SetState(756)
			p.Match(SqlBaseParserCOMMIT)
		}
		p.SetState(758)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWORK {
			{
				p.SetState(757)
				p.Match(SqlBaseParserWORK)
			}

		}

	case 56:
		localctx = NewRollbackContext(p, localctx)
		p.EnterOuterAlt(localctx, 56)
		{
			p.SetState(760)
			p.Match(SqlBaseParserROLLBACK)
		}
		p.SetState(762)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWORK {
			{
				p.SetState(761)
				p.Match(SqlBaseParserWORK)
			}

		}

	case 57:
		localctx = NewPrepareContext(p, localctx)
		p.EnterOuterAlt(localctx, 57)
		{
			p.SetState(764)
			p.Match(SqlBaseParserPREPARE)
		}
		{
			p.SetState(765)
			p.Identifier()
		}
		{
			p.SetState(766)
			p.Match(SqlBaseParserFROM)
		}
		{
			p.SetState(767)
			p.Statement()
		}

	case 58:
		localctx = NewDeallocateContext(p, localctx)
		p.EnterOuterAlt(localctx, 58)
		{
			p.SetState(769)
			p.Match(SqlBaseParserDEALLOCATE)
		}
		{
			p.SetState(770)
			p.Match(SqlBaseParserPREPARE)
		}
		{
			p.SetState(771)
			p.Identifier()
		}

	case 59:
		localctx = NewExecuteContext(p, localctx)
		p.EnterOuterAlt(localctx, 59)
		{
			p.SetState(772)
			p.Match(SqlBaseParserEXECUTE)
		}
		{
			p.SetState(773)
			p.Identifier()
		}
		p.SetState(783)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserUSING {
			{
				p.SetState(774)
				p.Match(SqlBaseParserUSING)
			}
			{
				p.SetState(775)
				p.Expression()
			}
			p.SetState(780)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__3 {
				{
					p.SetState(776)
					p.Match(SqlBaseParserT__3)
				}
				{
					p.SetState(777)
					p.Expression()
				}

				p.SetState(782)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}

	case 60:
		localctx = NewDescribeInputContext(p, localctx)
		p.EnterOuterAlt(localctx, 60)
		{
			p.SetState(785)
			p.Match(SqlBaseParserDESCRIBE)
		}
		{
			p.SetState(786)
			p.Match(SqlBaseParserINPUT)
		}
		{
			p.SetState(787)
			p.Identifier()
		}

	case 61:
		localctx = NewDescribeOutputContext(p, localctx)
		p.EnterOuterAlt(localctx, 61)
		{
			p.SetState(788)
			p.Match(SqlBaseParserDESCRIBE)
		}
		{
			p.SetState(789)
			p.Match(SqlBaseParserOUTPUT)
		}
		{
			p.SetState(790)
			p.Identifier()
		}

	}

	return localctx
}

// IQueryContext is an interface to support dynamic dispatch.
type IQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQueryContext differentiates from other interfaces.
	IsQueryContext()
}

type QueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryContext() *QueryContext {
	var p = new(QueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_query
	return p
}

func (*QueryContext) IsQueryContext() {}

func NewQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryContext {
	var p = new(QueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_query

	return p
}

func (s *QueryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryContext) QueryNoWith() IQueryNoWithContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryNoWithContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryNoWithContext)
}

func (s *QueryContext) With() IWithContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWithContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWithContext)
}

func (s *QueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterQuery(s)
	}
}

func (s *QueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitQuery(s)
	}
}

func (s *QueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitQuery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) Query() (localctx IQueryContext) {
	localctx = NewQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, SqlBaseParserRULE_query)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(794)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserWITH {
		{
			p.SetState(793)
			p.With()
		}

	}
	{
		p.SetState(796)
		p.QueryNoWith()
	}

	return localctx
}

// IWithContext is an interface to support dynamic dispatch.
type IWithContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWithContext differentiates from other interfaces.
	IsWithContext()
}

type WithContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithContext() *WithContext {
	var p = new(WithContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_with
	return p
}

func (*WithContext) IsWithContext() {}

func NewWithContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithContext {
	var p = new(WithContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_with

	return p
}

func (s *WithContext) GetParser() antlr.Parser { return s.parser }

func (s *WithContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *WithContext) AllNamedQuery() []INamedQueryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INamedQueryContext)(nil)).Elem())
	var tst = make([]INamedQueryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INamedQueryContext)
		}
	}

	return tst
}

func (s *WithContext) NamedQuery(i int) INamedQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedQueryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INamedQueryContext)
}

func (s *WithContext) RECURSIVE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRECURSIVE, 0)
}

func (s *WithContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterWith(s)
	}
}

func (s *WithContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitWith(s)
	}
}

func (s *WithContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitWith(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) With() (localctx IWithContext) {
	localctx = NewWithContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, SqlBaseParserRULE_with)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(798)
		p.Match(SqlBaseParserWITH)
	}
	p.SetState(800)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserRECURSIVE {
		{
			p.SetState(799)
			p.Match(SqlBaseParserRECURSIVE)
		}

	}
	{
		p.SetState(802)
		p.NamedQuery()
	}
	p.SetState(807)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserT__3 {
		{
			p.SetState(803)
			p.Match(SqlBaseParserT__3)
		}
		{
			p.SetState(804)
			p.NamedQuery()
		}

		p.SetState(809)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITableElementContext is an interface to support dynamic dispatch.
type ITableElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableElementContext differentiates from other interfaces.
	IsTableElementContext()
}

type TableElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableElementContext() *TableElementContext {
	var p = new(TableElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_tableElement
	return p
}

func (*TableElementContext) IsTableElementContext() {}

func NewTableElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableElementContext {
	var p = new(TableElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_tableElement

	return p
}

func (s *TableElementContext) GetParser() antlr.Parser { return s.parser }

func (s *TableElementContext) ColumnDefinition() IColumnDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *TableElementContext) LikeClause() ILikeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILikeClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILikeClauseContext)
}

func (s *TableElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterTableElement(s)
	}
}

func (s *TableElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitTableElement(s)
	}
}

func (s *TableElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitTableElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) TableElement() (localctx ITableElementContext) {
	localctx = NewTableElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, SqlBaseParserRULE_tableElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(812)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserADD, SqlBaseParserADMIN, SqlBaseParserALL, SqlBaseParserANALYZE, SqlBaseParserANY, SqlBaseParserARRAY, SqlBaseParserASC, SqlBaseParserAT, SqlBaseParserBERNOULLI, SqlBaseParserCALL, SqlBaseParserCALLED, SqlBaseParserCASCADE, SqlBaseParserCATALOGS, SqlBaseParserCOLUMN, SqlBaseParserCOLUMNS, SqlBaseParserCOMMENT, SqlBaseParserCOMMIT, SqlBaseParserCOMMITTED, SqlBaseParserCURRENT, SqlBaseParserCURRENT_ROLE, SqlBaseParserDATA, SqlBaseParserDATE, SqlBaseParserDAY, SqlBaseParserDEFINER, SqlBaseParserDESC, SqlBaseParserDETERMINISTIC, SqlBaseParserDISTRIBUTED, SqlBaseParserEXCLUDING, SqlBaseParserEXPLAIN, SqlBaseParserEXTERNAL, SqlBaseParserFILTER, SqlBaseParserFIRST, SqlBaseParserFOLLOWING, SqlBaseParserFORMAT, SqlBaseParserFUNCTION, SqlBaseParserFUNCTIONS, SqlBaseParserGRANT, SqlBaseParserGRANTED, SqlBaseParserGRANTS, SqlBaseParserGRAPHVIZ, SqlBaseParserHOUR, SqlBaseParserIF, SqlBaseParserIGNORE, SqlBaseParserINCLUDING, SqlBaseParserINPUT, SqlBaseParserINTERVAL, SqlBaseParserINVOKER, SqlBaseParserIO, SqlBaseParserISOLATION, SqlBaseParserJSON, SqlBaseParserLANGUAGE, SqlBaseParserLAST, SqlBaseParserLATERAL, SqlBaseParserLEVEL, SqlBaseParserLIMIT, SqlBaseParserLOGICAL, SqlBaseParserMAP, SqlBaseParserMATERIALIZED, SqlBaseParserMINUTE, SqlBaseParserMONTH, SqlBaseParserNAME, SqlBaseParserNFC, SqlBaseParserNFD, SqlBaseParserNFKC, SqlBaseParserNFKD, SqlBaseParserNO, SqlBaseParserNONE, SqlBaseParserNULLIF, SqlBaseParserNULLS, SqlBaseParserOFFSET, SqlBaseParserONLY, SqlBaseParserOPTION, SqlBaseParserORDINALITY, SqlBaseParserOUTPUT, SqlBaseParserOVER, SqlBaseParserPARTITION, SqlBaseParserPARTITIONS, SqlBaseParserPOSITION, SqlBaseParserPRECEDING, SqlBaseParserPRIVILEGES, SqlBaseParserPROPERTIES, SqlBaseParserRANGE, SqlBaseParserREAD, SqlBaseParserREFRESH, SqlBaseParserRENAME, SqlBaseParserREPEATABLE, SqlBaseParserREPLACE, SqlBaseParserRESET, SqlBaseParserRESPECT, SqlBaseParserRESTRICT, SqlBaseParserRETURN, SqlBaseParserRETURNS, SqlBaseParserREVOKE, SqlBaseParserROLE, SqlBaseParserROLES, SqlBaseParserROLLBACK, SqlBaseParserROW, SqlBaseParserROWS, SqlBaseParserSCHEMA, SqlBaseParserSCHEMAS, SqlBaseParserSECOND, SqlBaseParserSECURITY, SqlBaseParserSERIALIZABLE, SqlBaseParserSESSION, SqlBaseParserSET, SqlBaseParserSETS, SqlBaseParserSHOW, SqlBaseParserSOME, SqlBaseParserSQL, SqlBaseParserSTART, SqlBaseParserSTATS, SqlBaseParserSUBSTRING, SqlBaseParserSYSTEM, SqlBaseParserTABLES, SqlBaseParserTABLESAMPLE, SqlBaseParserTEMPORARY, SqlBaseParserTEXT, SqlBaseParserTIME, SqlBaseParserTIMESTAMP, SqlBaseParserTO, SqlBaseParserTRANSACTION, SqlBaseParserTRY_CAST, SqlBaseParserTYPE, SqlBaseParserUNBOUNDED, SqlBaseParserUNCOMMITTED, SqlBaseParserUSE, SqlBaseParserUSER, SqlBaseParserVALIDATE, SqlBaseParserVERBOSE, SqlBaseParserVIEW, SqlBaseParserWORK, SqlBaseParserWRITE, SqlBaseParserYEAR, SqlBaseParserZONE, SqlBaseParserIDENTIFIER, SqlBaseParserDIGIT_IDENTIFIER, SqlBaseParserQUOTED_IDENTIFIER, SqlBaseParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(810)
			p.ColumnDefinition()
		}

	case SqlBaseParserLIKE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(811)
			p.LikeClause()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IColumnDefinitionContext is an interface to support dynamic dispatch.
type IColumnDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumnDefinitionContext differentiates from other interfaces.
	IsColumnDefinitionContext()
}

type ColumnDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnDefinitionContext() *ColumnDefinitionContext {
	var p = new(ColumnDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_columnDefinition
	return p
}

func (*ColumnDefinitionContext) IsColumnDefinitionContext() {}

func NewColumnDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnDefinitionContext {
	var p = new(ColumnDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_columnDefinition

	return p
}

func (s *ColumnDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnDefinitionContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnDefinitionContext) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *ColumnDefinitionContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *ColumnDefinitionContext) NULL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULL, 0)
}

func (s *ColumnDefinitionContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMENT, 0)
}

func (s *ColumnDefinitionContext) String_() IString_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *ColumnDefinitionContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *ColumnDefinitionContext) Properties() IPropertiesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertiesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *ColumnDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterColumnDefinition(s)
	}
}

func (s *ColumnDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitColumnDefinition(s)
	}
}

func (s *ColumnDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitColumnDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) ColumnDefinition() (localctx IColumnDefinitionContext) {
	localctx = NewColumnDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, SqlBaseParserRULE_columnDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(814)
		p.Identifier()
	}
	{
		p.SetState(815)
		p.type_(0)
	}
	p.SetState(818)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserNOT {
		{
			p.SetState(816)
			p.Match(SqlBaseParserNOT)
		}
		{
			p.SetState(817)
			p.Match(SqlBaseParserNULL)
		}

	}
	p.SetState(822)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserCOMMENT {
		{
			p.SetState(820)
			p.Match(SqlBaseParserCOMMENT)
		}
		{
			p.SetState(821)
			p.String_()
		}

	}
	p.SetState(826)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserWITH {
		{
			p.SetState(824)
			p.Match(SqlBaseParserWITH)
		}
		{
			p.SetState(825)
			p.Properties()
		}

	}

	return localctx
}

// ILikeClauseContext is an interface to support dynamic dispatch.
type ILikeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOptionType returns the optionType token.
	GetOptionType() antlr.Token

	// SetOptionType sets the optionType token.
	SetOptionType(antlr.Token)

	// IsLikeClauseContext differentiates from other interfaces.
	IsLikeClauseContext()
}

type LikeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser     antlr.Parser
	optionType antlr.Token
}

func NewEmptyLikeClauseContext() *LikeClauseContext {
	var p = new(LikeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_likeClause
	return p
}

func (*LikeClauseContext) IsLikeClauseContext() {}

func NewLikeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LikeClauseContext {
	var p = new(LikeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_likeClause

	return p
}

func (s *LikeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LikeClauseContext) GetOptionType() antlr.Token { return s.optionType }

func (s *LikeClauseContext) SetOptionType(v antlr.Token) { s.optionType = v }

func (s *LikeClauseContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIKE, 0)
}

func (s *LikeClauseContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *LikeClauseContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPROPERTIES, 0)
}

func (s *LikeClauseContext) INCLUDING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINCLUDING, 0)
}

func (s *LikeClauseContext) EXCLUDING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXCLUDING, 0)
}

func (s *LikeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LikeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterLikeClause(s)
	}
}

func (s *LikeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitLikeClause(s)
	}
}

func (s *LikeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitLikeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) LikeClause() (localctx ILikeClauseContext) {
	localctx = NewLikeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, SqlBaseParserRULE_likeClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(828)
		p.Match(SqlBaseParserLIKE)
	}
	{
		p.SetState(829)
		p.QualifiedName()
	}
	p.SetState(832)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserEXCLUDING || _la == SqlBaseParserINCLUDING {
		{
			p.SetState(830)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LikeClauseContext).optionType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserEXCLUDING || _la == SqlBaseParserINCLUDING) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LikeClauseContext).optionType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(831)
			p.Match(SqlBaseParserPROPERTIES)
		}

	}

	return localctx
}

// IPropertiesContext is an interface to support dynamic dispatch.
type IPropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertiesContext differentiates from other interfaces.
	IsPropertiesContext()
}

type PropertiesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertiesContext() *PropertiesContext {
	var p = new(PropertiesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_properties
	return p
}

func (*PropertiesContext) IsPropertiesContext() {}

func NewPropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertiesContext {
	var p = new(PropertiesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_properties

	return p
}

func (s *PropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertiesContext) AllProperty() []IPropertyContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPropertyContext)(nil)).Elem())
	var tst = make([]IPropertyContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPropertyContext)
		}
	}

	return tst
}

func (s *PropertiesContext) Property(i int) IPropertyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *PropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterProperties(s)
	}
}

func (s *PropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitProperties(s)
	}
}

func (s *PropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitProperties(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) Properties() (localctx IPropertiesContext) {
	localctx = NewPropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, SqlBaseParserRULE_properties)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(834)
		p.Match(SqlBaseParserT__1)
	}
	{
		p.SetState(835)
		p.Property()
	}
	p.SetState(840)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserT__3 {
		{
			p.SetState(836)
			p.Match(SqlBaseParserT__3)
		}
		{
			p.SetState(837)
			p.Property()
		}

		p.SetState(842)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(843)
		p.Match(SqlBaseParserT__2)
	}

	return localctx
}

// IPropertyContext is an interface to support dynamic dispatch.
type IPropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyContext differentiates from other interfaces.
	IsPropertyContext()
}

type PropertyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyContext() *PropertyContext {
	var p = new(PropertyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_property
	return p
}

func (*PropertyContext) IsPropertyContext() {}

func NewPropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyContext {
	var p = new(PropertyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_property

	return p
}

func (s *PropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PropertyContext) EQ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEQ, 0)
}

func (s *PropertyContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterProperty(s)
	}
}

func (s *PropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitProperty(s)
	}
}

func (s *PropertyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitProperty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) Property() (localctx IPropertyContext) {
	localctx = NewPropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, SqlBaseParserRULE_property)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(845)
		p.Identifier()
	}
	{
		p.SetState(846)
		p.Match(SqlBaseParserEQ)
	}
	{
		p.SetState(847)
		p.Expression()
	}

	return localctx
}

// ISqlParameterDeclarationContext is an interface to support dynamic dispatch.
type ISqlParameterDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSqlParameterDeclarationContext differentiates from other interfaces.
	IsSqlParameterDeclarationContext()
}

type SqlParameterDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySqlParameterDeclarationContext() *SqlParameterDeclarationContext {
	var p = new(SqlParameterDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_sqlParameterDeclaration
	return p
}

func (*SqlParameterDeclarationContext) IsSqlParameterDeclarationContext() {}

func NewSqlParameterDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SqlParameterDeclarationContext {
	var p = new(SqlParameterDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_sqlParameterDeclaration

	return p
}

func (s *SqlParameterDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *SqlParameterDeclarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SqlParameterDeclarationContext) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *SqlParameterDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqlParameterDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SqlParameterDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSqlParameterDeclaration(s)
	}
}

func (s *SqlParameterDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSqlParameterDeclaration(s)
	}
}

func (s *SqlParameterDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSqlParameterDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) SqlParameterDeclaration() (localctx ISqlParameterDeclarationContext) {
	localctx = NewSqlParameterDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, SqlBaseParserRULE_sqlParameterDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(849)
		p.Identifier()
	}
	{
		p.SetState(850)
		p.type_(0)
	}

	return localctx
}

// IRoutineCharacteristicsContext is an interface to support dynamic dispatch.
type IRoutineCharacteristicsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRoutineCharacteristicsContext differentiates from other interfaces.
	IsRoutineCharacteristicsContext()
}

type RoutineCharacteristicsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoutineCharacteristicsContext() *RoutineCharacteristicsContext {
	var p = new(RoutineCharacteristicsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_routineCharacteristics
	return p
}

func (*RoutineCharacteristicsContext) IsRoutineCharacteristicsContext() {}

func NewRoutineCharacteristicsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoutineCharacteristicsContext {
	var p = new(RoutineCharacteristicsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_routineCharacteristics

	return p
}

func (s *RoutineCharacteristicsContext) GetParser() antlr.Parser { return s.parser }

func (s *RoutineCharacteristicsContext) AllRoutineCharacteristic() []IRoutineCharacteristicContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRoutineCharacteristicContext)(nil)).Elem())
	var tst = make([]IRoutineCharacteristicContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRoutineCharacteristicContext)
		}
	}

	return tst
}

func (s *RoutineCharacteristicsContext) RoutineCharacteristic(i int) IRoutineCharacteristicContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRoutineCharacteristicContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRoutineCharacteristicContext)
}

func (s *RoutineCharacteristicsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineCharacteristicsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoutineCharacteristicsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRoutineCharacteristics(s)
	}
}

func (s *RoutineCharacteristicsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRoutineCharacteristics(s)
	}
}

func (s *RoutineCharacteristicsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitRoutineCharacteristics(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) RoutineCharacteristics() (localctx IRoutineCharacteristicsContext) {
	localctx = NewRoutineCharacteristicsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, SqlBaseParserRULE_routineCharacteristics)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(855)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserCALLED || _la == SqlBaseParserDETERMINISTIC || _la == SqlBaseParserLANGUAGE || _la == SqlBaseParserNOT || _la == SqlBaseParserRETURNS {
		{
			p.SetState(852)
			p.RoutineCharacteristic()
		}

		p.SetState(857)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IRoutineCharacteristicContext is an interface to support dynamic dispatch.
type IRoutineCharacteristicContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRoutineCharacteristicContext differentiates from other interfaces.
	IsRoutineCharacteristicContext()
}

type RoutineCharacteristicContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoutineCharacteristicContext() *RoutineCharacteristicContext {
	var p = new(RoutineCharacteristicContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_routineCharacteristic
	return p
}

func (*RoutineCharacteristicContext) IsRoutineCharacteristicContext() {}

func NewRoutineCharacteristicContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoutineCharacteristicContext {
	var p = new(RoutineCharacteristicContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_routineCharacteristic

	return p
}

func (s *RoutineCharacteristicContext) GetParser() antlr.Parser { return s.parser }

func (s *RoutineCharacteristicContext) LANGUAGE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLANGUAGE, 0)
}

func (s *RoutineCharacteristicContext) Language() ILanguageContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILanguageContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILanguageContext)
}

func (s *RoutineCharacteristicContext) Determinism() IDeterminismContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeterminismContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeterminismContext)
}

func (s *RoutineCharacteristicContext) NullCallClause() INullCallClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INullCallClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INullCallClauseContext)
}

func (s *RoutineCharacteristicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineCharacteristicContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoutineCharacteristicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRoutineCharacteristic(s)
	}
}

func (s *RoutineCharacteristicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRoutineCharacteristic(s)
	}
}

func (s *RoutineCharacteristicContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitRoutineCharacteristic(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) RoutineCharacteristic() (localctx IRoutineCharacteristicContext) {
	localctx = NewRoutineCharacteristicContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, SqlBaseParserRULE_routineCharacteristic)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(862)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserLANGUAGE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(858)
			p.Match(SqlBaseParserLANGUAGE)
		}
		{
			p.SetState(859)
			p.Language()
		}

	case SqlBaseParserDETERMINISTIC, SqlBaseParserNOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(860)
			p.Determinism()
		}

	case SqlBaseParserCALLED, SqlBaseParserRETURNS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(861)
			p.NullCallClause()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAlterRoutineCharacteristicsContext is an interface to support dynamic dispatch.
type IAlterRoutineCharacteristicsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterRoutineCharacteristicsContext differentiates from other interfaces.
	IsAlterRoutineCharacteristicsContext()
}

type AlterRoutineCharacteristicsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterRoutineCharacteristicsContext() *AlterRoutineCharacteristicsContext {
	var p = new(AlterRoutineCharacteristicsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_alterRoutineCharacteristics
	return p
}

func (*AlterRoutineCharacteristicsContext) IsAlterRoutineCharacteristicsContext() {}

func NewAlterRoutineCharacteristicsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterRoutineCharacteristicsContext {
	var p = new(AlterRoutineCharacteristicsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_alterRoutineCharacteristics

	return p
}

func (s *AlterRoutineCharacteristicsContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterRoutineCharacteristicsContext) AllAlterRoutineCharacteristic() []IAlterRoutineCharacteristicContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAlterRoutineCharacteristicContext)(nil)).Elem())
	var tst = make([]IAlterRoutineCharacteristicContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAlterRoutineCharacteristicContext)
		}
	}

	return tst
}

func (s *AlterRoutineCharacteristicsContext) AlterRoutineCharacteristic(i int) IAlterRoutineCharacteristicContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterRoutineCharacteristicContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAlterRoutineCharacteristicContext)
}

func (s *AlterRoutineCharacteristicsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterRoutineCharacteristicsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterRoutineCharacteristicsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterAlterRoutineCharacteristics(s)
	}
}

func (s *AlterRoutineCharacteristicsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitAlterRoutineCharacteristics(s)
	}
}

func (s *AlterRoutineCharacteristicsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitAlterRoutineCharacteristics(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) AlterRoutineCharacteristics() (localctx IAlterRoutineCharacteristicsContext) {
	localctx = NewAlterRoutineCharacteristicsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, SqlBaseParserRULE_alterRoutineCharacteristics)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(867)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserCALLED || _la == SqlBaseParserRETURNS {
		{
			p.SetState(864)
			p.AlterRoutineCharacteristic()
		}

		p.SetState(869)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAlterRoutineCharacteristicContext is an interface to support dynamic dispatch.
type IAlterRoutineCharacteristicContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterRoutineCharacteristicContext differentiates from other interfaces.
	IsAlterRoutineCharacteristicContext()
}

type AlterRoutineCharacteristicContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterRoutineCharacteristicContext() *AlterRoutineCharacteristicContext {
	var p = new(AlterRoutineCharacteristicContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_alterRoutineCharacteristic
	return p
}

func (*AlterRoutineCharacteristicContext) IsAlterRoutineCharacteristicContext() {}

func NewAlterRoutineCharacteristicContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterRoutineCharacteristicContext {
	var p = new(AlterRoutineCharacteristicContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_alterRoutineCharacteristic

	return p
}

func (s *AlterRoutineCharacteristicContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterRoutineCharacteristicContext) NullCallClause() INullCallClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INullCallClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INullCallClauseContext)
}

func (s *AlterRoutineCharacteristicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterRoutineCharacteristicContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterRoutineCharacteristicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterAlterRoutineCharacteristic(s)
	}
}

func (s *AlterRoutineCharacteristicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitAlterRoutineCharacteristic(s)
	}
}

func (s *AlterRoutineCharacteristicContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitAlterRoutineCharacteristic(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) AlterRoutineCharacteristic() (localctx IAlterRoutineCharacteristicContext) {
	localctx = NewAlterRoutineCharacteristicContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, SqlBaseParserRULE_alterRoutineCharacteristic)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(870)
		p.NullCallClause()
	}

	return localctx
}

// IRoutineBodyContext is an interface to support dynamic dispatch.
type IRoutineBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRoutineBodyContext differentiates from other interfaces.
	IsRoutineBodyContext()
}

type RoutineBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoutineBodyContext() *RoutineBodyContext {
	var p = new(RoutineBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_routineBody
	return p
}

func (*RoutineBodyContext) IsRoutineBodyContext() {}

func NewRoutineBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoutineBodyContext {
	var p = new(RoutineBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_routineBody

	return p
}

func (s *RoutineBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *RoutineBodyContext) ReturnStatement() IReturnStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *RoutineBodyContext) ExternalBodyReference() IExternalBodyReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExternalBodyReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExternalBodyReferenceContext)
}

func (s *RoutineBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoutineBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRoutineBody(s)
	}
}

func (s *RoutineBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRoutineBody(s)
	}
}

func (s *RoutineBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitRoutineBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) RoutineBody() (localctx IRoutineBodyContext) {
	localctx = NewRoutineBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, SqlBaseParserRULE_routineBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(874)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserRETURN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(872)
			p.ReturnStatement()
		}

	case SqlBaseParserEXTERNAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(873)
			p.ExternalBodyReference()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_returnStatement
	return p
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) RETURN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRETURN, 0)
}

func (s *ReturnStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterReturnStatement(s)
	}
}

func (s *ReturnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitReturnStatement(s)
	}
}

func (s *ReturnStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitReturnStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) ReturnStatement() (localctx IReturnStatementContext) {
	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, SqlBaseParserRULE_returnStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(876)
		p.Match(SqlBaseParserRETURN)
	}
	{
		p.SetState(877)
		p.Expression()
	}

	return localctx
}

// IExternalBodyReferenceContext is an interface to support dynamic dispatch.
type IExternalBodyReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExternalBodyReferenceContext differentiates from other interfaces.
	IsExternalBodyReferenceContext()
}

type ExternalBodyReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternalBodyReferenceContext() *ExternalBodyReferenceContext {
	var p = new(ExternalBodyReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_externalBodyReference
	return p
}

func (*ExternalBodyReferenceContext) IsExternalBodyReferenceContext() {}

func NewExternalBodyReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExternalBodyReferenceContext {
	var p = new(ExternalBodyReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_externalBodyReference

	return p
}

func (s *ExternalBodyReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ExternalBodyReferenceContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXTERNAL, 0)
}

func (s *ExternalBodyReferenceContext) NAME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNAME, 0)
}

func (s *ExternalBodyReferenceContext) ExternalRoutineName() IExternalRoutineNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExternalRoutineNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExternalRoutineNameContext)
}

func (s *ExternalBodyReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternalBodyReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExternalBodyReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterExternalBodyReference(s)
	}
}

func (s *ExternalBodyReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitExternalBodyReference(s)
	}
}

func (s *ExternalBodyReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitExternalBodyReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) ExternalBodyReference() (localctx IExternalBodyReferenceContext) {
	localctx = NewExternalBodyReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, SqlBaseParserRULE_externalBodyReference)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(879)
		p.Match(SqlBaseParserEXTERNAL)
	}
	p.SetState(882)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserNAME {
		{
			p.SetState(880)
			p.Match(SqlBaseParserNAME)
		}
		{
			p.SetState(881)
			p.ExternalRoutineName()
		}

	}

	return localctx
}

// ILanguageContext is an interface to support dynamic dispatch.
type ILanguageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLanguageContext differentiates from other interfaces.
	IsLanguageContext()
}

type LanguageContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLanguageContext() *LanguageContext {
	var p = new(LanguageContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_language
	return p
}

func (*LanguageContext) IsLanguageContext() {}

func NewLanguageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LanguageContext {
	var p = new(LanguageContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_language

	return p
}

func (s *LanguageContext) GetParser() antlr.Parser { return s.parser }

func (s *LanguageContext) SQL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSQL, 0)
}

func (s *LanguageContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LanguageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LanguageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LanguageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterLanguage(s)
	}
}

func (s *LanguageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitLanguage(s)
	}
}

func (s *LanguageContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitLanguage(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) Language() (localctx ILanguageContext) {
	localctx = NewLanguageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, SqlBaseParserRULE_language)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(886)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 103, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(884)
			p.Match(SqlBaseParserSQL)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(885)
			p.Identifier()
		}

	}

	return localctx
}

// IDeterminismContext is an interface to support dynamic dispatch.
type IDeterminismContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeterminismContext differentiates from other interfaces.
	IsDeterminismContext()
}

type DeterminismContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeterminismContext() *DeterminismContext {
	var p = new(DeterminismContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_determinism
	return p
}

func (*DeterminismContext) IsDeterminismContext() {}

func NewDeterminismContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeterminismContext {
	var p = new(DeterminismContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_determinism

	return p
}

func (s *DeterminismContext) GetParser() antlr.Parser { return s.parser }

func (s *DeterminismContext) DETERMINISTIC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDETERMINISTIC, 0)
}

func (s *DeterminismContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *DeterminismContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeterminismContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeterminismContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDeterminism(s)
	}
}

func (s *DeterminismContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDeterminism(s)
	}
}

func (s *DeterminismContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitDeterminism(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) Determinism() (localctx IDeterminismContext) {
	localctx = NewDeterminismContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, SqlBaseParserRULE_determinism)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(891)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserDETERMINISTIC:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(888)
			p.Match(SqlBaseParserDETERMINISTIC)
		}

	case SqlBaseParserNOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(889)
			p.Match(SqlBaseParserNOT)
		}
		{
			p.SetState(890)
			p.Match(SqlBaseParserDETERMINISTIC)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INullCallClauseContext is an interface to support dynamic dispatch.
type INullCallClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNullCallClauseContext differentiates from other interfaces.
	IsNullCallClauseContext()
}

type NullCallClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullCallClauseContext() *NullCallClauseContext {
	var p = new(NullCallClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_nullCallClause
	return p
}

func (*NullCallClauseContext) IsNullCallClauseContext() {}

func NewNullCallClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullCallClauseContext {
	var p = new(NullCallClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_nullCallClause

	return p
}

func (s *NullCallClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *NullCallClauseContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRETURNS, 0)
}

func (s *NullCallClauseContext) AllNULL() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserNULL)
}

func (s *NullCallClauseContext) NULL(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULL, i)
}

func (s *NullCallClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserON, 0)
}

func (s *NullCallClauseContext) INPUT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINPUT, 0)
}

func (s *NullCallClauseContext) CALLED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCALLED, 0)
}

func (s *NullCallClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullCallClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullCallClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterNullCallClause(s)
	}
}

func (s *NullCallClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitNullCallClause(s)
	}
}

func (s *NullCallClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitNullCallClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) NullCallClause() (localctx INullCallClauseContext) {
	localctx = NewNullCallClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, SqlBaseParserRULE_nullCallClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(902)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserRETURNS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(893)
			p.Match(SqlBaseParserRETURNS)
		}
		{
			p.SetState(894)
			p.Match(SqlBaseParserNULL)
		}
		{
			p.SetState(895)
			p.Match(SqlBaseParserON)
		}
		{
			p.SetState(896)
			p.Match(SqlBaseParserNULL)
		}
		{
			p.SetState(897)
			p.Match(SqlBaseParserINPUT)
		}

	case SqlBaseParserCALLED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(898)
			p.Match(SqlBaseParserCALLED)
		}
		{
			p.SetState(899)
			p.Match(SqlBaseParserON)
		}
		{
			p.SetState(900)
			p.Match(SqlBaseParserNULL)
		}
		{
			p.SetState(901)
			p.Match(SqlBaseParserINPUT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExternalRoutineNameContext is an interface to support dynamic dispatch.
type IExternalRoutineNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExternalRoutineNameContext differentiates from other interfaces.
	IsExternalRoutineNameContext()
}

type ExternalRoutineNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternalRoutineNameContext() *ExternalRoutineNameContext {
	var p = new(ExternalRoutineNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_externalRoutineName
	return p
}

func (*ExternalRoutineNameContext) IsExternalRoutineNameContext() {}

func NewExternalRoutineNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExternalRoutineNameContext {
	var p = new(ExternalRoutineNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_externalRoutineName

	return p
}

func (s *ExternalRoutineNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ExternalRoutineNameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExternalRoutineNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternalRoutineNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExternalRoutineNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterExternalRoutineName(s)
	}
}

func (s *ExternalRoutineNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitExternalRoutineName(s)
	}
}

func (s *ExternalRoutineNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitExternalRoutineName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) ExternalRoutineName() (localctx IExternalRoutineNameContext) {
	localctx = NewExternalRoutineNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, SqlBaseParserRULE_externalRoutineName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(904)
		p.Identifier()
	}

	return localctx
}

// IQueryNoWithContext is an interface to support dynamic dispatch.
type IQueryNoWithContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOffset returns the offset token.
	GetOffset() antlr.Token

	// GetLimit returns the limit token.
	GetLimit() antlr.Token

	// SetOffset sets the offset token.
	SetOffset(antlr.Token)

	// SetLimit sets the limit token.
	SetLimit(antlr.Token)

	// IsQueryNoWithContext differentiates from other interfaces.
	IsQueryNoWithContext()
}

type QueryNoWithContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	offset antlr.Token
	limit  antlr.Token
}

func NewEmptyQueryNoWithContext() *QueryNoWithContext {
	var p = new(QueryNoWithContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_queryNoWith
	return p
}

func (*QueryNoWithContext) IsQueryNoWithContext() {}

func NewQueryNoWithContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryNoWithContext {
	var p = new(QueryNoWithContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_queryNoWith

	return p
}

func (s *QueryNoWithContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryNoWithContext) GetOffset() antlr.Token { return s.offset }

func (s *QueryNoWithContext) GetLimit() antlr.Token { return s.limit }

func (s *QueryNoWithContext) SetOffset(v antlr.Token) { s.offset = v }

func (s *QueryNoWithContext) SetLimit(v antlr.Token) { s.limit = v }

func (s *QueryNoWithContext) QueryTerm() IQueryTermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryTermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryTermContext)
}

func (s *QueryNoWithContext) ORDER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserORDER, 0)
}

func (s *QueryNoWithContext) BY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBY, 0)
}

func (s *QueryNoWithContext) AllSortItem() []ISortItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISortItemContext)(nil)).Elem())
	var tst = make([]ISortItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISortItemContext)
		}
	}

	return tst
}

func (s *QueryNoWithContext) SortItem(i int) ISortItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *QueryNoWithContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOFFSET, 0)
}

func (s *QueryNoWithContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIMIT, 0)
}

func (s *QueryNoWithContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserINTEGER_VALUE)
}

func (s *QueryNoWithContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTEGER_VALUE, i)
}

func (s *QueryNoWithContext) ALL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALL, 0)
}

func (s *QueryNoWithContext) ROW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROW, 0)
}

func (s *QueryNoWithContext) ROWS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROWS, 0)
}

func (s *QueryNoWithContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryNoWithContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryNoWithContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterQueryNoWith(s)
	}
}

func (s *QueryNoWithContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitQueryNoWith(s)
	}
}

func (s *QueryNoWithContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitQueryNoWith(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) QueryNoWith() (localctx IQueryNoWithContext) {
	localctx = NewQueryNoWithContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, SqlBaseParserRULE_queryNoWith)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(906)
		p.queryTerm(0)
	}
	p.SetState(917)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserORDER {
		{
			p.SetState(907)
			p.Match(SqlBaseParserORDER)
		}
		{
			p.SetState(908)
			p.Match(SqlBaseParserBY)
		}
		{
			p.SetState(909)
			p.SortItem()
		}
		p.SetState(914)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__3 {
			{
				p.SetState(910)
				p.Match(SqlBaseParserT__3)
			}
			{
				p.SetState(911)
				p.SortItem()
			}

			p.SetState(916)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(924)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserOFFSET {
		{
			p.SetState(919)
			p.Match(SqlBaseParserOFFSET)
		}
		{
			p.SetState(920)

			var _m = p.Match(SqlBaseParserINTEGER_VALUE)

			localctx.(*QueryNoWithContext).offset = _m
		}
		p.SetState(922)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserROW || _la == SqlBaseParserROWS {
			{
				p.SetState(921)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBaseParserROW || _la == SqlBaseParserROWS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	}
	p.SetState(928)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserLIMIT {
		{
			p.SetState(926)
			p.Match(SqlBaseParserLIMIT)
		}
		{
			p.SetState(927)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*QueryNoWithContext).limit = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserALL || _la == SqlBaseParserINTEGER_VALUE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*QueryNoWithContext).limit = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IQueryTermContext is an interface to support dynamic dispatch.
type IQueryTermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQueryTermContext differentiates from other interfaces.
	IsQueryTermContext()
}

type QueryTermContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryTermContext() *QueryTermContext {
	var p = new(QueryTermContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_queryTerm
	return p
}

func (*QueryTermContext) IsQueryTermContext() {}

func NewQueryTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryTermContext {
	var p = new(QueryTermContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_queryTerm

	return p
}

func (s *QueryTermContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryTermContext) CopyFrom(ctx *QueryTermContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *QueryTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryTermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type QueryTermDefaultContext struct {
	*QueryTermContext
}

func NewQueryTermDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryTermDefaultContext {
	var p = new(QueryTermDefaultContext)

	p.QueryTermContext = NewEmptyQueryTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*QueryTermContext))

	return p
}

func (s *QueryTermDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryTermDefaultContext) QueryPrimary() IQueryPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryPrimaryContext)
}

func (s *QueryTermDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterQueryTermDefault(s)
	}
}

func (s *QueryTermDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitQueryTermDefault(s)
	}
}

func (s *QueryTermDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitQueryTermDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetOperationContext struct {
	*QueryTermContext
	left     IQueryTermContext
	operator antlr.Token
	right    IQueryTermContext
}

func NewSetOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetOperationContext {
	var p = new(SetOperationContext)

	p.QueryTermContext = NewEmptyQueryTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*QueryTermContext))

	return p
}

func (s *SetOperationContext) GetOperator() antlr.Token { return s.operator }

func (s *SetOperationContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *SetOperationContext) GetLeft() IQueryTermContext { return s.left }

func (s *SetOperationContext) GetRight() IQueryTermContext { return s.right }

func (s *SetOperationContext) SetLeft(v IQueryTermContext) { s.left = v }

func (s *SetOperationContext) SetRight(v IQueryTermContext) { s.right = v }

func (s *SetOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetOperationContext) AllQueryTerm() []IQueryTermContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQueryTermContext)(nil)).Elem())
	var tst = make([]IQueryTermContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQueryTermContext)
		}
	}

	return tst
}

func (s *SetOperationContext) QueryTerm(i int) IQueryTermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryTermContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQueryTermContext)
}

func (s *SetOperationContext) INTERSECT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTERSECT, 0)
}

func (s *SetOperationContext) SetQuantifier() ISetQuantifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetQuantifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *SetOperationContext) UNION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNION, 0)
}

func (s *SetOperationContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXCEPT, 0)
}

func (s *SetOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSetOperation(s)
	}
}

func (s *SetOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSetOperation(s)
	}
}

func (s *SetOperationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSetOperation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) QueryTerm() (localctx IQueryTermContext) {
	return p.queryTerm(0)
}

func (p *SqlBaseParser) queryTerm(_p int) (localctx IQueryTermContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewQueryTermContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IQueryTermContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 48
	p.EnterRecursionRule(localctx, 48, SqlBaseParserRULE_queryTerm, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewQueryTermDefaultContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(931)
		p.QueryPrimary()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(947)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(945)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 113, p.GetParserRuleContext()) {
			case 1:
				localctx = NewSetOperationContext(p, NewQueryTermContext(p, _parentctx, _parentState))
				localctx.(*SetOperationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_queryTerm)
				p.SetState(933)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(934)

					var _m = p.Match(SqlBaseParserINTERSECT)

					localctx.(*SetOperationContext).operator = _m
				}
				p.SetState(936)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == SqlBaseParserALL || _la == SqlBaseParserDISTINCT {
					{
						p.SetState(935)
						p.SetQuantifier()
					}

				}
				{
					p.SetState(938)

					var _x = p.queryTerm(3)

					localctx.(*SetOperationContext).right = _x
				}

			case 2:
				localctx = NewSetOperationContext(p, NewQueryTermContext(p, _parentctx, _parentState))
				localctx.(*SetOperationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_queryTerm)
				p.SetState(939)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(940)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*SetOperationContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == SqlBaseParserEXCEPT || _la == SqlBaseParserUNION) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*SetOperationContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				p.SetState(942)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == SqlBaseParserALL || _la == SqlBaseParserDISTINCT {
					{
						p.SetState(941)
						p.SetQuantifier()
					}

				}
				{
					p.SetState(944)

					var _x = p.queryTerm(2)

					localctx.(*SetOperationContext).right = _x
				}

			}

		}
		p.SetState(949)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext())
	}

	return localctx
}

// IQueryPrimaryContext is an interface to support dynamic dispatch.
type IQueryPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQueryPrimaryContext differentiates from other interfaces.
	IsQueryPrimaryContext()
}

type QueryPrimaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryPrimaryContext() *QueryPrimaryContext {
	var p = new(QueryPrimaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_queryPrimary
	return p
}

func (*QueryPrimaryContext) IsQueryPrimaryContext() {}

func NewQueryPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryPrimaryContext {
	var p = new(QueryPrimaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_queryPrimary

	return p
}

func (s *QueryPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryPrimaryContext) CopyFrom(ctx *QueryPrimaryContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *QueryPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SubqueryContext struct {
	*QueryPrimaryContext
}

func NewSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryContext {
	var p = new(SubqueryContext)

	p.QueryPrimaryContext = NewEmptyQueryPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*QueryPrimaryContext))

	return p
}

func (s *SubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryContext) QueryNoWith() IQueryNoWithContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryNoWithContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryNoWithContext)
}

func (s *SubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSubquery(s)
	}
}

func (s *SubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSubquery(s)
	}
}

func (s *SubqueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSubquery(s)

	default:
		return t.VisitChildren(s)
	}
}

type QueryPrimaryDefaultContext struct {
	*QueryPrimaryContext
}

func NewQueryPrimaryDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryPrimaryDefaultContext {
	var p = new(QueryPrimaryDefaultContext)

	p.QueryPrimaryContext = NewEmptyQueryPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*QueryPrimaryContext))

	return p
}

func (s *QueryPrimaryDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPrimaryDefaultContext) QuerySpecification() IQuerySpecificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuerySpecificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *QueryPrimaryDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterQueryPrimaryDefault(s)
	}
}

func (s *QueryPrimaryDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitQueryPrimaryDefault(s)
	}
}

func (s *QueryPrimaryDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitQueryPrimaryDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableContext struct {
	*QueryPrimaryContext
}

func NewTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableContext {
	var p = new(TableContext)

	p.QueryPrimaryContext = NewEmptyQueryPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*QueryPrimaryContext))

	return p
}

func (s *TableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *TableContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterTable(s)
	}
}

func (s *TableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitTable(s)
	}
}

func (s *TableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitTable(s)

	default:
		return t.VisitChildren(s)
	}
}

type InlineTableContext struct {
	*QueryPrimaryContext
}

func NewInlineTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InlineTableContext {
	var p = new(InlineTableContext)

	p.QueryPrimaryContext = NewEmptyQueryPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*QueryPrimaryContext))

	return p
}

func (s *InlineTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineTableContext) VALUES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVALUES, 0)
}

func (s *InlineTableContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *InlineTableContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InlineTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterInlineTable(s)
	}
}

func (s *InlineTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitInlineTable(s)
	}
}

func (s *InlineTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitInlineTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) QueryPrimary() (localctx IQueryPrimaryContext) {
	localctx = NewQueryPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, SqlBaseParserRULE_queryPrimary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(966)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserSELECT:
		localctx = NewQueryPrimaryDefaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(950)
			p.QuerySpecification()
		}

	case SqlBaseParserTABLE:
		localctx = NewTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(951)
			p.Match(SqlBaseParserTABLE)
		}
		{
			p.SetState(952)
			p.QualifiedName()
		}

	case SqlBaseParserVALUES:
		localctx = NewInlineTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(953)
			p.Match(SqlBaseParserVALUES)
		}
		{
			p.SetState(954)
			p.Expression()
		}
		p.SetState(959)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 115, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(955)
					p.Match(SqlBaseParserT__3)
				}
				{
					p.SetState(956)
					p.Expression()
				}

			}
			p.SetState(961)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 115, p.GetParserRuleContext())
		}

	case SqlBaseParserT__1:
		localctx = NewSubqueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(962)
			p.Match(SqlBaseParserT__1)
		}
		{
			p.SetState(963)
			p.QueryNoWith()
		}
		{
			p.SetState(964)
			p.Match(SqlBaseParserT__2)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISortItemContext is an interface to support dynamic dispatch.
type ISortItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOrdering returns the ordering token.
	GetOrdering() antlr.Token

	// GetNullOrdering returns the nullOrdering token.
	GetNullOrdering() antlr.Token

	// SetOrdering sets the ordering token.
	SetOrdering(antlr.Token)

	// SetNullOrdering sets the nullOrdering token.
	SetNullOrdering(antlr.Token)

	// IsSortItemContext differentiates from other interfaces.
	IsSortItemContext()
}

type SortItemContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	ordering     antlr.Token
	nullOrdering antlr.Token
}

func NewEmptySortItemContext() *SortItemContext {
	var p = new(SortItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_sortItem
	return p
}

func (*SortItemContext) IsSortItemContext() {}

func NewSortItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortItemContext {
	var p = new(SortItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_sortItem

	return p
}

func (s *SortItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SortItemContext) GetOrdering() antlr.Token { return s.ordering }

func (s *SortItemContext) GetNullOrdering() antlr.Token { return s.nullOrdering }

func (s *SortItemContext) SetOrdering(v antlr.Token) { s.ordering = v }

func (s *SortItemContext) SetNullOrdering(v antlr.Token) { s.nullOrdering = v }

func (s *SortItemContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SortItemContext) NULLS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULLS, 0)
}

func (s *SortItemContext) ASC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserASC, 0)
}

func (s *SortItemContext) DESC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDESC, 0)
}

func (s *SortItemContext) FIRST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFIRST, 0)
}

func (s *SortItemContext) LAST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLAST, 0)
}

func (s *SortItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSortItem(s)
	}
}

func (s *SortItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSortItem(s)
	}
}

func (s *SortItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSortItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) SortItem() (localctx ISortItemContext) {
	localctx = NewSortItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, SqlBaseParserRULE_sortItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(968)
		p.Expression()
	}
	p.SetState(970)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserASC || _la == SqlBaseParserDESC {
		{
			p.SetState(969)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SortItemContext).ordering = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserASC || _la == SqlBaseParserDESC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SortItemContext).ordering = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(974)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserNULLS {
		{
			p.SetState(972)
			p.Match(SqlBaseParserNULLS)
		}
		{
			p.SetState(973)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SortItemContext).nullOrdering = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserFIRST || _la == SqlBaseParserLAST) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SortItemContext).nullOrdering = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IQuerySpecificationContext is an interface to support dynamic dispatch.
type IQuerySpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWhere returns the where rule contexts.
	GetWhere() IBooleanExpressionContext

	// GetHaving returns the having rule contexts.
	GetHaving() IBooleanExpressionContext

	// SetWhere sets the where rule contexts.
	SetWhere(IBooleanExpressionContext)

	// SetHaving sets the having rule contexts.
	SetHaving(IBooleanExpressionContext)

	// IsQuerySpecificationContext differentiates from other interfaces.
	IsQuerySpecificationContext()
}

type QuerySpecificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	where  IBooleanExpressionContext
	having IBooleanExpressionContext
}

func NewEmptyQuerySpecificationContext() *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_querySpecification
	return p
}

func (*QuerySpecificationContext) IsQuerySpecificationContext() {}

func NewQuerySpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_querySpecification

	return p
}

func (s *QuerySpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *QuerySpecificationContext) GetWhere() IBooleanExpressionContext { return s.where }

func (s *QuerySpecificationContext) GetHaving() IBooleanExpressionContext { return s.having }

func (s *QuerySpecificationContext) SetWhere(v IBooleanExpressionContext) { s.where = v }

func (s *QuerySpecificationContext) SetHaving(v IBooleanExpressionContext) { s.having = v }

func (s *QuerySpecificationContext) SELECT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSELECT, 0)
}

func (s *QuerySpecificationContext) AllSelectItem() []ISelectItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISelectItemContext)(nil)).Elem())
	var tst = make([]ISelectItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISelectItemContext)
		}
	}

	return tst
}

func (s *QuerySpecificationContext) SelectItem(i int) ISelectItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISelectItemContext)
}

func (s *QuerySpecificationContext) SetQuantifier() ISetQuantifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetQuantifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *QuerySpecificationContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *QuerySpecificationContext) AllRelation() []IRelationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRelationContext)(nil)).Elem())
	var tst = make([]IRelationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRelationContext)
		}
	}

	return tst
}

func (s *QuerySpecificationContext) Relation(i int) IRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *QuerySpecificationContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWHERE, 0)
}

func (s *QuerySpecificationContext) GROUP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGROUP, 0)
}

func (s *QuerySpecificationContext) BY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBY, 0)
}

func (s *QuerySpecificationContext) GroupBy() IGroupByContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroupByContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroupByContext)
}

func (s *QuerySpecificationContext) HAVING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserHAVING, 0)
}

func (s *QuerySpecificationContext) AllBooleanExpression() []IBooleanExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem())
	var tst = make([]IBooleanExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBooleanExpressionContext)
		}
	}

	return tst
}

func (s *QuerySpecificationContext) BooleanExpression(i int) IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *QuerySpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuerySpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuerySpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterQuerySpecification(s)
	}
}

func (s *QuerySpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitQuerySpecification(s)
	}
}

func (s *QuerySpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitQuerySpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) QuerySpecification() (localctx IQuerySpecificationContext) {
	localctx = NewQuerySpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, SqlBaseParserRULE_querySpecification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(976)
		p.Match(SqlBaseParserSELECT)
	}
	p.SetState(978)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 119, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(977)
			p.SetQuantifier()
		}

	}
	{
		p.SetState(980)
		p.SelectItem()
	}
	p.SetState(985)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 120, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(981)
				p.Match(SqlBaseParserT__3)
			}
			{
				p.SetState(982)
				p.SelectItem()
			}

		}
		p.SetState(987)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 120, p.GetParserRuleContext())
	}
	p.SetState(997)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(988)
			p.Match(SqlBaseParserFROM)
		}
		{
			p.SetState(989)
			p.relation(0)
		}
		p.SetState(994)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 121, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(990)
					p.Match(SqlBaseParserT__3)
				}
				{
					p.SetState(991)
					p.relation(0)
				}

			}
			p.SetState(996)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 121, p.GetParserRuleContext())
		}

	}
	p.SetState(1001)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 123, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(999)
			p.Match(SqlBaseParserWHERE)
		}
		{
			p.SetState(1000)

			var _x = p.booleanExpression(0)

			localctx.(*QuerySpecificationContext).where = _x
		}

	}
	p.SetState(1006)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 124, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1003)
			p.Match(SqlBaseParserGROUP)
		}
		{
			p.SetState(1004)
			p.Match(SqlBaseParserBY)
		}
		{
			p.SetState(1005)
			p.GroupBy()
		}

	}
	p.SetState(1010)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1008)
			p.Match(SqlBaseParserHAVING)
		}
		{
			p.SetState(1009)

			var _x = p.booleanExpression(0)

			localctx.(*QuerySpecificationContext).having = _x
		}

	}

	return localctx
}

// IGroupByContext is an interface to support dynamic dispatch.
type IGroupByContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroupByContext differentiates from other interfaces.
	IsGroupByContext()
}

type GroupByContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupByContext() *GroupByContext {
	var p = new(GroupByContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_groupBy
	return p
}

func (*GroupByContext) IsGroupByContext() {}

func NewGroupByContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByContext {
	var p = new(GroupByContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_groupBy

	return p
}

func (s *GroupByContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByContext) AllGroupingElement() []IGroupingElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGroupingElementContext)(nil)).Elem())
	var tst = make([]IGroupingElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGroupingElementContext)
		}
	}

	return tst
}

func (s *GroupByContext) GroupingElement(i int) IGroupingElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroupingElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGroupingElementContext)
}

func (s *GroupByContext) SetQuantifier() ISetQuantifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetQuantifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *GroupByContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupByContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterGroupBy(s)
	}
}

func (s *GroupByContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitGroupBy(s)
	}
}

func (s *GroupByContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitGroupBy(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) GroupBy() (localctx IGroupByContext) {
	localctx = NewGroupByContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, SqlBaseParserRULE_groupBy)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1013)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 126, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1012)
			p.SetQuantifier()
		}

	}
	{
		p.SetState(1015)
		p.GroupingElement()
	}
	p.SetState(1020)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 127, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1016)
				p.Match(SqlBaseParserT__3)
			}
			{
				p.SetState(1017)
				p.GroupingElement()
			}

		}
		p.SetState(1022)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 127, p.GetParserRuleContext())
	}

	return localctx
}

// IGroupingElementContext is an interface to support dynamic dispatch.
type IGroupingElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroupingElementContext differentiates from other interfaces.
	IsGroupingElementContext()
}

type GroupingElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingElementContext() *GroupingElementContext {
	var p = new(GroupingElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_groupingElement
	return p
}

func (*GroupingElementContext) IsGroupingElementContext() {}

func NewGroupingElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingElementContext {
	var p = new(GroupingElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_groupingElement

	return p
}

func (s *GroupingElementContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingElementContext) CopyFrom(ctx *GroupingElementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *GroupingElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type MultipleGroupingSetsContext struct {
	*GroupingElementContext
}

func NewMultipleGroupingSetsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MultipleGroupingSetsContext {
	var p = new(MultipleGroupingSetsContext)

	p.GroupingElementContext = NewEmptyGroupingElementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*GroupingElementContext))

	return p
}

func (s *MultipleGroupingSetsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipleGroupingSetsContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGROUPING, 0)
}

func (s *MultipleGroupingSetsContext) SETS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSETS, 0)
}

func (s *MultipleGroupingSetsContext) AllGroupingSet() []IGroupingSetContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGroupingSetContext)(nil)).Elem())
	var tst = make([]IGroupingSetContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGroupingSetContext)
		}
	}

	return tst
}

func (s *MultipleGroupingSetsContext) GroupingSet(i int) IGroupingSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroupingSetContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGroupingSetContext)
}

func (s *MultipleGroupingSetsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterMultipleGroupingSets(s)
	}
}

func (s *MultipleGroupingSetsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitMultipleGroupingSets(s)
	}
}

func (s *MultipleGroupingSetsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitMultipleGroupingSets(s)

	default:
		return t.VisitChildren(s)
	}
}

type SingleGroupingSetContext struct {
	*GroupingElementContext
}

func NewSingleGroupingSetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SingleGroupingSetContext {
	var p = new(SingleGroupingSetContext)

	p.GroupingElementContext = NewEmptyGroupingElementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*GroupingElementContext))

	return p
}

func (s *SingleGroupingSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleGroupingSetContext) GroupingSet() IGroupingSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroupingSetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroupingSetContext)
}

func (s *SingleGroupingSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSingleGroupingSet(s)
	}
}

func (s *SingleGroupingSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSingleGroupingSet(s)
	}
}

func (s *SingleGroupingSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSingleGroupingSet(s)

	default:
		return t.VisitChildren(s)
	}
}

type CubeContext struct {
	*GroupingElementContext
}

func NewCubeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CubeContext {
	var p = new(CubeContext)

	p.GroupingElementContext = NewEmptyGroupingElementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*GroupingElementContext))

	return p
}

func (s *CubeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CubeContext) CUBE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCUBE, 0)
}

func (s *CubeContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *CubeContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CubeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCube(s)
	}
}

func (s *CubeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCube(s)
	}
}

func (s *CubeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitCube(s)

	default:
		return t.VisitChildren(s)
	}
}

type RollupContext struct {
	*GroupingElementContext
}

func NewRollupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RollupContext {
	var p = new(RollupContext)

	p.GroupingElementContext = NewEmptyGroupingElementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*GroupingElementContext))

	return p
}

func (s *RollupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollupContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLLUP, 0)
}

func (s *RollupContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *RollupContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RollupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRollup(s)
	}
}

func (s *RollupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRollup(s)
	}
}

func (s *RollupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitRollup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) GroupingElement() (localctx IGroupingElementContext) {
	localctx = NewGroupingElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, SqlBaseParserRULE_groupingElement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1063)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 133, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSingleGroupingSetContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1023)
			p.GroupingSet()
		}

	case 2:
		localctx = NewRollupContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1024)
			p.Match(SqlBaseParserROLLUP)
		}
		{
			p.SetState(1025)
			p.Match(SqlBaseParserT__1)
		}
		p.SetState(1034)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SqlBaseParserT__1)|(1<<SqlBaseParserT__4)|(1<<SqlBaseParserADD)|(1<<SqlBaseParserADMIN)|(1<<SqlBaseParserALL)|(1<<SqlBaseParserANALYZE)|(1<<SqlBaseParserANY)|(1<<SqlBaseParserARRAY)|(1<<SqlBaseParserASC)|(1<<SqlBaseParserAT)|(1<<SqlBaseParserBERNOULLI)|(1<<SqlBaseParserCALL)|(1<<SqlBaseParserCALLED)|(1<<SqlBaseParserCASCADE)|(1<<SqlBaseParserCASE)|(1<<SqlBaseParserCAST)|(1<<SqlBaseParserCATALOGS)|(1<<SqlBaseParserCOLUMN)|(1<<SqlBaseParserCOLUMNS))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(SqlBaseParserCOMMENT-32))|(1<<(SqlBaseParserCOMMIT-32))|(1<<(SqlBaseParserCOMMITTED-32))|(1<<(SqlBaseParserCURRENT-32))|(1<<(SqlBaseParserCURRENT_DATE-32))|(1<<(SqlBaseParserCURRENT_ROLE-32))|(1<<(SqlBaseParserCURRENT_TIME-32))|(1<<(SqlBaseParserCURRENT_TIMESTAMP-32))|(1<<(SqlBaseParserCURRENT_USER-32))|(1<<(SqlBaseParserDATA-32))|(1<<(SqlBaseParserDATE-32))|(1<<(SqlBaseParserDAY-32))|(1<<(SqlBaseParserDEFINER-32))|(1<<(SqlBaseParserDESC-32))|(1<<(SqlBaseParserDETERMINISTIC-32))|(1<<(SqlBaseParserDISTRIBUTED-32))|(1<<(SqlBaseParserEXCLUDING-32))|(1<<(SqlBaseParserEXISTS-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(SqlBaseParserEXPLAIN-64))|(1<<(SqlBaseParserEXTRACT-64))|(1<<(SqlBaseParserEXTERNAL-64))|(1<<(SqlBaseParserFALSE-64))|(1<<(SqlBaseParserFILTER-64))|(1<<(SqlBaseParserFIRST-64))|(1<<(SqlBaseParserFOLLOWING-64))|(1<<(SqlBaseParserFORMAT-64))|(1<<(SqlBaseParserFUNCTION-64))|(1<<(SqlBaseParserFUNCTIONS-64))|(1<<(SqlBaseParserGRANT-64))|(1<<(SqlBaseParserGRANTED-64))|(1<<(SqlBaseParserGRANTS-64))|(1<<(SqlBaseParserGRAPHVIZ-64))|(1<<(SqlBaseParserGROUPING-64))|(1<<(SqlBaseParserHOUR-64))|(1<<(SqlBaseParserIF-64))|(1<<(SqlBaseParserIGNORE-64))|(1<<(SqlBaseParserINCLUDING-64))|(1<<(SqlBaseParserINPUT-64))|(1<<(SqlBaseParserINTERVAL-64))|(1<<(SqlBaseParserINVOKER-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(SqlBaseParserIO-96))|(1<<(SqlBaseParserISOLATION-96))|(1<<(SqlBaseParserJSON-96))|(1<<(SqlBaseParserLANGUAGE-96))|(1<<(SqlBaseParserLAST-96))|(1<<(SqlBaseParserLATERAL-96))|(1<<(SqlBaseParserLEVEL-96))|(1<<(SqlBaseParserLIMIT-96))|(1<<(SqlBaseParserLOCALTIME-96))|(1<<(SqlBaseParserLOCALTIMESTAMP-96))|(1<<(SqlBaseParserLOGICAL-96))|(1<<(SqlBaseParserMAP-96))|(1<<(SqlBaseParserMATERIALIZED-96))|(1<<(SqlBaseParserMINUTE-96))|(1<<(SqlBaseParserMONTH-96))|(1<<(SqlBaseParserNAME-96))|(1<<(SqlBaseParserNFC-96))|(1<<(SqlBaseParserNFD-96))|(1<<(SqlBaseParserNFKC-96))|(1<<(SqlBaseParserNFKD-96))|(1<<(SqlBaseParserNO-96))|(1<<(SqlBaseParserNONE-96))|(1<<(SqlBaseParserNORMALIZE-96))|(1<<(SqlBaseParserNOT-96))|(1<<(SqlBaseParserNULL-96))|(1<<(SqlBaseParserNULLIF-96))|(1<<(SqlBaseParserNULLS-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(SqlBaseParserOFFSET-128))|(1<<(SqlBaseParserONLY-128))|(1<<(SqlBaseParserOPTION-128))|(1<<(SqlBaseParserORDINALITY-128))|(1<<(SqlBaseParserOUTPUT-128))|(1<<(SqlBaseParserOVER-128))|(1<<(SqlBaseParserPARTITION-128))|(1<<(SqlBaseParserPARTITIONS-128))|(1<<(SqlBaseParserPOSITION-128))|(1<<(SqlBaseParserPRECEDING-128))|(1<<(SqlBaseParserPRIVILEGES-128))|(1<<(SqlBaseParserPROPERTIES-128))|(1<<(SqlBaseParserRANGE-128))|(1<<(SqlBaseParserREAD-128))|(1<<(SqlBaseParserREFRESH-128))|(1<<(SqlBaseParserRENAME-128))|(1<<(SqlBaseParserREPEATABLE-128))|(1<<(SqlBaseParserREPLACE-128))|(1<<(SqlBaseParserRESET-128))|(1<<(SqlBaseParserRESPECT-128))|(1<<(SqlBaseParserRESTRICT-128))|(1<<(SqlBaseParserRETURN-128))|(1<<(SqlBaseParserRETURNS-128))|(1<<(SqlBaseParserREVOKE-128))|(1<<(SqlBaseParserROLE-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(SqlBaseParserROLES-160))|(1<<(SqlBaseParserROLLBACK-160))|(1<<(SqlBaseParserROW-160))|(1<<(SqlBaseParserROWS-160))|(1<<(SqlBaseParserSCHEMA-160))|(1<<(SqlBaseParserSCHEMAS-160))|(1<<(SqlBaseParserSECOND-160))|(1<<(SqlBaseParserSECURITY-160))|(1<<(SqlBaseParserSERIALIZABLE-160))|(1<<(SqlBaseParserSESSION-160))|(1<<(SqlBaseParserSET-160))|(1<<(SqlBaseParserSETS-160))|(1<<(SqlBaseParserSHOW-160))|(1<<(SqlBaseParserSOME-160))|(1<<(SqlBaseParserSQL-160))|(1<<(SqlBaseParserSTART-160))|(1<<(SqlBaseParserSTATS-160))|(1<<(SqlBaseParserSUBSTRING-160))|(1<<(SqlBaseParserSYSTEM-160))|(1<<(SqlBaseParserTABLES-160))|(1<<(SqlBaseParserTABLESAMPLE-160))|(1<<(SqlBaseParserTEMPORARY-160))|(1<<(SqlBaseParserTEXT-160))|(1<<(SqlBaseParserTIME-160))|(1<<(SqlBaseParserTIMESTAMP-160))|(1<<(SqlBaseParserTO-160))|(1<<(SqlBaseParserTRANSACTION-160))|(1<<(SqlBaseParserTRUE-160)))) != 0) || (((_la-192)&-(0x1f+1)) == 0 && ((1<<uint((_la-192)))&((1<<(SqlBaseParserTRY_CAST-192))|(1<<(SqlBaseParserTYPE-192))|(1<<(SqlBaseParserUNBOUNDED-192))|(1<<(SqlBaseParserUNCOMMITTED-192))|(1<<(SqlBaseParserUSE-192))|(1<<(SqlBaseParserUSER-192))|(1<<(SqlBaseParserVALIDATE-192))|(1<<(SqlBaseParserVERBOSE-192))|(1<<(SqlBaseParserVIEW-192))|(1<<(SqlBaseParserWORK-192))|(1<<(SqlBaseParserWRITE-192))|(1<<(SqlBaseParserYEAR-192))|(1<<(SqlBaseParserZONE-192))|(1<<(SqlBaseParserPLUS-192))|(1<<(SqlBaseParserMINUS-192)))) != 0) || (((_la-225)&-(0x1f+1)) == 0 && ((1<<uint((_la-225)))&((1<<(SqlBaseParserSTRING-225))|(1<<(SqlBaseParserUNICODE_STRING-225))|(1<<(SqlBaseParserBINARY_LITERAL-225))|(1<<(SqlBaseParserINTEGER_VALUE-225))|(1<<(SqlBaseParserDECIMAL_VALUE-225))|(1<<(SqlBaseParserDOUBLE_VALUE-225))|(1<<(SqlBaseParserIDENTIFIER-225))|(1<<(SqlBaseParserDIGIT_IDENTIFIER-225))|(1<<(SqlBaseParserQUOTED_IDENTIFIER-225))|(1<<(SqlBaseParserBACKQUOTED_IDENTIFIER-225))|(1<<(SqlBaseParserDOUBLE_PRECISION-225)))) != 0) {
			{
				p.SetState(1026)
				p.Expression()
			}
			p.SetState(1031)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__3 {
				{
					p.SetState(1027)
					p.Match(SqlBaseParserT__3)
				}
				{
					p.SetState(1028)
					p.Expression()
				}

				p.SetState(1033)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(1036)
			p.Match(SqlBaseParserT__2)
		}

	case 3:
		localctx = NewCubeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1037)
			p.Match(SqlBaseParserCUBE)
		}
		{
			p.SetState(1038)
			p.Match(SqlBaseParserT__1)
		}
		p.SetState(1047)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SqlBaseParserT__1)|(1<<SqlBaseParserT__4)|(1<<SqlBaseParserADD)|(1<<SqlBaseParserADMIN)|(1<<SqlBaseParserALL)|(1<<SqlBaseParserANALYZE)|(1<<SqlBaseParserANY)|(1<<SqlBaseParserARRAY)|(1<<SqlBaseParserASC)|(1<<SqlBaseParserAT)|(1<<SqlBaseParserBERNOULLI)|(1<<SqlBaseParserCALL)|(1<<SqlBaseParserCALLED)|(1<<SqlBaseParserCASCADE)|(1<<SqlBaseParserCASE)|(1<<SqlBaseParserCAST)|(1<<SqlBaseParserCATALOGS)|(1<<SqlBaseParserCOLUMN)|(1<<SqlBaseParserCOLUMNS))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(SqlBaseParserCOMMENT-32))|(1<<(SqlBaseParserCOMMIT-32))|(1<<(SqlBaseParserCOMMITTED-32))|(1<<(SqlBaseParserCURRENT-32))|(1<<(SqlBaseParserCURRENT_DATE-32))|(1<<(SqlBaseParserCURRENT_ROLE-32))|(1<<(SqlBaseParserCURRENT_TIME-32))|(1<<(SqlBaseParserCURRENT_TIMESTAMP-32))|(1<<(SqlBaseParserCURRENT_USER-32))|(1<<(SqlBaseParserDATA-32))|(1<<(SqlBaseParserDATE-32))|(1<<(SqlBaseParserDAY-32))|(1<<(SqlBaseParserDEFINER-32))|(1<<(SqlBaseParserDESC-32))|(1<<(SqlBaseParserDETERMINISTIC-32))|(1<<(SqlBaseParserDISTRIBUTED-32))|(1<<(SqlBaseParserEXCLUDING-32))|(1<<(SqlBaseParserEXISTS-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(SqlBaseParserEXPLAIN-64))|(1<<(SqlBaseParserEXTRACT-64))|(1<<(SqlBaseParserEXTERNAL-64))|(1<<(SqlBaseParserFALSE-64))|(1<<(SqlBaseParserFILTER-64))|(1<<(SqlBaseParserFIRST-64))|(1<<(SqlBaseParserFOLLOWING-64))|(1<<(SqlBaseParserFORMAT-64))|(1<<(SqlBaseParserFUNCTION-64))|(1<<(SqlBaseParserFUNCTIONS-64))|(1<<(SqlBaseParserGRANT-64))|(1<<(SqlBaseParserGRANTED-64))|(1<<(SqlBaseParserGRANTS-64))|(1<<(SqlBaseParserGRAPHVIZ-64))|(1<<(SqlBaseParserGROUPING-64))|(1<<(SqlBaseParserHOUR-64))|(1<<(SqlBaseParserIF-64))|(1<<(SqlBaseParserIGNORE-64))|(1<<(SqlBaseParserINCLUDING-64))|(1<<(SqlBaseParserINPUT-64))|(1<<(SqlBaseParserINTERVAL-64))|(1<<(SqlBaseParserINVOKER-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(SqlBaseParserIO-96))|(1<<(SqlBaseParserISOLATION-96))|(1<<(SqlBaseParserJSON-96))|(1<<(SqlBaseParserLANGUAGE-96))|(1<<(SqlBaseParserLAST-96))|(1<<(SqlBaseParserLATERAL-96))|(1<<(SqlBaseParserLEVEL-96))|(1<<(SqlBaseParserLIMIT-96))|(1<<(SqlBaseParserLOCALTIME-96))|(1<<(SqlBaseParserLOCALTIMESTAMP-96))|(1<<(SqlBaseParserLOGICAL-96))|(1<<(SqlBaseParserMAP-96))|(1<<(SqlBaseParserMATERIALIZED-96))|(1<<(SqlBaseParserMINUTE-96))|(1<<(SqlBaseParserMONTH-96))|(1<<(SqlBaseParserNAME-96))|(1<<(SqlBaseParserNFC-96))|(1<<(SqlBaseParserNFD-96))|(1<<(SqlBaseParserNFKC-96))|(1<<(SqlBaseParserNFKD-96))|(1<<(SqlBaseParserNO-96))|(1<<(SqlBaseParserNONE-96))|(1<<(SqlBaseParserNORMALIZE-96))|(1<<(SqlBaseParserNOT-96))|(1<<(SqlBaseParserNULL-96))|(1<<(SqlBaseParserNULLIF-96))|(1<<(SqlBaseParserNULLS-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(SqlBaseParserOFFSET-128))|(1<<(SqlBaseParserONLY-128))|(1<<(SqlBaseParserOPTION-128))|(1<<(SqlBaseParserORDINALITY-128))|(1<<(SqlBaseParserOUTPUT-128))|(1<<(SqlBaseParserOVER-128))|(1<<(SqlBaseParserPARTITION-128))|(1<<(SqlBaseParserPARTITIONS-128))|(1<<(SqlBaseParserPOSITION-128))|(1<<(SqlBaseParserPRECEDING-128))|(1<<(SqlBaseParserPRIVILEGES-128))|(1<<(SqlBaseParserPROPERTIES-128))|(1<<(SqlBaseParserRANGE-128))|(1<<(SqlBaseParserREAD-128))|(1<<(SqlBaseParserREFRESH-128))|(1<<(SqlBaseParserRENAME-128))|(1<<(SqlBaseParserREPEATABLE-128))|(1<<(SqlBaseParserREPLACE-128))|(1<<(SqlBaseParserRESET-128))|(1<<(SqlBaseParserRESPECT-128))|(1<<(SqlBaseParserRESTRICT-128))|(1<<(SqlBaseParserRETURN-128))|(1<<(SqlBaseParserRETURNS-128))|(1<<(SqlBaseParserREVOKE-128))|(1<<(SqlBaseParserROLE-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(SqlBaseParserROLES-160))|(1<<(SqlBaseParserROLLBACK-160))|(1<<(SqlBaseParserROW-160))|(1<<(SqlBaseParserROWS-160))|(1<<(SqlBaseParserSCHEMA-160))|(1<<(SqlBaseParserSCHEMAS-160))|(1<<(SqlBaseParserSECOND-160))|(1<<(SqlBaseParserSECURITY-160))|(1<<(SqlBaseParserSERIALIZABLE-160))|(1<<(SqlBaseParserSESSION-160))|(1<<(SqlBaseParserSET-160))|(1<<(SqlBaseParserSETS-160))|(1<<(SqlBaseParserSHOW-160))|(1<<(SqlBaseParserSOME-160))|(1<<(SqlBaseParserSQL-160))|(1<<(SqlBaseParserSTART-160))|(1<<(SqlBaseParserSTATS-160))|(1<<(SqlBaseParserSUBSTRING-160))|(1<<(SqlBaseParserSYSTEM-160))|(1<<(SqlBaseParserTABLES-160))|(1<<(SqlBaseParserTABLESAMPLE-160))|(1<<(SqlBaseParserTEMPORARY-160))|(1<<(SqlBaseParserTEXT-160))|(1<<(SqlBaseParserTIME-160))|(1<<(SqlBaseParserTIMESTAMP-160))|(1<<(SqlBaseParserTO-160))|(1<<(SqlBaseParserTRANSACTION-160))|(1<<(SqlBaseParserTRUE-160)))) != 0) || (((_la-192)&-(0x1f+1)) == 0 && ((1<<uint((_la-192)))&((1<<(SqlBaseParserTRY_CAST-192))|(1<<(SqlBaseParserTYPE-192))|(1<<(SqlBaseParserUNBOUNDED-192))|(1<<(SqlBaseParserUNCOMMITTED-192))|(1<<(SqlBaseParserUSE-192))|(1<<(SqlBaseParserUSER-192))|(1<<(SqlBaseParserVALIDATE-192))|(1<<(SqlBaseParserVERBOSE-192))|(1<<(SqlBaseParserVIEW-192))|(1<<(SqlBaseParserWORK-192))|(1<<(SqlBaseParserWRITE-192))|(1<<(SqlBaseParserYEAR-192))|(1<<(SqlBaseParserZONE-192))|(1<<(SqlBaseParserPLUS-192))|(1<<(SqlBaseParserMINUS-192)))) != 0) || (((_la-225)&-(0x1f+1)) == 0 && ((1<<uint((_la-225)))&((1<<(SqlBaseParserSTRING-225))|(1<<(SqlBaseParserUNICODE_STRING-225))|(1<<(SqlBaseParserBINARY_LITERAL-225))|(1<<(SqlBaseParserINTEGER_VALUE-225))|(1<<(SqlBaseParserDECIMAL_VALUE-225))|(1<<(SqlBaseParserDOUBLE_VALUE-225))|(1<<(SqlBaseParserIDENTIFIER-225))|(1<<(SqlBaseParserDIGIT_IDENTIFIER-225))|(1<<(SqlBaseParserQUOTED_IDENTIFIER-225))|(1<<(SqlBaseParserBACKQUOTED_IDENTIFIER-225))|(1<<(SqlBaseParserDOUBLE_PRECISION-225)))) != 0) {
			{
				p.SetState(1039)
				p.Expression()
			}
			p.SetState(1044)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__3 {
				{
					p.SetState(1040)
					p.Match(SqlBaseParserT__3)
				}
				{
					p.SetState(1041)
					p.Expression()
				}

				p.SetState(1046)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(1049)
			p.Match(SqlBaseParserT__2)
		}

	case 4:
		localctx = NewMultipleGroupingSetsContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1050)
			p.Match(SqlBaseParserGROUPING)
		}
		{
			p.SetState(1051)
			p.Match(SqlBaseParserSETS)
		}
		{
			p.SetState(1052)
			p.Match(SqlBaseParserT__1)
		}
		{
			p.SetState(1053)
			p.GroupingSet()
		}
		p.SetState(1058)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__3 {
			{
				p.SetState(1054)
				p.Match(SqlBaseParserT__3)
			}
			{
				p.SetState(1055)
				p.GroupingSet()
			}

			p.SetState(1060)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1061)
			p.Match(SqlBaseParserT__2)
		}

	}

	return localctx
}

// IGroupingSetContext is an interface to support dynamic dispatch.
type IGroupingSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroupingSetContext differentiates from other interfaces.
	IsGroupingSetContext()
}

type GroupingSetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingSetContext() *GroupingSetContext {
	var p = new(GroupingSetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_groupingSet
	return p
}

func (*GroupingSetContext) IsGroupingSetContext() {}

func NewGroupingSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingSetContext {
	var p = new(GroupingSetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_groupingSet

	return p
}

func (s *GroupingSetContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingSetContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *GroupingSetContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GroupingSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupingSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterGroupingSet(s)
	}
}

func (s *GroupingSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitGroupingSet(s)
	}
}

func (s *GroupingSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitGroupingSet(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) GroupingSet() (localctx IGroupingSetContext) {
	localctx = NewGroupingSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, SqlBaseParserRULE_groupingSet)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1078)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1065)
			p.Match(SqlBaseParserT__1)
		}
		p.SetState(1074)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SqlBaseParserT__1)|(1<<SqlBaseParserT__4)|(1<<SqlBaseParserADD)|(1<<SqlBaseParserADMIN)|(1<<SqlBaseParserALL)|(1<<SqlBaseParserANALYZE)|(1<<SqlBaseParserANY)|(1<<SqlBaseParserARRAY)|(1<<SqlBaseParserASC)|(1<<SqlBaseParserAT)|(1<<SqlBaseParserBERNOULLI)|(1<<SqlBaseParserCALL)|(1<<SqlBaseParserCALLED)|(1<<SqlBaseParserCASCADE)|(1<<SqlBaseParserCASE)|(1<<SqlBaseParserCAST)|(1<<SqlBaseParserCATALOGS)|(1<<SqlBaseParserCOLUMN)|(1<<SqlBaseParserCOLUMNS))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(SqlBaseParserCOMMENT-32))|(1<<(SqlBaseParserCOMMIT-32))|(1<<(SqlBaseParserCOMMITTED-32))|(1<<(SqlBaseParserCURRENT-32))|(1<<(SqlBaseParserCURRENT_DATE-32))|(1<<(SqlBaseParserCURRENT_ROLE-32))|(1<<(SqlBaseParserCURRENT_TIME-32))|(1<<(SqlBaseParserCURRENT_TIMESTAMP-32))|(1<<(SqlBaseParserCURRENT_USER-32))|(1<<(SqlBaseParserDATA-32))|(1<<(SqlBaseParserDATE-32))|(1<<(SqlBaseParserDAY-32))|(1<<(SqlBaseParserDEFINER-32))|(1<<(SqlBaseParserDESC-32))|(1<<(SqlBaseParserDETERMINISTIC-32))|(1<<(SqlBaseParserDISTRIBUTED-32))|(1<<(SqlBaseParserEXCLUDING-32))|(1<<(SqlBaseParserEXISTS-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(SqlBaseParserEXPLAIN-64))|(1<<(SqlBaseParserEXTRACT-64))|(1<<(SqlBaseParserEXTERNAL-64))|(1<<(SqlBaseParserFALSE-64))|(1<<(SqlBaseParserFILTER-64))|(1<<(SqlBaseParserFIRST-64))|(1<<(SqlBaseParserFOLLOWING-64))|(1<<(SqlBaseParserFORMAT-64))|(1<<(SqlBaseParserFUNCTION-64))|(1<<(SqlBaseParserFUNCTIONS-64))|(1<<(SqlBaseParserGRANT-64))|(1<<(SqlBaseParserGRANTED-64))|(1<<(SqlBaseParserGRANTS-64))|(1<<(SqlBaseParserGRAPHVIZ-64))|(1<<(SqlBaseParserGROUPING-64))|(1<<(SqlBaseParserHOUR-64))|(1<<(SqlBaseParserIF-64))|(1<<(SqlBaseParserIGNORE-64))|(1<<(SqlBaseParserINCLUDING-64))|(1<<(SqlBaseParserINPUT-64))|(1<<(SqlBaseParserINTERVAL-64))|(1<<(SqlBaseParserINVOKER-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(SqlBaseParserIO-96))|(1<<(SqlBaseParserISOLATION-96))|(1<<(SqlBaseParserJSON-96))|(1<<(SqlBaseParserLANGUAGE-96))|(1<<(SqlBaseParserLAST-96))|(1<<(SqlBaseParserLATERAL-96))|(1<<(SqlBaseParserLEVEL-96))|(1<<(SqlBaseParserLIMIT-96))|(1<<(SqlBaseParserLOCALTIME-96))|(1<<(SqlBaseParserLOCALTIMESTAMP-96))|(1<<(SqlBaseParserLOGICAL-96))|(1<<(SqlBaseParserMAP-96))|(1<<(SqlBaseParserMATERIALIZED-96))|(1<<(SqlBaseParserMINUTE-96))|(1<<(SqlBaseParserMONTH-96))|(1<<(SqlBaseParserNAME-96))|(1<<(SqlBaseParserNFC-96))|(1<<(SqlBaseParserNFD-96))|(1<<(SqlBaseParserNFKC-96))|(1<<(SqlBaseParserNFKD-96))|(1<<(SqlBaseParserNO-96))|(1<<(SqlBaseParserNONE-96))|(1<<(SqlBaseParserNORMALIZE-96))|(1<<(SqlBaseParserNOT-96))|(1<<(SqlBaseParserNULL-96))|(1<<(SqlBaseParserNULLIF-96))|(1<<(SqlBaseParserNULLS-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(SqlBaseParserOFFSET-128))|(1<<(SqlBaseParserONLY-128))|(1<<(SqlBaseParserOPTION-128))|(1<<(SqlBaseParserORDINALITY-128))|(1<<(SqlBaseParserOUTPUT-128))|(1<<(SqlBaseParserOVER-128))|(1<<(SqlBaseParserPARTITION-128))|(1<<(SqlBaseParserPARTITIONS-128))|(1<<(SqlBaseParserPOSITION-128))|(1<<(SqlBaseParserPRECEDING-128))|(1<<(SqlBaseParserPRIVILEGES-128))|(1<<(SqlBaseParserPROPERTIES-128))|(1<<(SqlBaseParserRANGE-128))|(1<<(SqlBaseParserREAD-128))|(1<<(SqlBaseParserREFRESH-128))|(1<<(SqlBaseParserRENAME-128))|(1<<(SqlBaseParserREPEATABLE-128))|(1<<(SqlBaseParserREPLACE-128))|(1<<(SqlBaseParserRESET-128))|(1<<(SqlBaseParserRESPECT-128))|(1<<(SqlBaseParserRESTRICT-128))|(1<<(SqlBaseParserRETURN-128))|(1<<(SqlBaseParserRETURNS-128))|(1<<(SqlBaseParserREVOKE-128))|(1<<(SqlBaseParserROLE-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(SqlBaseParserROLES-160))|(1<<(SqlBaseParserROLLBACK-160))|(1<<(SqlBaseParserROW-160))|(1<<(SqlBaseParserROWS-160))|(1<<(SqlBaseParserSCHEMA-160))|(1<<(SqlBaseParserSCHEMAS-160))|(1<<(SqlBaseParserSECOND-160))|(1<<(SqlBaseParserSECURITY-160))|(1<<(SqlBaseParserSERIALIZABLE-160))|(1<<(SqlBaseParserSESSION-160))|(1<<(SqlBaseParserSET-160))|(1<<(SqlBaseParserSETS-160))|(1<<(SqlBaseParserSHOW-160))|(1<<(SqlBaseParserSOME-160))|(1<<(SqlBaseParserSQL-160))|(1<<(SqlBaseParserSTART-160))|(1<<(SqlBaseParserSTATS-160))|(1<<(SqlBaseParserSUBSTRING-160))|(1<<(SqlBaseParserSYSTEM-160))|(1<<(SqlBaseParserTABLES-160))|(1<<(SqlBaseParserTABLESAMPLE-160))|(1<<(SqlBaseParserTEMPORARY-160))|(1<<(SqlBaseParserTEXT-160))|(1<<(SqlBaseParserTIME-160))|(1<<(SqlBaseParserTIMESTAMP-160))|(1<<(SqlBaseParserTO-160))|(1<<(SqlBaseParserTRANSACTION-160))|(1<<(SqlBaseParserTRUE-160)))) != 0) || (((_la-192)&-(0x1f+1)) == 0 && ((1<<uint((_la-192)))&((1<<(SqlBaseParserTRY_CAST-192))|(1<<(SqlBaseParserTYPE-192))|(1<<(SqlBaseParserUNBOUNDED-192))|(1<<(SqlBaseParserUNCOMMITTED-192))|(1<<(SqlBaseParserUSE-192))|(1<<(SqlBaseParserUSER-192))|(1<<(SqlBaseParserVALIDATE-192))|(1<<(SqlBaseParserVERBOSE-192))|(1<<(SqlBaseParserVIEW-192))|(1<<(SqlBaseParserWORK-192))|(1<<(SqlBaseParserWRITE-192))|(1<<(SqlBaseParserYEAR-192))|(1<<(SqlBaseParserZONE-192))|(1<<(SqlBaseParserPLUS-192))|(1<<(SqlBaseParserMINUS-192)))) != 0) || (((_la-225)&-(0x1f+1)) == 0 && ((1<<uint((_la-225)))&((1<<(SqlBaseParserSTRING-225))|(1<<(SqlBaseParserUNICODE_STRING-225))|(1<<(SqlBaseParserBINARY_LITERAL-225))|(1<<(SqlBaseParserINTEGER_VALUE-225))|(1<<(SqlBaseParserDECIMAL_VALUE-225))|(1<<(SqlBaseParserDOUBLE_VALUE-225))|(1<<(SqlBaseParserIDENTIFIER-225))|(1<<(SqlBaseParserDIGIT_IDENTIFIER-225))|(1<<(SqlBaseParserQUOTED_IDENTIFIER-225))|(1<<(SqlBaseParserBACKQUOTED_IDENTIFIER-225))|(1<<(SqlBaseParserDOUBLE_PRECISION-225)))) != 0) {
			{
				p.SetState(1066)
				p.Expression()
			}
			p.SetState(1071)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__3 {
				{
					p.SetState(1067)
					p.Match(SqlBaseParserT__3)
				}
				{
					p.SetState(1068)
					p.Expression()
				}

				p.SetState(1073)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(1076)
			p.Match(SqlBaseParserT__2)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1077)
			p.Expression()
		}

	}

	return localctx
}

// INamedQueryContext is an interface to support dynamic dispatch.
type INamedQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// IsNamedQueryContext differentiates from other interfaces.
	IsNamedQueryContext()
}

type NamedQueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentifierContext
}

func NewEmptyNamedQueryContext() *NamedQueryContext {
	var p = new(NamedQueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_namedQuery
	return p
}

func (*NamedQueryContext) IsNamedQueryContext() {}

func NewNamedQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedQueryContext {
	var p = new(NamedQueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_namedQuery

	return p
}

func (s *NamedQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedQueryContext) GetName() IIdentifierContext { return s.name }

func (s *NamedQueryContext) SetName(v IIdentifierContext) { s.name = v }

func (s *NamedQueryContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *NamedQueryContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *NamedQueryContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NamedQueryContext) ColumnAliases() IColumnAliasesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnAliasesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *NamedQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterNamedQuery(s)
	}
}

func (s *NamedQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitNamedQuery(s)
	}
}

func (s *NamedQueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitNamedQuery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) NamedQuery() (localctx INamedQueryContext) {
	localctx = NewNamedQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, SqlBaseParserRULE_namedQuery)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1080)

		var _x = p.Identifier()

		localctx.(*NamedQueryContext).name = _x
	}
	p.SetState(1082)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserT__1 {
		{
			p.SetState(1081)
			p.ColumnAliases()
		}

	}
	{
		p.SetState(1084)
		p.Match(SqlBaseParserAS)
	}
	{
		p.SetState(1085)
		p.Match(SqlBaseParserT__1)
	}
	{
		p.SetState(1086)
		p.Query()
	}
	{
		p.SetState(1087)
		p.Match(SqlBaseParserT__2)
	}

	return localctx
}

// ISetQuantifierContext is an interface to support dynamic dispatch.
type ISetQuantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetQuantifierContext differentiates from other interfaces.
	IsSetQuantifierContext()
}

type SetQuantifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetQuantifierContext() *SetQuantifierContext {
	var p = new(SetQuantifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_setQuantifier
	return p
}

func (*SetQuantifierContext) IsSetQuantifierContext() {}

func NewSetQuantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetQuantifierContext {
	var p = new(SetQuantifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_setQuantifier

	return p
}

func (s *SetQuantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *SetQuantifierContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDISTINCT, 0)
}

func (s *SetQuantifierContext) ALL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALL, 0)
}

func (s *SetQuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetQuantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetQuantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSetQuantifier(s)
	}
}

func (s *SetQuantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSetQuantifier(s)
	}
}

func (s *SetQuantifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSetQuantifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) SetQuantifier() (localctx ISetQuantifierContext) {
	localctx = NewSetQuantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, SqlBaseParserRULE_setQuantifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1089)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBaseParserALL || _la == SqlBaseParserDISTINCT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISelectItemContext is an interface to support dynamic dispatch.
type ISelectItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectItemContext differentiates from other interfaces.
	IsSelectItemContext()
}

type SelectItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectItemContext() *SelectItemContext {
	var p = new(SelectItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_selectItem
	return p
}

func (*SelectItemContext) IsSelectItemContext() {}

func NewSelectItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectItemContext {
	var p = new(SelectItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_selectItem

	return p
}

func (s *SelectItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectItemContext) CopyFrom(ctx *SelectItemContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *SelectItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SelectAllContext struct {
	*SelectItemContext
}

func NewSelectAllContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectAllContext {
	var p = new(SelectAllContext)

	p.SelectItemContext = NewEmptySelectItemContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectItemContext))

	return p
}

func (s *SelectAllContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectAllContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *SelectAllContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserASTERISK, 0)
}

func (s *SelectAllContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSelectAll(s)
	}
}

func (s *SelectAllContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSelectAll(s)
	}
}

func (s *SelectAllContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSelectAll(s)

	default:
		return t.VisitChildren(s)
	}
}

type SelectSingleContext struct {
	*SelectItemContext
}

func NewSelectSingleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectSingleContext {
	var p = new(SelectSingleContext)

	p.SelectItemContext = NewEmptySelectItemContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectItemContext))

	return p
}

func (s *SelectSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectSingleContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SelectSingleContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SelectSingleContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *SelectSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSelectSingle(s)
	}
}

func (s *SelectSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSelectSingle(s)
	}
}

func (s *SelectSingleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSelectSingle(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) SelectItem() (localctx ISelectItemContext) {
	localctx = NewSelectItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, SqlBaseParserRULE_selectItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1103)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 140, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSelectSingleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1091)
			p.Expression()
		}
		p.SetState(1096)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext()) == 1 {
			p.SetState(1093)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBaseParserAS {
				{
					p.SetState(1092)
					p.Match(SqlBaseParserAS)
				}

			}
			{
				p.SetState(1095)
				p.Identifier()
			}

		}

	case 2:
		localctx = NewSelectAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1098)
			p.QualifiedName()
		}
		{
			p.SetState(1099)
			p.Match(SqlBaseParserT__0)
		}
		{
			p.SetState(1100)
			p.Match(SqlBaseParserASTERISK)
		}

	case 3:
		localctx = NewSelectAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1102)
			p.Match(SqlBaseParserASTERISK)
		}

	}

	return localctx
}

// IRelationContext is an interface to support dynamic dispatch.
type IRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationContext differentiates from other interfaces.
	IsRelationContext()
}

type RelationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationContext() *RelationContext {
	var p = new(RelationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_relation
	return p
}

func (*RelationContext) IsRelationContext() {}

func NewRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationContext {
	var p = new(RelationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_relation

	return p
}

func (s *RelationContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationContext) CopyFrom(ctx *RelationContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *RelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RelationDefaultContext struct {
	*RelationContext
}

func NewRelationDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RelationDefaultContext {
	var p = new(RelationDefaultContext)

	p.RelationContext = NewEmptyRelationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationContext))

	return p
}

func (s *RelationDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationDefaultContext) SampledRelation() ISampledRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISampledRelationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISampledRelationContext)
}

func (s *RelationDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRelationDefault(s)
	}
}

func (s *RelationDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRelationDefault(s)
	}
}

func (s *RelationDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitRelationDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type JoinRelationContext struct {
	*RelationContext
	left          IRelationContext
	right         ISampledRelationContext
	rightRelation IRelationContext
}

func NewJoinRelationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JoinRelationContext {
	var p = new(JoinRelationContext)

	p.RelationContext = NewEmptyRelationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationContext))

	return p
}

func (s *JoinRelationContext) GetLeft() IRelationContext { return s.left }

func (s *JoinRelationContext) GetRight() ISampledRelationContext { return s.right }

func (s *JoinRelationContext) GetRightRelation() IRelationContext { return s.rightRelation }

func (s *JoinRelationContext) SetLeft(v IRelationContext) { s.left = v }

func (s *JoinRelationContext) SetRight(v ISampledRelationContext) { s.right = v }

func (s *JoinRelationContext) SetRightRelation(v IRelationContext) { s.rightRelation = v }

func (s *JoinRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinRelationContext) AllRelation() []IRelationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRelationContext)(nil)).Elem())
	var tst = make([]IRelationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRelationContext)
		}
	}

	return tst
}

func (s *JoinRelationContext) Relation(i int) IRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *JoinRelationContext) CROSS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCROSS, 0)
}

func (s *JoinRelationContext) JOIN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserJOIN, 0)
}

func (s *JoinRelationContext) JoinType() IJoinTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoinTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJoinTypeContext)
}

func (s *JoinRelationContext) JoinCriteria() IJoinCriteriaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoinCriteriaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJoinCriteriaContext)
}

func (s *JoinRelationContext) NATURAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNATURAL, 0)
}

func (s *JoinRelationContext) SampledRelation() ISampledRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISampledRelationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISampledRelationContext)
}

func (s *JoinRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterJoinRelation(s)
	}
}

func (s *JoinRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitJoinRelation(s)
	}
}

func (s *JoinRelationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitJoinRelation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) Relation() (localctx IRelationContext) {
	return p.relation(0)
}

func (p *SqlBaseParser) relation(_p int) (localctx IRelationContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRelationContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRelationContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 68
	p.EnterRecursionRule(localctx, 68, SqlBaseParserRULE_relation, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewRelationDefaultContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(1106)
		p.SampledRelation()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1126)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 142, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewJoinRelationContext(p, NewRelationContext(p, _parentctx, _parentState))
			localctx.(*JoinRelationContext).left = _prevctx

			p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_relation)
			p.SetState(1108)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			p.SetState(1122)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case SqlBaseParserCROSS:
				{
					p.SetState(1109)
					p.Match(SqlBaseParserCROSS)
				}
				{
					p.SetState(1110)
					p.Match(SqlBaseParserJOIN)
				}
				{
					p.SetState(1111)

					var _x = p.SampledRelation()

					localctx.(*JoinRelationContext).right = _x
				}

			case SqlBaseParserFULL, SqlBaseParserINNER, SqlBaseParserJOIN, SqlBaseParserLEFT, SqlBaseParserRIGHT:
				{
					p.SetState(1112)
					p.JoinType()
				}
				{
					p.SetState(1113)
					p.Match(SqlBaseParserJOIN)
				}
				{
					p.SetState(1114)

					var _x = p.relation(0)

					localctx.(*JoinRelationContext).rightRelation = _x
				}
				{
					p.SetState(1115)
					p.JoinCriteria()
				}

			case SqlBaseParserNATURAL:
				{
					p.SetState(1117)
					p.Match(SqlBaseParserNATURAL)
				}
				{
					p.SetState(1118)
					p.JoinType()
				}
				{
					p.SetState(1119)
					p.Match(SqlBaseParserJOIN)
				}
				{
					p.SetState(1120)

					var _x = p.SampledRelation()

					localctx.(*JoinRelationContext).right = _x
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(1128)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 142, p.GetParserRuleContext())
	}

	return localctx
}

// IJoinTypeContext is an interface to support dynamic dispatch.
type IJoinTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoinTypeContext differentiates from other interfaces.
	IsJoinTypeContext()
}

type JoinTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinTypeContext() *JoinTypeContext {
	var p = new(JoinTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_joinType
	return p
}

func (*JoinTypeContext) IsJoinTypeContext() {}

func NewJoinTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinTypeContext {
	var p = new(JoinTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_joinType

	return p
}

func (s *JoinTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinTypeContext) INNER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINNER, 0)
}

func (s *JoinTypeContext) LEFT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT, 0)
}

func (s *JoinTypeContext) OUTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOUTER, 0)
}

func (s *JoinTypeContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT, 0)
}

func (s *JoinTypeContext) FULL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFULL, 0)
}

func (s *JoinTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterJoinType(s)
	}
}

func (s *JoinTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitJoinType(s)
	}
}

func (s *JoinTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitJoinType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) JoinType() (localctx IJoinTypeContext) {
	localctx = NewJoinTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, SqlBaseParserRULE_joinType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1144)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserINNER, SqlBaseParserJOIN:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1130)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserINNER {
			{
				p.SetState(1129)
				p.Match(SqlBaseParserINNER)
			}

		}

	case SqlBaseParserLEFT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1132)
			p.Match(SqlBaseParserLEFT)
		}
		p.SetState(1134)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserOUTER {
			{
				p.SetState(1133)
				p.Match(SqlBaseParserOUTER)
			}

		}

	case SqlBaseParserRIGHT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1136)
			p.Match(SqlBaseParserRIGHT)
		}
		p.SetState(1138)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserOUTER {
			{
				p.SetState(1137)
				p.Match(SqlBaseParserOUTER)
			}

		}

	case SqlBaseParserFULL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1140)
			p.Match(SqlBaseParserFULL)
		}
		p.SetState(1142)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserOUTER {
			{
				p.SetState(1141)
				p.Match(SqlBaseParserOUTER)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IJoinCriteriaContext is an interface to support dynamic dispatch.
type IJoinCriteriaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoinCriteriaContext differentiates from other interfaces.
	IsJoinCriteriaContext()
}

type JoinCriteriaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinCriteriaContext() *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_joinCriteria
	return p
}

func (*JoinCriteriaContext) IsJoinCriteriaContext() {}

func NewJoinCriteriaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_joinCriteria

	return p
}

func (s *JoinCriteriaContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinCriteriaContext) ON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserON, 0)
}

func (s *JoinCriteriaContext) BooleanExpression() IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *JoinCriteriaContext) USING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUSING, 0)
}

func (s *JoinCriteriaContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *JoinCriteriaContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *JoinCriteriaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinCriteriaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinCriteriaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterJoinCriteria(s)
	}
}

func (s *JoinCriteriaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitJoinCriteria(s)
	}
}

func (s *JoinCriteriaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitJoinCriteria(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) JoinCriteria() (localctx IJoinCriteriaContext) {
	localctx = NewJoinCriteriaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, SqlBaseParserRULE_joinCriteria)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1160)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserON:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1146)
			p.Match(SqlBaseParserON)
		}
		{
			p.SetState(1147)
			p.booleanExpression(0)
		}

	case SqlBaseParserUSING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1148)
			p.Match(SqlBaseParserUSING)
		}
		{
			p.SetState(1149)
			p.Match(SqlBaseParserT__1)
		}
		{
			p.SetState(1150)
			p.Identifier()
		}
		p.SetState(1155)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__3 {
			{
				p.SetState(1151)
				p.Match(SqlBaseParserT__3)
			}
			{
				p.SetState(1152)
				p.Identifier()
			}

			p.SetState(1157)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1158)
			p.Match(SqlBaseParserT__2)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISampledRelationContext is an interface to support dynamic dispatch.
type ISampledRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPercentage returns the percentage rule contexts.
	GetPercentage() IExpressionContext

	// SetPercentage sets the percentage rule contexts.
	SetPercentage(IExpressionContext)

	// IsSampledRelationContext differentiates from other interfaces.
	IsSampledRelationContext()
}

type SampledRelationContext struct {
	*antlr.BaseParserRuleContext
	parser     antlr.Parser
	percentage IExpressionContext
}

func NewEmptySampledRelationContext() *SampledRelationContext {
	var p = new(SampledRelationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_sampledRelation
	return p
}

func (*SampledRelationContext) IsSampledRelationContext() {}

func NewSampledRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SampledRelationContext {
	var p = new(SampledRelationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_sampledRelation

	return p
}

func (s *SampledRelationContext) GetParser() antlr.Parser { return s.parser }

func (s *SampledRelationContext) GetPercentage() IExpressionContext { return s.percentage }

func (s *SampledRelationContext) SetPercentage(v IExpressionContext) { s.percentage = v }

func (s *SampledRelationContext) AliasedRelation() IAliasedRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAliasedRelationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAliasedRelationContext)
}

func (s *SampledRelationContext) TABLESAMPLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLESAMPLE, 0)
}

func (s *SampledRelationContext) SampleType() ISampleTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISampleTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISampleTypeContext)
}

func (s *SampledRelationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SampledRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampledRelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SampledRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSampledRelation(s)
	}
}

func (s *SampledRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSampledRelation(s)
	}
}

func (s *SampledRelationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSampledRelation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) SampledRelation() (localctx ISampledRelationContext) {
	localctx = NewSampledRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, SqlBaseParserRULE_sampledRelation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1162)
		p.AliasedRelation()
	}
	p.SetState(1169)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 150, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1163)
			p.Match(SqlBaseParserTABLESAMPLE)
		}
		{
			p.SetState(1164)
			p.SampleType()
		}
		{
			p.SetState(1165)
			p.Match(SqlBaseParserT__1)
		}
		{
			p.SetState(1166)

			var _x = p.Expression()

			localctx.(*SampledRelationContext).percentage = _x
		}
		{
			p.SetState(1167)
			p.Match(SqlBaseParserT__2)
		}

	}

	return localctx
}

// ISampleTypeContext is an interface to support dynamic dispatch.
type ISampleTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSampleTypeContext differentiates from other interfaces.
	IsSampleTypeContext()
}

type SampleTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySampleTypeContext() *SampleTypeContext {
	var p = new(SampleTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_sampleType
	return p
}

func (*SampleTypeContext) IsSampleTypeContext() {}

func NewSampleTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SampleTypeContext {
	var p = new(SampleTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_sampleType

	return p
}

func (s *SampleTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SampleTypeContext) BERNOULLI() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBERNOULLI, 0)
}

func (s *SampleTypeContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSYSTEM, 0)
}

func (s *SampleTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SampleTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSampleType(s)
	}
}

func (s *SampleTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSampleType(s)
	}
}

func (s *SampleTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSampleType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) SampleType() (localctx ISampleTypeContext) {
	localctx = NewSampleTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, SqlBaseParserRULE_sampleType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1171)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBaseParserBERNOULLI || _la == SqlBaseParserSYSTEM) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAliasedRelationContext is an interface to support dynamic dispatch.
type IAliasedRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAliasedRelationContext differentiates from other interfaces.
	IsAliasedRelationContext()
}

type AliasedRelationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasedRelationContext() *AliasedRelationContext {
	var p = new(AliasedRelationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_aliasedRelation
	return p
}

func (*AliasedRelationContext) IsAliasedRelationContext() {}

func NewAliasedRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasedRelationContext {
	var p = new(AliasedRelationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_aliasedRelation

	return p
}

func (s *AliasedRelationContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasedRelationContext) RelationPrimary() IRelationPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationPrimaryContext)
}

func (s *AliasedRelationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AliasedRelationContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *AliasedRelationContext) ColumnAliases() IColumnAliasesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnAliasesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *AliasedRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasedRelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasedRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterAliasedRelation(s)
	}
}

func (s *AliasedRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitAliasedRelation(s)
	}
}

func (s *AliasedRelationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitAliasedRelation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) AliasedRelation() (localctx IAliasedRelationContext) {
	localctx = NewAliasedRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, SqlBaseParserRULE_aliasedRelation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1173)
		p.RelationPrimary()
	}
	p.SetState(1181)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 153, p.GetParserRuleContext()) == 1 {
		p.SetState(1175)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserAS {
			{
				p.SetState(1174)
				p.Match(SqlBaseParserAS)
			}

		}
		{
			p.SetState(1177)
			p.Identifier()
		}
		p.SetState(1179)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 152, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1178)
				p.ColumnAliases()
			}

		}

	}

	return localctx
}

// IColumnAliasesContext is an interface to support dynamic dispatch.
type IColumnAliasesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumnAliasesContext differentiates from other interfaces.
	IsColumnAliasesContext()
}

type ColumnAliasesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnAliasesContext() *ColumnAliasesContext {
	var p = new(ColumnAliasesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_columnAliases
	return p
}

func (*ColumnAliasesContext) IsColumnAliasesContext() {}

func NewColumnAliasesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnAliasesContext {
	var p = new(ColumnAliasesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_columnAliases

	return p
}

func (s *ColumnAliasesContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnAliasesContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *ColumnAliasesContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnAliasesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnAliasesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnAliasesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterColumnAliases(s)
	}
}

func (s *ColumnAliasesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitColumnAliases(s)
	}
}

func (s *ColumnAliasesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitColumnAliases(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) ColumnAliases() (localctx IColumnAliasesContext) {
	localctx = NewColumnAliasesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, SqlBaseParserRULE_columnAliases)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1183)
		p.Match(SqlBaseParserT__1)
	}
	{
		p.SetState(1184)
		p.Identifier()
	}
	p.SetState(1189)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserT__3 {
		{
			p.SetState(1185)
			p.Match(SqlBaseParserT__3)
		}
		{
			p.SetState(1186)
			p.Identifier()
		}

		p.SetState(1191)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1192)
		p.Match(SqlBaseParserT__2)
	}

	return localctx
}

// IRelationPrimaryContext is an interface to support dynamic dispatch.
type IRelationPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationPrimaryContext differentiates from other interfaces.
	IsRelationPrimaryContext()
}

type RelationPrimaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationPrimaryContext() *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_relationPrimary
	return p
}

func (*RelationPrimaryContext) IsRelationPrimaryContext() {}

func NewRelationPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_relationPrimary

	return p
}

func (s *RelationPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationPrimaryContext) CopyFrom(ctx *RelationPrimaryContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *RelationPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SubqueryRelationContext struct {
	*RelationPrimaryContext
}

func NewSubqueryRelationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryRelationContext {
	var p = new(SubqueryRelationContext)

	p.RelationPrimaryContext = NewEmptyRelationPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationPrimaryContext))

	return p
}

func (s *SubqueryRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryRelationContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *SubqueryRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSubqueryRelation(s)
	}
}

func (s *SubqueryRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSubqueryRelation(s)
	}
}

func (s *SubqueryRelationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSubqueryRelation(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParenthesizedRelationContext struct {
	*RelationPrimaryContext
}

func NewParenthesizedRelationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedRelationContext {
	var p = new(ParenthesizedRelationContext)

	p.RelationPrimaryContext = NewEmptyRelationPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationPrimaryContext))

	return p
}

func (s *ParenthesizedRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedRelationContext) Relation() IRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *ParenthesizedRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterParenthesizedRelation(s)
	}
}

func (s *ParenthesizedRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitParenthesizedRelation(s)
	}
}

func (s *ParenthesizedRelationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitParenthesizedRelation(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnnestContext struct {
	*RelationPrimaryContext
}

func NewUnnestContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnnestContext {
	var p = new(UnnestContext)

	p.RelationPrimaryContext = NewEmptyRelationPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationPrimaryContext))

	return p
}

func (s *UnnestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnnestContext) UNNEST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNNEST, 0)
}

func (s *UnnestContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *UnnestContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UnnestContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *UnnestContext) ORDINALITY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserORDINALITY, 0)
}

func (s *UnnestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterUnnest(s)
	}
}

func (s *UnnestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitUnnest(s)
	}
}

func (s *UnnestContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitUnnest(s)

	default:
		return t.VisitChildren(s)
	}
}

type LateralContext struct {
	*RelationPrimaryContext
}

func NewLateralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LateralContext {
	var p = new(LateralContext)

	p.RelationPrimaryContext = NewEmptyRelationPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationPrimaryContext))

	return p
}

func (s *LateralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LateralContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLATERAL, 0)
}

func (s *LateralContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *LateralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterLateral(s)
	}
}

func (s *LateralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitLateral(s)
	}
}

func (s *LateralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitLateral(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableNameContext struct {
	*RelationPrimaryContext
}

func NewTableNameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableNameContext {
	var p = new(TableNameContext)

	p.RelationPrimaryContext = NewEmptyRelationPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationPrimaryContext))

	return p
}

func (s *TableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNameContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterTableName(s)
	}
}

func (s *TableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitTableName(s)
	}
}

func (s *TableNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitTableName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) RelationPrimary() (localctx IRelationPrimaryContext) {
	localctx = NewRelationPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, SqlBaseParserRULE_relationPrimary)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1223)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 157, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTableNameContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1194)
			p.QualifiedName()
		}

	case 2:
		localctx = NewSubqueryRelationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1195)
			p.Match(SqlBaseParserT__1)
		}
		{
			p.SetState(1196)
			p.Query()
		}
		{
			p.SetState(1197)
			p.Match(SqlBaseParserT__2)
		}

	case 3:
		localctx = NewUnnestContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1199)
			p.Match(SqlBaseParserUNNEST)
		}
		{
			p.SetState(1200)
			p.Match(SqlBaseParserT__1)
		}
		{
			p.SetState(1201)
			p.Expression()
		}
		p.SetState(1206)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__3 {
			{
				p.SetState(1202)
				p.Match(SqlBaseParserT__3)
			}
			{
				p.SetState(1203)
				p.Expression()
			}

			p.SetState(1208)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1209)
			p.Match(SqlBaseParserT__2)
		}
		p.SetState(1212)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 156, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1210)
				p.Match(SqlBaseParserWITH)
			}
			{
				p.SetState(1211)
				p.Match(SqlBaseParserORDINALITY)
			}

		}

	case 4:
		localctx = NewLateralContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1214)
			p.Match(SqlBaseParserLATERAL)
		}
		{
			p.SetState(1215)
			p.Match(SqlBaseParserT__1)
		}
		{
			p.SetState(1216)
			p.Query()
		}
		{
			p.SetState(1217)
			p.Match(SqlBaseParserT__2)
		}

	case 5:
		localctx = NewParenthesizedRelationContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1219)
			p.Match(SqlBaseParserT__1)
		}
		{
			p.SetState(1220)
			p.relation(0)
		}
		{
			p.SetState(1221)
			p.Match(SqlBaseParserT__2)
		}

	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) BooleanExpression() IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (s *ExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, SqlBaseParserRULE_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1225)
		p.booleanExpression(0)
	}

	return localctx
}

// IBooleanExpressionContext is an interface to support dynamic dispatch.
type IBooleanExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBooleanExpressionContext differentiates from other interfaces.
	IsBooleanExpressionContext()
}

type BooleanExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanExpressionContext() *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_booleanExpression
	return p
}

func (*BooleanExpressionContext) IsBooleanExpressionContext() {}

func NewBooleanExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_booleanExpression

	return p
}

func (s *BooleanExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanExpressionContext) CopyFrom(ctx *BooleanExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *BooleanExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LogicalNotContext struct {
	*BooleanExpressionContext
}

func NewLogicalNotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalNotContext {
	var p = new(LogicalNotContext)

	p.BooleanExpressionContext = NewEmptyBooleanExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*BooleanExpressionContext))

	return p
}

func (s *LogicalNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalNotContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *LogicalNotContext) BooleanExpression() IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LogicalNotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterLogicalNot(s)
	}
}

func (s *LogicalNotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitLogicalNot(s)
	}
}

func (s *LogicalNotContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitLogicalNot(s)

	default:
		return t.VisitChildren(s)
	}
}

type PredicatedContext struct {
	*BooleanExpressionContext
	_valueExpression IValueExpressionContext
}

func NewPredicatedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredicatedContext {
	var p = new(PredicatedContext)

	p.BooleanExpressionContext = NewEmptyBooleanExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*BooleanExpressionContext))

	return p
}

func (s *PredicatedContext) Get_valueExpression() IValueExpressionContext { return s._valueExpression }

func (s *PredicatedContext) Set_valueExpression(v IValueExpressionContext) { s._valueExpression = v }

func (s *PredicatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicatedContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PredicatedContext) Predicate() IPredicateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PredicatedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterPredicated(s)
	}
}

func (s *PredicatedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitPredicated(s)
	}
}

func (s *PredicatedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitPredicated(s)

	default:
		return t.VisitChildren(s)
	}
}

type LogicalBinaryContext struct {
	*BooleanExpressionContext
	left     IBooleanExpressionContext
	operator antlr.Token
	right    IBooleanExpressionContext
}

func NewLogicalBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalBinaryContext {
	var p = new(LogicalBinaryContext)

	p.BooleanExpressionContext = NewEmptyBooleanExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*BooleanExpressionContext))

	return p
}

func (s *LogicalBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *LogicalBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *LogicalBinaryContext) GetLeft() IBooleanExpressionContext { return s.left }

func (s *LogicalBinaryContext) GetRight() IBooleanExpressionContext { return s.right }

func (s *LogicalBinaryContext) SetLeft(v IBooleanExpressionContext) { s.left = v }

func (s *LogicalBinaryContext) SetRight(v IBooleanExpressionContext) { s.right = v }

func (s *LogicalBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalBinaryContext) AllBooleanExpression() []IBooleanExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem())
	var tst = make([]IBooleanExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBooleanExpressionContext)
		}
	}

	return tst
}

func (s *LogicalBinaryContext) BooleanExpression(i int) IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LogicalBinaryContext) AND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAND, 0)
}

func (s *LogicalBinaryContext) OR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOR, 0)
}

func (s *LogicalBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterLogicalBinary(s)
	}
}

func (s *LogicalBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitLogicalBinary(s)
	}
}

func (s *LogicalBinaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitLogicalBinary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) BooleanExpression() (localctx IBooleanExpressionContext) {
	return p.booleanExpression(0)
}

func (p *SqlBaseParser) booleanExpression(_p int) (localctx IBooleanExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewBooleanExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBooleanExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 86
	p.EnterRecursionRule(localctx, 86, SqlBaseParserRULE_booleanExpression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1234)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserT__1, SqlBaseParserT__4, SqlBaseParserADD, SqlBaseParserADMIN, SqlBaseParserALL, SqlBaseParserANALYZE, SqlBaseParserANY, SqlBaseParserARRAY, SqlBaseParserASC, SqlBaseParserAT, SqlBaseParserBERNOULLI, SqlBaseParserCALL, SqlBaseParserCALLED, SqlBaseParserCASCADE, SqlBaseParserCASE, SqlBaseParserCAST, SqlBaseParserCATALOGS, SqlBaseParserCOLUMN, SqlBaseParserCOLUMNS, SqlBaseParserCOMMENT, SqlBaseParserCOMMIT, SqlBaseParserCOMMITTED, SqlBaseParserCURRENT, SqlBaseParserCURRENT_DATE, SqlBaseParserCURRENT_ROLE, SqlBaseParserCURRENT_TIME, SqlBaseParserCURRENT_TIMESTAMP, SqlBaseParserCURRENT_USER, SqlBaseParserDATA, SqlBaseParserDATE, SqlBaseParserDAY, SqlBaseParserDEFINER, SqlBaseParserDESC, SqlBaseParserDETERMINISTIC, SqlBaseParserDISTRIBUTED, SqlBaseParserEXCLUDING, SqlBaseParserEXISTS, SqlBaseParserEXPLAIN, SqlBaseParserEXTRACT, SqlBaseParserEXTERNAL, SqlBaseParserFALSE, SqlBaseParserFILTER, SqlBaseParserFIRST, SqlBaseParserFOLLOWING, SqlBaseParserFORMAT, SqlBaseParserFUNCTION, SqlBaseParserFUNCTIONS, SqlBaseParserGRANT, SqlBaseParserGRANTED, SqlBaseParserGRANTS, SqlBaseParserGRAPHVIZ, SqlBaseParserGROUPING, SqlBaseParserHOUR, SqlBaseParserIF, SqlBaseParserIGNORE, SqlBaseParserINCLUDING, SqlBaseParserINPUT, SqlBaseParserINTERVAL, SqlBaseParserINVOKER, SqlBaseParserIO, SqlBaseParserISOLATION, SqlBaseParserJSON, SqlBaseParserLANGUAGE, SqlBaseParserLAST, SqlBaseParserLATERAL, SqlBaseParserLEVEL, SqlBaseParserLIMIT, SqlBaseParserLOCALTIME, SqlBaseParserLOCALTIMESTAMP, SqlBaseParserLOGICAL, SqlBaseParserMAP, SqlBaseParserMATERIALIZED, SqlBaseParserMINUTE, SqlBaseParserMONTH, SqlBaseParserNAME, SqlBaseParserNFC, SqlBaseParserNFD, SqlBaseParserNFKC, SqlBaseParserNFKD, SqlBaseParserNO, SqlBaseParserNONE, SqlBaseParserNORMALIZE, SqlBaseParserNULL, SqlBaseParserNULLIF, SqlBaseParserNULLS, SqlBaseParserOFFSET, SqlBaseParserONLY, SqlBaseParserOPTION, SqlBaseParserORDINALITY, SqlBaseParserOUTPUT, SqlBaseParserOVER, SqlBaseParserPARTITION, SqlBaseParserPARTITIONS, SqlBaseParserPOSITION, SqlBaseParserPRECEDING, SqlBaseParserPRIVILEGES, SqlBaseParserPROPERTIES, SqlBaseParserRANGE, SqlBaseParserREAD, SqlBaseParserREFRESH, SqlBaseParserRENAME, SqlBaseParserREPEATABLE, SqlBaseParserREPLACE, SqlBaseParserRESET, SqlBaseParserRESPECT, SqlBaseParserRESTRICT, SqlBaseParserRETURN, SqlBaseParserRETURNS, SqlBaseParserREVOKE, SqlBaseParserROLE, SqlBaseParserROLES, SqlBaseParserROLLBACK, SqlBaseParserROW, SqlBaseParserROWS, SqlBaseParserSCHEMA, SqlBaseParserSCHEMAS, SqlBaseParserSECOND, SqlBaseParserSECURITY, SqlBaseParserSERIALIZABLE, SqlBaseParserSESSION, SqlBaseParserSET, SqlBaseParserSETS, SqlBaseParserSHOW, SqlBaseParserSOME, SqlBaseParserSQL, SqlBaseParserSTART, SqlBaseParserSTATS, SqlBaseParserSUBSTRING, SqlBaseParserSYSTEM, SqlBaseParserTABLES, SqlBaseParserTABLESAMPLE, SqlBaseParserTEMPORARY, SqlBaseParserTEXT, SqlBaseParserTIME, SqlBaseParserTIMESTAMP, SqlBaseParserTO, SqlBaseParserTRANSACTION, SqlBaseParserTRUE, SqlBaseParserTRY_CAST, SqlBaseParserTYPE, SqlBaseParserUNBOUNDED, SqlBaseParserUNCOMMITTED, SqlBaseParserUSE, SqlBaseParserUSER, SqlBaseParserVALIDATE, SqlBaseParserVERBOSE, SqlBaseParserVIEW, SqlBaseParserWORK, SqlBaseParserWRITE, SqlBaseParserYEAR, SqlBaseParserZONE, SqlBaseParserPLUS, SqlBaseParserMINUS, SqlBaseParserSTRING, SqlBaseParserUNICODE_STRING, SqlBaseParserBINARY_LITERAL, SqlBaseParserINTEGER_VALUE, SqlBaseParserDECIMAL_VALUE, SqlBaseParserDOUBLE_VALUE, SqlBaseParserIDENTIFIER, SqlBaseParserDIGIT_IDENTIFIER, SqlBaseParserQUOTED_IDENTIFIER, SqlBaseParserBACKQUOTED_IDENTIFIER, SqlBaseParserDOUBLE_PRECISION:
		localctx = NewPredicatedContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(1228)

			var _x = p.valueExpression(0)

			localctx.(*PredicatedContext)._valueExpression = _x
		}
		p.SetState(1230)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 158, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1229)
				p.Predicate(localctx.(*PredicatedContext).Get_valueExpression())
			}

		}

	case SqlBaseParserNOT:
		localctx = NewLogicalNotContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1232)
			p.Match(SqlBaseParserNOT)
		}
		{
			p.SetState(1233)
			p.booleanExpression(3)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1244)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 161, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1242)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 160, p.GetParserRuleContext()) {
			case 1:
				localctx = NewLogicalBinaryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_booleanExpression)
				p.SetState(1236)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(1237)

					var _m = p.Match(SqlBaseParserAND)

					localctx.(*LogicalBinaryContext).operator = _m
				}
				{
					p.SetState(1238)

					var _x = p.booleanExpression(3)

					localctx.(*LogicalBinaryContext).right = _x
				}

			case 2:
				localctx = NewLogicalBinaryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_booleanExpression)
				p.SetState(1239)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(1240)

					var _m = p.Match(SqlBaseParserOR)

					localctx.(*LogicalBinaryContext).operator = _m
				}
				{
					p.SetState(1241)

					var _x = p.booleanExpression(2)

					localctx.(*LogicalBinaryContext).right = _x
				}

			}

		}
		p.SetState(1246)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 161, p.GetParserRuleContext())
	}

	return localctx
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value attribute.
	GetValue() ParserRuleContext

	// SetValue sets the value attribute.
	SetValue(ParserRuleContext)

	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	value  ParserRuleContext
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_predicate
	return p
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, value ParserRuleContext) *PredicateContext {
	var p = new(PredicateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_predicate

	p.value = value

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) GetValue() ParserRuleContext { return s.value }

func (s *PredicateContext) SetValue(v ParserRuleContext) { s.value = v }

func (s *PredicateContext) CopyFrom(ctx *PredicateContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
	s.value = ctx.value
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ComparisonContext struct {
	*PredicateContext
	right IValueExpressionContext
}

func NewComparisonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComparisonContext {
	var p = new(ComparisonContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *ComparisonContext) GetRight() IValueExpressionContext { return s.right }

func (s *ComparisonContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonContext) ComparisonOperator() IComparisonOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *ComparisonContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterComparison(s)
	}
}

func (s *ComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitComparison(s)
	}
}

func (s *ComparisonContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitComparison(s)

	default:
		return t.VisitChildren(s)
	}
}

type LikeContext struct {
	*PredicateContext
	pattern IValueExpressionContext
	escape  IValueExpressionContext
}

func NewLikeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LikeContext {
	var p = new(LikeContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *LikeContext) GetPattern() IValueExpressionContext { return s.pattern }

func (s *LikeContext) GetEscape() IValueExpressionContext { return s.escape }

func (s *LikeContext) SetPattern(v IValueExpressionContext) { s.pattern = v }

func (s *LikeContext) SetEscape(v IValueExpressionContext) { s.escape = v }

func (s *LikeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikeContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIKE, 0)
}

func (s *LikeContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *LikeContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *LikeContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *LikeContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserESCAPE, 0)
}

func (s *LikeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterLike(s)
	}
}

func (s *LikeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitLike(s)
	}
}

func (s *LikeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitLike(s)

	default:
		return t.VisitChildren(s)
	}
}

type InSubqueryContext struct {
	*PredicateContext
}

func NewInSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InSubqueryContext {
	var p = new(InSubqueryContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *InSubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InSubqueryContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, 0)
}

func (s *InSubqueryContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *InSubqueryContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *InSubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterInSubquery(s)
	}
}

func (s *InSubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitInSubquery(s)
	}
}

func (s *InSubqueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitInSubquery(s)

	default:
		return t.VisitChildren(s)
	}
}

type DistinctFromContext struct {
	*PredicateContext
	right IValueExpressionContext
}

func NewDistinctFromContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DistinctFromContext {
	var p = new(DistinctFromContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *DistinctFromContext) GetRight() IValueExpressionContext { return s.right }

func (s *DistinctFromContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *DistinctFromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistinctFromContext) IS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIS, 0)
}

func (s *DistinctFromContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDISTINCT, 0)
}

func (s *DistinctFromContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *DistinctFromContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *DistinctFromContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *DistinctFromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDistinctFrom(s)
	}
}

func (s *DistinctFromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDistinctFrom(s)
	}
}

func (s *DistinctFromContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitDistinctFrom(s)

	default:
		return t.VisitChildren(s)
	}
}

type InListContext struct {
	*PredicateContext
}

func NewInListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InListContext {
	var p = new(InListContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *InListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InListContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, 0)
}

func (s *InListContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *InListContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InListContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *InListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterInList(s)
	}
}

func (s *InListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitInList(s)
	}
}

func (s *InListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitInList(s)

	default:
		return t.VisitChildren(s)
	}
}

type NullPredicateContext struct {
	*PredicateContext
}

func NewNullPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullPredicateContext {
	var p = new(NullPredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *NullPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullPredicateContext) IS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIS, 0)
}

func (s *NullPredicateContext) NULL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULL, 0)
}

func (s *NullPredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *NullPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterNullPredicate(s)
	}
}

func (s *NullPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitNullPredicate(s)
	}
}

func (s *NullPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitNullPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

type BetweenContext struct {
	*PredicateContext
	lower IValueExpressionContext
	upper IValueExpressionContext
}

func NewBetweenContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BetweenContext {
	var p = new(BetweenContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *BetweenContext) GetLower() IValueExpressionContext { return s.lower }

func (s *BetweenContext) GetUpper() IValueExpressionContext { return s.upper }

func (s *BetweenContext) SetLower(v IValueExpressionContext) { s.lower = v }

func (s *BetweenContext) SetUpper(v IValueExpressionContext) { s.upper = v }

func (s *BetweenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BetweenContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBETWEEN, 0)
}

func (s *BetweenContext) AND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAND, 0)
}

func (s *BetweenContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *BetweenContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *BetweenContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *BetweenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterBetween(s)
	}
}

func (s *BetweenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitBetween(s)
	}
}

func (s *BetweenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitBetween(s)

	default:
		return t.VisitChildren(s)
	}
}

type QuantifiedComparisonContext struct {
	*PredicateContext
}

func NewQuantifiedComparisonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QuantifiedComparisonContext {
	var p = new(QuantifiedComparisonContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *QuantifiedComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuantifiedComparisonContext) ComparisonOperator() IComparisonOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *QuantifiedComparisonContext) ComparisonQuantifier() IComparisonQuantifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonQuantifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparisonQuantifierContext)
}

func (s *QuantifiedComparisonContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *QuantifiedComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterQuantifiedComparison(s)
	}
}

func (s *QuantifiedComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitQuantifiedComparison(s)
	}
}

func (s *QuantifiedComparisonContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitQuantifiedComparison(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) Predicate(value ParserRuleContext) (localctx IPredicateContext) {
	localctx = NewPredicateContext(p, p.GetParserRuleContext(), p.GetState(), value)
	p.EnterRule(localctx, 88, SqlBaseParserRULE_predicate)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1308)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 170, p.GetParserRuleContext()) {
	case 1:
		localctx = NewComparisonContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1247)
			p.ComparisonOperator()
		}
		{
			p.SetState(1248)

			var _x = p.valueExpression(0)

			localctx.(*ComparisonContext).right = _x
		}

	case 2:
		localctx = NewQuantifiedComparisonContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1250)
			p.ComparisonOperator()
		}
		{
			p.SetState(1251)
			p.ComparisonQuantifier()
		}
		{
			p.SetState(1252)
			p.Match(SqlBaseParserT__1)
		}
		{
			p.SetState(1253)
			p.Query()
		}
		{
			p.SetState(1254)
			p.Match(SqlBaseParserT__2)
		}

	case 3:
		localctx = NewBetweenContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1257)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserNOT {
			{
				p.SetState(1256)
				p.Match(SqlBaseParserNOT)
			}

		}
		{
			p.SetState(1259)
			p.Match(SqlBaseParserBETWEEN)
		}
		{
			p.SetState(1260)

			var _x = p.valueExpression(0)

			localctx.(*BetweenContext).lower = _x
		}
		{
			p.SetState(1261)
			p.Match(SqlBaseParserAND)
		}
		{
			p.SetState(1262)

			var _x = p.valueExpression(0)

			localctx.(*BetweenContext).upper = _x
		}

	case 4:
		localctx = NewInListContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1265)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserNOT {
			{
				p.SetState(1264)
				p.Match(SqlBaseParserNOT)
			}

		}
		{
			p.SetState(1267)
			p.Match(SqlBaseParserIN)
		}
		{
			p.SetState(1268)
			p.Match(SqlBaseParserT__1)
		}
		{
			p.SetState(1269)
			p.Expression()
		}
		p.SetState(1274)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__3 {
			{
				p.SetState(1270)
				p.Match(SqlBaseParserT__3)
			}
			{
				p.SetState(1271)
				p.Expression()
			}

			p.SetState(1276)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1277)
			p.Match(SqlBaseParserT__2)
		}

	case 5:
		localctx = NewInSubqueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		p.SetState(1280)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserNOT {
			{
				p.SetState(1279)
				p.Match(SqlBaseParserNOT)
			}

		}
		{
			p.SetState(1282)
			p.Match(SqlBaseParserIN)
		}
		{
			p.SetState(1283)
			p.Match(SqlBaseParserT__1)
		}
		{
			p.SetState(1284)
			p.Query()
		}
		{
			p.SetState(1285)
			p.Match(SqlBaseParserT__2)
		}

	case 6:
		localctx = NewLikeContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		p.SetState(1288)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserNOT {
			{
				p.SetState(1287)
				p.Match(SqlBaseParserNOT)
			}

		}
		{
			p.SetState(1290)
			p.Match(SqlBaseParserLIKE)
		}
		{
			p.SetState(1291)

			var _x = p.valueExpression(0)

			localctx.(*LikeContext).pattern = _x
		}
		p.SetState(1294)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 167, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1292)
				p.Match(SqlBaseParserESCAPE)
			}
			{
				p.SetState(1293)

				var _x = p.valueExpression(0)

				localctx.(*LikeContext).escape = _x
			}

		}

	case 7:
		localctx = NewNullPredicateContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1296)
			p.Match(SqlBaseParserIS)
		}
		p.SetState(1298)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserNOT {
			{
				p.SetState(1297)
				p.Match(SqlBaseParserNOT)
			}

		}
		{
			p.SetState(1300)
			p.Match(SqlBaseParserNULL)
		}

	case 8:
		localctx = NewDistinctFromContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1301)
			p.Match(SqlBaseParserIS)
		}
		p.SetState(1303)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserNOT {
			{
				p.SetState(1302)
				p.Match(SqlBaseParserNOT)
			}

		}
		{
			p.SetState(1305)
			p.Match(SqlBaseParserDISTINCT)
		}
		{
			p.SetState(1306)
			p.Match(SqlBaseParserFROM)
		}
		{
			p.SetState(1307)

			var _x = p.valueExpression(0)

			localctx.(*DistinctFromContext).right = _x
		}

	}

	return localctx
}

// IValueExpressionContext is an interface to support dynamic dispatch.
type IValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValueExpressionContext differentiates from other interfaces.
	IsValueExpressionContext()
}

type ValueExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueExpressionContext() *ValueExpressionContext {
	var p = new(ValueExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_valueExpression
	return p
}

func (*ValueExpressionContext) IsValueExpressionContext() {}

func NewValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueExpressionContext {
	var p = new(ValueExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_valueExpression

	return p
}

func (s *ValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueExpressionContext) CopyFrom(ctx *ValueExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ValueExpressionDefaultContext struct {
	*ValueExpressionContext
}

func NewValueExpressionDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ValueExpressionDefaultContext {
	var p = new(ValueExpressionDefaultContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *ValueExpressionDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionDefaultContext) PrimaryExpression() IPrimaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ValueExpressionDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterValueExpressionDefault(s)
	}
}

func (s *ValueExpressionDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitValueExpressionDefault(s)
	}
}

func (s *ValueExpressionDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitValueExpressionDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type ConcatenationContext struct {
	*ValueExpressionContext
	left  IValueExpressionContext
	right IValueExpressionContext
}

func NewConcatenationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConcatenationContext {
	var p = new(ConcatenationContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *ConcatenationContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ConcatenationContext) GetRight() IValueExpressionContext { return s.right }

func (s *ConcatenationContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ConcatenationContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ConcatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConcatenationContext) CONCAT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCONCAT, 0)
}

func (s *ConcatenationContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *ConcatenationContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ConcatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterConcatenation(s)
	}
}

func (s *ConcatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitConcatenation(s)
	}
}

func (s *ConcatenationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitConcatenation(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArithmeticBinaryContext struct {
	*ValueExpressionContext
	left     IValueExpressionContext
	operator antlr.Token
	right    IValueExpressionContext
}

func NewArithmeticBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticBinaryContext {
	var p = new(ArithmeticBinaryContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticBinaryContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ArithmeticBinaryContext) GetRight() IValueExpressionContext { return s.right }

func (s *ArithmeticBinaryContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ArithmeticBinaryContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ArithmeticBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticBinaryContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *ArithmeticBinaryContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticBinaryContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserASTERISK, 0)
}

func (s *ArithmeticBinaryContext) SLASH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSLASH, 0)
}

func (s *ArithmeticBinaryContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPERCENT, 0)
}

func (s *ArithmeticBinaryContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPLUS, 0)
}

func (s *ArithmeticBinaryContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUS, 0)
}

func (s *ArithmeticBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterArithmeticBinary(s)
	}
}

func (s *ArithmeticBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitArithmeticBinary(s)
	}
}

func (s *ArithmeticBinaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitArithmeticBinary(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArithmeticUnaryContext struct {
	*ValueExpressionContext
	operator antlr.Token
}

func NewArithmeticUnaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticUnaryContext {
	var p = new(ArithmeticUnaryContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticUnaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticUnaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticUnaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticUnaryContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticUnaryContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUS, 0)
}

func (s *ArithmeticUnaryContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPLUS, 0)
}

func (s *ArithmeticUnaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterArithmeticUnary(s)
	}
}

func (s *ArithmeticUnaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitArithmeticUnary(s)
	}
}

func (s *ArithmeticUnaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitArithmeticUnary(s)

	default:
		return t.VisitChildren(s)
	}
}

type AtTimeZoneContext struct {
	*ValueExpressionContext
}

func NewAtTimeZoneContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AtTimeZoneContext {
	var p = new(AtTimeZoneContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *AtTimeZoneContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtTimeZoneContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *AtTimeZoneContext) AT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAT, 0)
}

func (s *AtTimeZoneContext) TimeZoneSpecifier() ITimeZoneSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimeZoneSpecifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimeZoneSpecifierContext)
}

func (s *AtTimeZoneContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterAtTimeZone(s)
	}
}

func (s *AtTimeZoneContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitAtTimeZone(s)
	}
}

func (s *AtTimeZoneContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitAtTimeZone(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) ValueExpression() (localctx IValueExpressionContext) {
	return p.valueExpression(0)
}

func (p *SqlBaseParser) valueExpression(_p int) (localctx IValueExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewValueExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IValueExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 90
	p.EnterRecursionRule(localctx, 90, SqlBaseParserRULE_valueExpression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1314)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserT__1, SqlBaseParserT__4, SqlBaseParserADD, SqlBaseParserADMIN, SqlBaseParserALL, SqlBaseParserANALYZE, SqlBaseParserANY, SqlBaseParserARRAY, SqlBaseParserASC, SqlBaseParserAT, SqlBaseParserBERNOULLI, SqlBaseParserCALL, SqlBaseParserCALLED, SqlBaseParserCASCADE, SqlBaseParserCASE, SqlBaseParserCAST, SqlBaseParserCATALOGS, SqlBaseParserCOLUMN, SqlBaseParserCOLUMNS, SqlBaseParserCOMMENT, SqlBaseParserCOMMIT, SqlBaseParserCOMMITTED, SqlBaseParserCURRENT, SqlBaseParserCURRENT_DATE, SqlBaseParserCURRENT_ROLE, SqlBaseParserCURRENT_TIME, SqlBaseParserCURRENT_TIMESTAMP, SqlBaseParserCURRENT_USER, SqlBaseParserDATA, SqlBaseParserDATE, SqlBaseParserDAY, SqlBaseParserDEFINER, SqlBaseParserDESC, SqlBaseParserDETERMINISTIC, SqlBaseParserDISTRIBUTED, SqlBaseParserEXCLUDING, SqlBaseParserEXISTS, SqlBaseParserEXPLAIN, SqlBaseParserEXTRACT, SqlBaseParserEXTERNAL, SqlBaseParserFALSE, SqlBaseParserFILTER, SqlBaseParserFIRST, SqlBaseParserFOLLOWING, SqlBaseParserFORMAT, SqlBaseParserFUNCTION, SqlBaseParserFUNCTIONS, SqlBaseParserGRANT, SqlBaseParserGRANTED, SqlBaseParserGRANTS, SqlBaseParserGRAPHVIZ, SqlBaseParserGROUPING, SqlBaseParserHOUR, SqlBaseParserIF, SqlBaseParserIGNORE, SqlBaseParserINCLUDING, SqlBaseParserINPUT, SqlBaseParserINTERVAL, SqlBaseParserINVOKER, SqlBaseParserIO, SqlBaseParserISOLATION, SqlBaseParserJSON, SqlBaseParserLANGUAGE, SqlBaseParserLAST, SqlBaseParserLATERAL, SqlBaseParserLEVEL, SqlBaseParserLIMIT, SqlBaseParserLOCALTIME, SqlBaseParserLOCALTIMESTAMP, SqlBaseParserLOGICAL, SqlBaseParserMAP, SqlBaseParserMATERIALIZED, SqlBaseParserMINUTE, SqlBaseParserMONTH, SqlBaseParserNAME, SqlBaseParserNFC, SqlBaseParserNFD, SqlBaseParserNFKC, SqlBaseParserNFKD, SqlBaseParserNO, SqlBaseParserNONE, SqlBaseParserNORMALIZE, SqlBaseParserNULL, SqlBaseParserNULLIF, SqlBaseParserNULLS, SqlBaseParserOFFSET, SqlBaseParserONLY, SqlBaseParserOPTION, SqlBaseParserORDINALITY, SqlBaseParserOUTPUT, SqlBaseParserOVER, SqlBaseParserPARTITION, SqlBaseParserPARTITIONS, SqlBaseParserPOSITION, SqlBaseParserPRECEDING, SqlBaseParserPRIVILEGES, SqlBaseParserPROPERTIES, SqlBaseParserRANGE, SqlBaseParserREAD, SqlBaseParserREFRESH, SqlBaseParserRENAME, SqlBaseParserREPEATABLE, SqlBaseParserREPLACE, SqlBaseParserRESET, SqlBaseParserRESPECT, SqlBaseParserRESTRICT, SqlBaseParserRETURN, SqlBaseParserRETURNS, SqlBaseParserREVOKE, SqlBaseParserROLE, SqlBaseParserROLES, SqlBaseParserROLLBACK, SqlBaseParserROW, SqlBaseParserROWS, SqlBaseParserSCHEMA, SqlBaseParserSCHEMAS, SqlBaseParserSECOND, SqlBaseParserSECURITY, SqlBaseParserSERIALIZABLE, SqlBaseParserSESSION, SqlBaseParserSET, SqlBaseParserSETS, SqlBaseParserSHOW, SqlBaseParserSOME, SqlBaseParserSQL, SqlBaseParserSTART, SqlBaseParserSTATS, SqlBaseParserSUBSTRING, SqlBaseParserSYSTEM, SqlBaseParserTABLES, SqlBaseParserTABLESAMPLE, SqlBaseParserTEMPORARY, SqlBaseParserTEXT, SqlBaseParserTIME, SqlBaseParserTIMESTAMP, SqlBaseParserTO, SqlBaseParserTRANSACTION, SqlBaseParserTRUE, SqlBaseParserTRY_CAST, SqlBaseParserTYPE, SqlBaseParserUNBOUNDED, SqlBaseParserUNCOMMITTED, SqlBaseParserUSE, SqlBaseParserUSER, SqlBaseParserVALIDATE, SqlBaseParserVERBOSE, SqlBaseParserVIEW, SqlBaseParserWORK, SqlBaseParserWRITE, SqlBaseParserYEAR, SqlBaseParserZONE, SqlBaseParserSTRING, SqlBaseParserUNICODE_STRING, SqlBaseParserBINARY_LITERAL, SqlBaseParserINTEGER_VALUE, SqlBaseParserDECIMAL_VALUE, SqlBaseParserDOUBLE_VALUE, SqlBaseParserIDENTIFIER, SqlBaseParserDIGIT_IDENTIFIER, SqlBaseParserQUOTED_IDENTIFIER, SqlBaseParserBACKQUOTED_IDENTIFIER, SqlBaseParserDOUBLE_PRECISION:
		localctx = NewValueExpressionDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(1311)
			p.primaryExpression(0)
		}

	case SqlBaseParserPLUS, SqlBaseParserMINUS:
		localctx = NewArithmeticUnaryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1312)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ArithmeticUnaryContext).operator = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserPLUS || _la == SqlBaseParserMINUS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ArithmeticUnaryContext).operator = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1313)
			p.valueExpression(4)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1330)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 173, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1328)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 172, p.GetParserRuleContext()) {
			case 1:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_valueExpression)
				p.SetState(1316)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(1317)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((_la-221)&-(0x1f+1)) == 0 && ((1<<uint((_la-221)))&((1<<(SqlBaseParserASTERISK-221))|(1<<(SqlBaseParserSLASH-221))|(1<<(SqlBaseParserPERCENT-221)))) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1318)

					var _x = p.valueExpression(4)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 2:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_valueExpression)
				p.SetState(1319)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(1320)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == SqlBaseParserPLUS || _la == SqlBaseParserMINUS) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1321)

					var _x = p.valueExpression(3)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 3:
				localctx = NewConcatenationContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ConcatenationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_valueExpression)
				p.SetState(1322)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(1323)
					p.Match(SqlBaseParserCONCAT)
				}
				{
					p.SetState(1324)

					var _x = p.valueExpression(2)

					localctx.(*ConcatenationContext).right = _x
				}

			case 4:
				localctx = NewAtTimeZoneContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_valueExpression)
				p.SetState(1325)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(1326)
					p.Match(SqlBaseParserAT)
				}
				{
					p.SetState(1327)
					p.TimeZoneSpecifier()
				}

			}

		}
		p.SetState(1332)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 173, p.GetParserRuleContext())
	}

	return localctx
}

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_primaryExpression
	return p
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) CopyFrom(ctx *PrimaryExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DereferenceContext struct {
	*PrimaryExpressionContext
	base      IPrimaryExpressionContext
	fieldName IIdentifierContext
}

func NewDereferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DereferenceContext {
	var p = new(DereferenceContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *DereferenceContext) GetBase() IPrimaryExpressionContext { return s.base }

func (s *DereferenceContext) GetFieldName() IIdentifierContext { return s.fieldName }

func (s *DereferenceContext) SetBase(v IPrimaryExpressionContext) { s.base = v }

func (s *DereferenceContext) SetFieldName(v IIdentifierContext) { s.fieldName = v }

func (s *DereferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DereferenceContext) PrimaryExpression() IPrimaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *DereferenceContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DereferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDereference(s)
	}
}

func (s *DereferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDereference(s)
	}
}

func (s *DereferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitDereference(s)

	default:
		return t.VisitChildren(s)
	}
}

type TypeConstructorContext struct {
	*PrimaryExpressionContext
}

func NewTypeConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TypeConstructorContext {
	var p = new(TypeConstructorContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *TypeConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeConstructorContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeConstructorContext) String_() IString_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *TypeConstructorContext) DOUBLE_PRECISION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDOUBLE_PRECISION, 0)
}

func (s *TypeConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterTypeConstructor(s)
	}
}

func (s *TypeConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitTypeConstructor(s)
	}
}

func (s *TypeConstructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitTypeConstructor(s)

	default:
		return t.VisitChildren(s)
	}
}

type SpecialDateTimeFunctionContext struct {
	*PrimaryExpressionContext
	name      antlr.Token
	precision antlr.Token
}

func NewSpecialDateTimeFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpecialDateTimeFunctionContext {
	var p = new(SpecialDateTimeFunctionContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SpecialDateTimeFunctionContext) GetName() antlr.Token { return s.name }

func (s *SpecialDateTimeFunctionContext) GetPrecision() antlr.Token { return s.precision }

func (s *SpecialDateTimeFunctionContext) SetName(v antlr.Token) { s.name = v }

func (s *SpecialDateTimeFunctionContext) SetPrecision(v antlr.Token) { s.precision = v }

func (s *SpecialDateTimeFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialDateTimeFunctionContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT_DATE, 0)
}

func (s *SpecialDateTimeFunctionContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT_TIME, 0)
}

func (s *SpecialDateTimeFunctionContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTEGER_VALUE, 0)
}

func (s *SpecialDateTimeFunctionContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT_TIMESTAMP, 0)
}

func (s *SpecialDateTimeFunctionContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLOCALTIME, 0)
}

func (s *SpecialDateTimeFunctionContext) LOCALTIMESTAMP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLOCALTIMESTAMP, 0)
}

func (s *SpecialDateTimeFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSpecialDateTimeFunction(s)
	}
}

func (s *SpecialDateTimeFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSpecialDateTimeFunction(s)
	}
}

func (s *SpecialDateTimeFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSpecialDateTimeFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type SubstringContext struct {
	*PrimaryExpressionContext
}

func NewSubstringContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubstringContext {
	var p = new(SubstringContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SubstringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubstringContext) SUBSTRING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSUBSTRING, 0)
}

func (s *SubstringContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *SubstringContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *SubstringContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *SubstringContext) FOR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOR, 0)
}

func (s *SubstringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSubstring(s)
	}
}

func (s *SubstringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSubstring(s)
	}
}

func (s *SubstringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSubstring(s)

	default:
		return t.VisitChildren(s)
	}
}

type CastContext struct {
	*PrimaryExpressionContext
}

func NewCastContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastContext {
	var p = new(CastContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastContext) CAST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCAST, 0)
}

func (s *CastContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CastContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *CastContext) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *CastContext) TRY_CAST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRY_CAST, 0)
}

func (s *CastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCast(s)
	}
}

func (s *CastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCast(s)
	}
}

func (s *CastContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitCast(s)

	default:
		return t.VisitChildren(s)
	}
}

type LambdaContext struct {
	*PrimaryExpressionContext
}

func NewLambdaContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LambdaContext {
	var p = new(LambdaContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *LambdaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *LambdaContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LambdaContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LambdaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterLambda(s)
	}
}

func (s *LambdaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitLambda(s)
	}
}

func (s *LambdaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitLambda(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParenthesizedExpressionContext struct {
	*PrimaryExpressionContext
}

func NewParenthesizedExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParenthesizedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitParenthesizedExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParameterContext struct {
	*PrimaryExpressionContext
}

func NewParameterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParameterContext {
	var p = new(ParameterContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterParameter(s)
	}
}

func (s *ParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitParameter(s)
	}
}

func (s *ParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

type NormalizeContext struct {
	*PrimaryExpressionContext
}

func NewNormalizeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NormalizeContext {
	var p = new(NormalizeContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *NormalizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NormalizeContext) NORMALIZE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNORMALIZE, 0)
}

func (s *NormalizeContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *NormalizeContext) NormalForm() INormalFormContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INormalFormContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INormalFormContext)
}

func (s *NormalizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterNormalize(s)
	}
}

func (s *NormalizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitNormalize(s)
	}
}

func (s *NormalizeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitNormalize(s)

	default:
		return t.VisitChildren(s)
	}
}

type IntervalLiteralContext struct {
	*PrimaryExpressionContext
}

func NewIntervalLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntervalLiteralContext {
	var p = new(IntervalLiteralContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *IntervalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalLiteralContext) Interval() IIntervalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntervalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *IntervalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterIntervalLiteral(s)
	}
}

func (s *IntervalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitIntervalLiteral(s)
	}
}

func (s *IntervalLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitIntervalLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type NumericLiteralContext struct {
	*PrimaryExpressionContext
}

func NewNumericLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NumericLiteralContext {
	var p = new(NumericLiteralContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *NumericLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericLiteralContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *NumericLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitNumericLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type BooleanLiteralContext struct {
	*PrimaryExpressionContext
}

func NewBooleanLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) BooleanValue() IBooleanValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanValueContext)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitBooleanLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleCaseContext struct {
	*PrimaryExpressionContext
	elseExpression IExpressionContext
}

func NewSimpleCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleCaseContext {
	var p = new(SimpleCaseContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SimpleCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SimpleCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SimpleCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCASE, 0)
}

func (s *SimpleCaseContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *SimpleCaseContext) END() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEND, 0)
}

func (s *SimpleCaseContext) AllWhenClause() []IWhenClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWhenClauseContext)(nil)).Elem())
	var tst = make([]IWhenClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWhenClauseContext)
		}
	}

	return tst
}

func (s *SimpleCaseContext) WhenClause(i int) IWhenClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhenClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SimpleCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserELSE, 0)
}

func (s *SimpleCaseContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SimpleCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSimpleCase(s)
	}
}

func (s *SimpleCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSimpleCase(s)
	}
}

func (s *SimpleCaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSimpleCase(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnReferenceContext struct {
	*PrimaryExpressionContext
}

func NewColumnReferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnReferenceContext {
	var p = new(ColumnReferenceContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ColumnReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnReferenceContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterColumnReference(s)
	}
}

func (s *ColumnReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitColumnReference(s)
	}
}

func (s *ColumnReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitColumnReference(s)

	default:
		return t.VisitChildren(s)
	}
}

type NullLiteralContext struct {
	*PrimaryExpressionContext
}

func NewNullLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullLiteralContext {
	var p = new(NullLiteralContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *NullLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullLiteralContext) NULL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULL, 0)
}

func (s *NullLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterNullLiteral(s)
	}
}

func (s *NullLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitNullLiteral(s)
	}
}

func (s *NullLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitNullLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type RowConstructorContext struct {
	*PrimaryExpressionContext
}

func NewRowConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RowConstructorContext {
	var p = new(RowConstructorContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *RowConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowConstructorContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *RowConstructorContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RowConstructorContext) ROW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROW, 0)
}

func (s *RowConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRowConstructor(s)
	}
}

func (s *RowConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRowConstructor(s)
	}
}

func (s *RowConstructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitRowConstructor(s)

	default:
		return t.VisitChildren(s)
	}
}

type SubscriptContext struct {
	*PrimaryExpressionContext
	value IPrimaryExpressionContext
	index IValueExpressionContext
}

func NewSubscriptContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubscriptContext {
	var p = new(SubscriptContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SubscriptContext) GetValue() IPrimaryExpressionContext { return s.value }

func (s *SubscriptContext) GetIndex() IValueExpressionContext { return s.index }

func (s *SubscriptContext) SetValue(v IPrimaryExpressionContext) { s.value = v }

func (s *SubscriptContext) SetIndex(v IValueExpressionContext) { s.index = v }

func (s *SubscriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscriptContext) PrimaryExpression() IPrimaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *SubscriptContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *SubscriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSubscript(s)
	}
}

func (s *SubscriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSubscript(s)
	}
}

func (s *SubscriptContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSubscript(s)

	default:
		return t.VisitChildren(s)
	}
}

type SubqueryExpressionContext struct {
	*PrimaryExpressionContext
}

func NewSubqueryExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryExpressionContext {
	var p = new(SubqueryExpressionContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SubqueryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryExpressionContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *SubqueryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSubqueryExpression(s)
	}
}

func (s *SubqueryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSubqueryExpression(s)
	}
}

func (s *SubqueryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSubqueryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BinaryLiteralContext struct {
	*PrimaryExpressionContext
}

func NewBinaryLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BinaryLiteralContext {
	var p = new(BinaryLiteralContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *BinaryLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryLiteralContext) BINARY_LITERAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBINARY_LITERAL, 0)
}

func (s *BinaryLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterBinaryLiteral(s)
	}
}

func (s *BinaryLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitBinaryLiteral(s)
	}
}

func (s *BinaryLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitBinaryLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type CurrentUserContext struct {
	*PrimaryExpressionContext
	name antlr.Token
}

func NewCurrentUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentUserContext {
	var p = new(CurrentUserContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CurrentUserContext) GetName() antlr.Token { return s.name }

func (s *CurrentUserContext) SetName(v antlr.Token) { s.name = v }

func (s *CurrentUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentUserContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT_USER, 0)
}

func (s *CurrentUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCurrentUser(s)
	}
}

func (s *CurrentUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCurrentUser(s)
	}
}

func (s *CurrentUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitCurrentUser(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExtractContext struct {
	*PrimaryExpressionContext
}

func NewExtractContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExtractContext {
	var p = new(ExtractContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ExtractContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtractContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXTRACT, 0)
}

func (s *ExtractContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExtractContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *ExtractContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ExtractContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterExtract(s)
	}
}

func (s *ExtractContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitExtract(s)
	}
}

func (s *ExtractContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitExtract(s)

	default:
		return t.VisitChildren(s)
	}
}

type StringLiteralContext struct {
	*PrimaryExpressionContext
}

func NewStringLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringLiteralContext {
	var p = new(StringLiteralContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) String_() IString_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

func (s *StringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArrayConstructorContext struct {
	*PrimaryExpressionContext
}

func NewArrayConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayConstructorContext {
	var p = new(ArrayConstructorContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ArrayConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayConstructorContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserARRAY, 0)
}

func (s *ArrayConstructorContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ArrayConstructorContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterArrayConstructor(s)
	}
}

func (s *ArrayConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitArrayConstructor(s)
	}
}

func (s *ArrayConstructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitArrayConstructor(s)

	default:
		return t.VisitChildren(s)
	}
}

type FunctionCallContext struct {
	*PrimaryExpressionContext
}

func NewFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionCallContext {
	var p = new(FunctionCallContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *FunctionCallContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserASTERISK, 0)
}

func (s *FunctionCallContext) Filter() IFilterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFilterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFilterContext)
}

func (s *FunctionCallContext) Over() IOverContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOverContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOverContext)
}

func (s *FunctionCallContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *FunctionCallContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionCallContext) ORDER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserORDER, 0)
}

func (s *FunctionCallContext) BY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBY, 0)
}

func (s *FunctionCallContext) AllSortItem() []ISortItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISortItemContext)(nil)).Elem())
	var tst = make([]ISortItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISortItemContext)
		}
	}

	return tst
}

func (s *FunctionCallContext) SortItem(i int) ISortItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *FunctionCallContext) SetQuantifier() ISetQuantifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetQuantifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *FunctionCallContext) NullTreatment() INullTreatmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INullTreatmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INullTreatmentContext)
}

func (s *FunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterFunctionCall(s)
	}
}

func (s *FunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitFunctionCall(s)
	}
}

func (s *FunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExistsContext struct {
	*PrimaryExpressionContext
}

func NewExistsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExistsContext {
	var p = new(ExistsContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExistsContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *ExistsContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *ExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterExists(s)
	}
}

func (s *ExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitExists(s)
	}
}

func (s *ExistsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitExists(s)

	default:
		return t.VisitChildren(s)
	}
}

type PositionContext struct {
	*PrimaryExpressionContext
}

func NewPositionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PositionContext {
	var p = new(PositionContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *PositionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PositionContext) POSITION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPOSITION, 0)
}

func (s *PositionContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *PositionContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PositionContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, 0)
}

func (s *PositionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterPosition(s)
	}
}

func (s *PositionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitPosition(s)
	}
}

func (s *PositionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitPosition(s)

	default:
		return t.VisitChildren(s)
	}
}

type SearchedCaseContext struct {
	*PrimaryExpressionContext
	elseExpression IExpressionContext
}

func NewSearchedCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SearchedCaseContext {
	var p = new(SearchedCaseContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SearchedCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SearchedCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SearchedCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchedCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCASE, 0)
}

func (s *SearchedCaseContext) END() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEND, 0)
}

func (s *SearchedCaseContext) AllWhenClause() []IWhenClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWhenClauseContext)(nil)).Elem())
	var tst = make([]IWhenClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWhenClauseContext)
		}
	}

	return tst
}

func (s *SearchedCaseContext) WhenClause(i int) IWhenClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhenClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SearchedCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserELSE, 0)
}

func (s *SearchedCaseContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SearchedCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSearchedCase(s)
	}
}

func (s *SearchedCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSearchedCase(s)
	}
}

func (s *SearchedCaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSearchedCase(s)

	default:
		return t.VisitChildren(s)
	}
}

type GroupingOperationContext struct {
	*PrimaryExpressionContext
}

func NewGroupingOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GroupingOperationContext {
	var p = new(GroupingOperationContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *GroupingOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingOperationContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGROUPING, 0)
}

func (s *GroupingOperationContext) AllQualifiedName() []IQualifiedNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem())
	var tst = make([]IQualifiedNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQualifiedNameContext)
		}
	}

	return tst
}

func (s *GroupingOperationContext) QualifiedName(i int) IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *GroupingOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterGroupingOperation(s)
	}
}

func (s *GroupingOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitGroupingOperation(s)
	}
}

func (s *GroupingOperationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitGroupingOperation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	return p.primaryExpression(0)
}

func (p *SqlBaseParser) primaryExpression(_p int) (localctx IPrimaryExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPrimaryExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 92
	p.EnterRecursionRule(localctx, 92, SqlBaseParserRULE_primaryExpression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1572)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 202, p.GetParserRuleContext()) {
	case 1:
		localctx = NewNullLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(1334)
			p.Match(SqlBaseParserNULL)
		}

	case 2:
		localctx = NewIntervalLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1335)
			p.Interval()
		}

	case 3:
		localctx = NewTypeConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1336)
			p.Identifier()
		}
		{
			p.SetState(1337)
			p.String_()
		}

	case 4:
		localctx = NewTypeConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1339)
			p.Match(SqlBaseParserDOUBLE_PRECISION)
		}
		{
			p.SetState(1340)
			p.String_()
		}

	case 5:
		localctx = NewNumericLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1341)
			p.Number()
		}

	case 6:
		localctx = NewBooleanLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1342)
			p.BooleanValue()
		}

	case 7:
		localctx = NewStringLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1343)
			p.String_()
		}

	case 8:
		localctx = NewBinaryLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1344)
			p.Match(SqlBaseParserBINARY_LITERAL)
		}

	case 9:
		localctx = NewParameterContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1345)
			p.Match(SqlBaseParserT__4)
		}

	case 10:
		localctx = NewPositionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1346)
			p.Match(SqlBaseParserPOSITION)
		}
		{
			p.SetState(1347)
			p.Match(SqlBaseParserT__1)
		}
		{
			p.SetState(1348)
			p.valueExpression(0)
		}
		{
			p.SetState(1349)
			p.Match(SqlBaseParserIN)
		}
		{
			p.SetState(1350)
			p.valueExpression(0)
		}
		{
			p.SetState(1351)
			p.Match(SqlBaseParserT__2)
		}

	case 11:
		localctx = NewRowConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1353)
			p.Match(SqlBaseParserT__1)
		}
		{
			p.SetState(1354)
			p.Expression()
		}
		p.SetState(1357)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SqlBaseParserT__3 {
			{
				p.SetState(1355)
				p.Match(SqlBaseParserT__3)
			}
			{
				p.SetState(1356)
				p.Expression()
			}

			p.SetState(1359)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1361)
			p.Match(SqlBaseParserT__2)
		}

	case 12:
		localctx = NewRowConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1363)
			p.Match(SqlBaseParserROW)
		}
		{
			p.SetState(1364)
			p.Match(SqlBaseParserT__1)
		}
		{
			p.SetState(1365)
			p.Expression()
		}
		p.SetState(1370)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__3 {
			{
				p.SetState(1366)
				p.Match(SqlBaseParserT__3)
			}
			{
				p.SetState(1367)
				p.Expression()
			}

			p.SetState(1372)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1373)
			p.Match(SqlBaseParserT__2)
		}

	case 13:
		localctx = NewFunctionCallContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1375)
			p.QualifiedName()
		}
		{
			p.SetState(1376)
			p.Match(SqlBaseParserT__1)
		}
		{
			p.SetState(1377)
			p.Match(SqlBaseParserASTERISK)
		}
		{
			p.SetState(1378)
			p.Match(SqlBaseParserT__2)
		}
		p.SetState(1380)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 176, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1379)
				p.Filter()
			}

		}
		p.SetState(1383)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 177, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1382)
				p.Over()
			}

		}

	case 14:
		localctx = NewFunctionCallContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1385)
			p.QualifiedName()
		}
		{
			p.SetState(1386)
			p.Match(SqlBaseParserT__1)
		}
		p.SetState(1398)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SqlBaseParserT__1)|(1<<SqlBaseParserT__4)|(1<<SqlBaseParserADD)|(1<<SqlBaseParserADMIN)|(1<<SqlBaseParserALL)|(1<<SqlBaseParserANALYZE)|(1<<SqlBaseParserANY)|(1<<SqlBaseParserARRAY)|(1<<SqlBaseParserASC)|(1<<SqlBaseParserAT)|(1<<SqlBaseParserBERNOULLI)|(1<<SqlBaseParserCALL)|(1<<SqlBaseParserCALLED)|(1<<SqlBaseParserCASCADE)|(1<<SqlBaseParserCASE)|(1<<SqlBaseParserCAST)|(1<<SqlBaseParserCATALOGS)|(1<<SqlBaseParserCOLUMN)|(1<<SqlBaseParserCOLUMNS))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(SqlBaseParserCOMMENT-32))|(1<<(SqlBaseParserCOMMIT-32))|(1<<(SqlBaseParserCOMMITTED-32))|(1<<(SqlBaseParserCURRENT-32))|(1<<(SqlBaseParserCURRENT_DATE-32))|(1<<(SqlBaseParserCURRENT_ROLE-32))|(1<<(SqlBaseParserCURRENT_TIME-32))|(1<<(SqlBaseParserCURRENT_TIMESTAMP-32))|(1<<(SqlBaseParserCURRENT_USER-32))|(1<<(SqlBaseParserDATA-32))|(1<<(SqlBaseParserDATE-32))|(1<<(SqlBaseParserDAY-32))|(1<<(SqlBaseParserDEFINER-32))|(1<<(SqlBaseParserDESC-32))|(1<<(SqlBaseParserDETERMINISTIC-32))|(1<<(SqlBaseParserDISTINCT-32))|(1<<(SqlBaseParserDISTRIBUTED-32))|(1<<(SqlBaseParserEXCLUDING-32))|(1<<(SqlBaseParserEXISTS-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(SqlBaseParserEXPLAIN-64))|(1<<(SqlBaseParserEXTRACT-64))|(1<<(SqlBaseParserEXTERNAL-64))|(1<<(SqlBaseParserFALSE-64))|(1<<(SqlBaseParserFILTER-64))|(1<<(SqlBaseParserFIRST-64))|(1<<(SqlBaseParserFOLLOWING-64))|(1<<(SqlBaseParserFORMAT-64))|(1<<(SqlBaseParserFUNCTION-64))|(1<<(SqlBaseParserFUNCTIONS-64))|(1<<(SqlBaseParserGRANT-64))|(1<<(SqlBaseParserGRANTED-64))|(1<<(SqlBaseParserGRANTS-64))|(1<<(SqlBaseParserGRAPHVIZ-64))|(1<<(SqlBaseParserGROUPING-64))|(1<<(SqlBaseParserHOUR-64))|(1<<(SqlBaseParserIF-64))|(1<<(SqlBaseParserIGNORE-64))|(1<<(SqlBaseParserINCLUDING-64))|(1<<(SqlBaseParserINPUT-64))|(1<<(SqlBaseParserINTERVAL-64))|(1<<(SqlBaseParserINVOKER-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(SqlBaseParserIO-96))|(1<<(SqlBaseParserISOLATION-96))|(1<<(SqlBaseParserJSON-96))|(1<<(SqlBaseParserLANGUAGE-96))|(1<<(SqlBaseParserLAST-96))|(1<<(SqlBaseParserLATERAL-96))|(1<<(SqlBaseParserLEVEL-96))|(1<<(SqlBaseParserLIMIT-96))|(1<<(SqlBaseParserLOCALTIME-96))|(1<<(SqlBaseParserLOCALTIMESTAMP-96))|(1<<(SqlBaseParserLOGICAL-96))|(1<<(SqlBaseParserMAP-96))|(1<<(SqlBaseParserMATERIALIZED-96))|(1<<(SqlBaseParserMINUTE-96))|(1<<(SqlBaseParserMONTH-96))|(1<<(SqlBaseParserNAME-96))|(1<<(SqlBaseParserNFC-96))|(1<<(SqlBaseParserNFD-96))|(1<<(SqlBaseParserNFKC-96))|(1<<(SqlBaseParserNFKD-96))|(1<<(SqlBaseParserNO-96))|(1<<(SqlBaseParserNONE-96))|(1<<(SqlBaseParserNORMALIZE-96))|(1<<(SqlBaseParserNOT-96))|(1<<(SqlBaseParserNULL-96))|(1<<(SqlBaseParserNULLIF-96))|(1<<(SqlBaseParserNULLS-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(SqlBaseParserOFFSET-128))|(1<<(SqlBaseParserONLY-128))|(1<<(SqlBaseParserOPTION-128))|(1<<(SqlBaseParserORDINALITY-128))|(1<<(SqlBaseParserOUTPUT-128))|(1<<(SqlBaseParserOVER-128))|(1<<(SqlBaseParserPARTITION-128))|(1<<(SqlBaseParserPARTITIONS-128))|(1<<(SqlBaseParserPOSITION-128))|(1<<(SqlBaseParserPRECEDING-128))|(1<<(SqlBaseParserPRIVILEGES-128))|(1<<(SqlBaseParserPROPERTIES-128))|(1<<(SqlBaseParserRANGE-128))|(1<<(SqlBaseParserREAD-128))|(1<<(SqlBaseParserREFRESH-128))|(1<<(SqlBaseParserRENAME-128))|(1<<(SqlBaseParserREPEATABLE-128))|(1<<(SqlBaseParserREPLACE-128))|(1<<(SqlBaseParserRESET-128))|(1<<(SqlBaseParserRESPECT-128))|(1<<(SqlBaseParserRESTRICT-128))|(1<<(SqlBaseParserRETURN-128))|(1<<(SqlBaseParserRETURNS-128))|(1<<(SqlBaseParserREVOKE-128))|(1<<(SqlBaseParserROLE-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(SqlBaseParserROLES-160))|(1<<(SqlBaseParserROLLBACK-160))|(1<<(SqlBaseParserROW-160))|(1<<(SqlBaseParserROWS-160))|(1<<(SqlBaseParserSCHEMA-160))|(1<<(SqlBaseParserSCHEMAS-160))|(1<<(SqlBaseParserSECOND-160))|(1<<(SqlBaseParserSECURITY-160))|(1<<(SqlBaseParserSERIALIZABLE-160))|(1<<(SqlBaseParserSESSION-160))|(1<<(SqlBaseParserSET-160))|(1<<(SqlBaseParserSETS-160))|(1<<(SqlBaseParserSHOW-160))|(1<<(SqlBaseParserSOME-160))|(1<<(SqlBaseParserSQL-160))|(1<<(SqlBaseParserSTART-160))|(1<<(SqlBaseParserSTATS-160))|(1<<(SqlBaseParserSUBSTRING-160))|(1<<(SqlBaseParserSYSTEM-160))|(1<<(SqlBaseParserTABLES-160))|(1<<(SqlBaseParserTABLESAMPLE-160))|(1<<(SqlBaseParserTEMPORARY-160))|(1<<(SqlBaseParserTEXT-160))|(1<<(SqlBaseParserTIME-160))|(1<<(SqlBaseParserTIMESTAMP-160))|(1<<(SqlBaseParserTO-160))|(1<<(SqlBaseParserTRANSACTION-160))|(1<<(SqlBaseParserTRUE-160)))) != 0) || (((_la-192)&-(0x1f+1)) == 0 && ((1<<uint((_la-192)))&((1<<(SqlBaseParserTRY_CAST-192))|(1<<(SqlBaseParserTYPE-192))|(1<<(SqlBaseParserUNBOUNDED-192))|(1<<(SqlBaseParserUNCOMMITTED-192))|(1<<(SqlBaseParserUSE-192))|(1<<(SqlBaseParserUSER-192))|(1<<(SqlBaseParserVALIDATE-192))|(1<<(SqlBaseParserVERBOSE-192))|(1<<(SqlBaseParserVIEW-192))|(1<<(SqlBaseParserWORK-192))|(1<<(SqlBaseParserWRITE-192))|(1<<(SqlBaseParserYEAR-192))|(1<<(SqlBaseParserZONE-192))|(1<<(SqlBaseParserPLUS-192))|(1<<(SqlBaseParserMINUS-192)))) != 0) || (((_la-225)&-(0x1f+1)) == 0 && ((1<<uint((_la-225)))&((1<<(SqlBaseParserSTRING-225))|(1<<(SqlBaseParserUNICODE_STRING-225))|(1<<(SqlBaseParserBINARY_LITERAL-225))|(1<<(SqlBaseParserINTEGER_VALUE-225))|(1<<(SqlBaseParserDECIMAL_VALUE-225))|(1<<(SqlBaseParserDOUBLE_VALUE-225))|(1<<(SqlBaseParserIDENTIFIER-225))|(1<<(SqlBaseParserDIGIT_IDENTIFIER-225))|(1<<(SqlBaseParserQUOTED_IDENTIFIER-225))|(1<<(SqlBaseParserBACKQUOTED_IDENTIFIER-225))|(1<<(SqlBaseParserDOUBLE_PRECISION-225)))) != 0) {
			p.SetState(1388)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 178, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1387)
					p.SetQuantifier()
				}

			}
			{
				p.SetState(1390)
				p.Expression()
			}
			p.SetState(1395)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__3 {
				{
					p.SetState(1391)
					p.Match(SqlBaseParserT__3)
				}
				{
					p.SetState(1392)
					p.Expression()
				}

				p.SetState(1397)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(1410)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserORDER {
			{
				p.SetState(1400)
				p.Match(SqlBaseParserORDER)
			}
			{
				p.SetState(1401)
				p.Match(SqlBaseParserBY)
			}
			{
				p.SetState(1402)
				p.SortItem()
			}
			p.SetState(1407)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__3 {
				{
					p.SetState(1403)
					p.Match(SqlBaseParserT__3)
				}
				{
					p.SetState(1404)
					p.SortItem()
				}

				p.SetState(1409)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(1412)
			p.Match(SqlBaseParserT__2)
		}
		p.SetState(1414)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 183, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1413)
				p.Filter()
			}

		}
		p.SetState(1420)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 185, p.GetParserRuleContext()) == 1 {
			p.SetState(1417)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBaseParserIGNORE || _la == SqlBaseParserRESPECT {
				{
					p.SetState(1416)
					p.NullTreatment()
				}

			}
			{
				p.SetState(1419)
				p.Over()
			}

		}

	case 15:
		localctx = NewLambdaContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1422)
			p.Identifier()
		}
		{
			p.SetState(1423)
			p.Match(SqlBaseParserT__5)
		}
		{
			p.SetState(1424)
			p.Expression()
		}

	case 16:
		localctx = NewLambdaContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1426)
			p.Match(SqlBaseParserT__1)
		}
		p.SetState(1435)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-10)&-(0x1f+1)) == 0 && ((1<<uint((_la-10)))&((1<<(SqlBaseParserADD-10))|(1<<(SqlBaseParserADMIN-10))|(1<<(SqlBaseParserALL-10))|(1<<(SqlBaseParserANALYZE-10))|(1<<(SqlBaseParserANY-10))|(1<<(SqlBaseParserARRAY-10))|(1<<(SqlBaseParserASC-10))|(1<<(SqlBaseParserAT-10))|(1<<(SqlBaseParserBERNOULLI-10))|(1<<(SqlBaseParserCALL-10))|(1<<(SqlBaseParserCALLED-10))|(1<<(SqlBaseParserCASCADE-10))|(1<<(SqlBaseParserCATALOGS-10))|(1<<(SqlBaseParserCOLUMN-10))|(1<<(SqlBaseParserCOLUMNS-10))|(1<<(SqlBaseParserCOMMENT-10))|(1<<(SqlBaseParserCOMMIT-10))|(1<<(SqlBaseParserCOMMITTED-10))|(1<<(SqlBaseParserCURRENT-10))|(1<<(SqlBaseParserCURRENT_ROLE-10)))) != 0) || (((_la-45)&-(0x1f+1)) == 0 && ((1<<uint((_la-45)))&((1<<(SqlBaseParserDATA-45))|(1<<(SqlBaseParserDATE-45))|(1<<(SqlBaseParserDAY-45))|(1<<(SqlBaseParserDEFINER-45))|(1<<(SqlBaseParserDESC-45))|(1<<(SqlBaseParserDETERMINISTIC-45))|(1<<(SqlBaseParserDISTRIBUTED-45))|(1<<(SqlBaseParserEXCLUDING-45))|(1<<(SqlBaseParserEXPLAIN-45))|(1<<(SqlBaseParserEXTERNAL-45))|(1<<(SqlBaseParserFILTER-45))|(1<<(SqlBaseParserFIRST-45))|(1<<(SqlBaseParserFOLLOWING-45))|(1<<(SqlBaseParserFORMAT-45))|(1<<(SqlBaseParserFUNCTION-45))|(1<<(SqlBaseParserFUNCTIONS-45)))) != 0) || (((_la-77)&-(0x1f+1)) == 0 && ((1<<uint((_la-77)))&((1<<(SqlBaseParserGRANT-77))|(1<<(SqlBaseParserGRANTED-77))|(1<<(SqlBaseParserGRANTS-77))|(1<<(SqlBaseParserGRAPHVIZ-77))|(1<<(SqlBaseParserHOUR-77))|(1<<(SqlBaseParserIF-77))|(1<<(SqlBaseParserIGNORE-77))|(1<<(SqlBaseParserINCLUDING-77))|(1<<(SqlBaseParserINPUT-77))|(1<<(SqlBaseParserINTERVAL-77))|(1<<(SqlBaseParserINVOKER-77))|(1<<(SqlBaseParserIO-77))|(1<<(SqlBaseParserISOLATION-77))|(1<<(SqlBaseParserJSON-77))|(1<<(SqlBaseParserLANGUAGE-77))|(1<<(SqlBaseParserLAST-77))|(1<<(SqlBaseParserLATERAL-77))|(1<<(SqlBaseParserLEVEL-77))|(1<<(SqlBaseParserLIMIT-77)))) != 0) || (((_la-110)&-(0x1f+1)) == 0 && ((1<<uint((_la-110)))&((1<<(SqlBaseParserLOGICAL-110))|(1<<(SqlBaseParserMAP-110))|(1<<(SqlBaseParserMATERIALIZED-110))|(1<<(SqlBaseParserMINUTE-110))|(1<<(SqlBaseParserMONTH-110))|(1<<(SqlBaseParserNAME-110))|(1<<(SqlBaseParserNFC-110))|(1<<(SqlBaseParserNFD-110))|(1<<(SqlBaseParserNFKC-110))|(1<<(SqlBaseParserNFKD-110))|(1<<(SqlBaseParserNO-110))|(1<<(SqlBaseParserNONE-110))|(1<<(SqlBaseParserNULLIF-110))|(1<<(SqlBaseParserNULLS-110))|(1<<(SqlBaseParserOFFSET-110))|(1<<(SqlBaseParserONLY-110))|(1<<(SqlBaseParserOPTION-110))|(1<<(SqlBaseParserORDINALITY-110))|(1<<(SqlBaseParserOUTPUT-110))|(1<<(SqlBaseParserOVER-110))|(1<<(SqlBaseParserPARTITION-110))|(1<<(SqlBaseParserPARTITIONS-110))|(1<<(SqlBaseParserPOSITION-110))|(1<<(SqlBaseParserPRECEDING-110)))) != 0) || (((_la-143)&-(0x1f+1)) == 0 && ((1<<uint((_la-143)))&((1<<(SqlBaseParserPRIVILEGES-143))|(1<<(SqlBaseParserPROPERTIES-143))|(1<<(SqlBaseParserRANGE-143))|(1<<(SqlBaseParserREAD-143))|(1<<(SqlBaseParserREFRESH-143))|(1<<(SqlBaseParserRENAME-143))|(1<<(SqlBaseParserREPEATABLE-143))|(1<<(SqlBaseParserREPLACE-143))|(1<<(SqlBaseParserRESET-143))|(1<<(SqlBaseParserRESPECT-143))|(1<<(SqlBaseParserRESTRICT-143))|(1<<(SqlBaseParserRETURN-143))|(1<<(SqlBaseParserRETURNS-143))|(1<<(SqlBaseParserREVOKE-143))|(1<<(SqlBaseParserROLE-143))|(1<<(SqlBaseParserROLES-143))|(1<<(SqlBaseParserROLLBACK-143))|(1<<(SqlBaseParserROW-143))|(1<<(SqlBaseParserROWS-143))|(1<<(SqlBaseParserSCHEMA-143))|(1<<(SqlBaseParserSCHEMAS-143))|(1<<(SqlBaseParserSECOND-143))|(1<<(SqlBaseParserSECURITY-143))|(1<<(SqlBaseParserSERIALIZABLE-143))|(1<<(SqlBaseParserSESSION-143))|(1<<(SqlBaseParserSET-143))|(1<<(SqlBaseParserSETS-143))|(1<<(SqlBaseParserSHOW-143)))) != 0) || (((_la-175)&-(0x1f+1)) == 0 && ((1<<uint((_la-175)))&((1<<(SqlBaseParserSOME-175))|(1<<(SqlBaseParserSQL-175))|(1<<(SqlBaseParserSTART-175))|(1<<(SqlBaseParserSTATS-175))|(1<<(SqlBaseParserSUBSTRING-175))|(1<<(SqlBaseParserSYSTEM-175))|(1<<(SqlBaseParserTABLES-175))|(1<<(SqlBaseParserTABLESAMPLE-175))|(1<<(SqlBaseParserTEMPORARY-175))|(1<<(SqlBaseParserTEXT-175))|(1<<(SqlBaseParserTIME-175))|(1<<(SqlBaseParserTIMESTAMP-175))|(1<<(SqlBaseParserTO-175))|(1<<(SqlBaseParserTRANSACTION-175))|(1<<(SqlBaseParserTRY_CAST-175))|(1<<(SqlBaseParserTYPE-175))|(1<<(SqlBaseParserUNBOUNDED-175))|(1<<(SqlBaseParserUNCOMMITTED-175))|(1<<(SqlBaseParserUSE-175))|(1<<(SqlBaseParserUSER-175))|(1<<(SqlBaseParserVALIDATE-175))|(1<<(SqlBaseParserVERBOSE-175))|(1<<(SqlBaseParserVIEW-175)))) != 0) || (((_la-209)&-(0x1f+1)) == 0 && ((1<<uint((_la-209)))&((1<<(SqlBaseParserWORK-209))|(1<<(SqlBaseParserWRITE-209))|(1<<(SqlBaseParserYEAR-209))|(1<<(SqlBaseParserZONE-209))|(1<<(SqlBaseParserIDENTIFIER-209))|(1<<(SqlBaseParserDIGIT_IDENTIFIER-209))|(1<<(SqlBaseParserQUOTED_IDENTIFIER-209))|(1<<(SqlBaseParserBACKQUOTED_IDENTIFIER-209)))) != 0) {
			{
				p.SetState(1427)
				p.Identifier()
			}
			p.SetState(1432)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__3 {
				{
					p.SetState(1428)
					p.Match(SqlBaseParserT__3)
				}
				{
					p.SetState(1429)
					p.Identifier()
				}

				p.SetState(1434)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(1437)
			p.Match(SqlBaseParserT__2)
		}
		{
			p.SetState(1438)
			p.Match(SqlBaseParserT__5)
		}
		{
			p.SetState(1439)
			p.Expression()
		}

	case 17:
		localctx = NewSubqueryExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1440)
			p.Match(SqlBaseParserT__1)
		}
		{
			p.SetState(1441)
			p.Query()
		}
		{
			p.SetState(1442)
			p.Match(SqlBaseParserT__2)
		}

	case 18:
		localctx = NewExistsContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1444)
			p.Match(SqlBaseParserEXISTS)
		}
		{
			p.SetState(1445)
			p.Match(SqlBaseParserT__1)
		}
		{
			p.SetState(1446)
			p.Query()
		}
		{
			p.SetState(1447)
			p.Match(SqlBaseParserT__2)
		}

	case 19:
		localctx = NewSimpleCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1449)
			p.Match(SqlBaseParserCASE)
		}
		{
			p.SetState(1450)
			p.valueExpression(0)
		}
		p.SetState(1452)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SqlBaseParserWHEN {
			{
				p.SetState(1451)
				p.WhenClause()
			}

			p.SetState(1454)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1458)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserELSE {
			{
				p.SetState(1456)
				p.Match(SqlBaseParserELSE)
			}
			{
				p.SetState(1457)

				var _x = p.Expression()

				localctx.(*SimpleCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(1460)
			p.Match(SqlBaseParserEND)
		}

	case 20:
		localctx = NewSearchedCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1462)
			p.Match(SqlBaseParserCASE)
		}
		p.SetState(1464)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SqlBaseParserWHEN {
			{
				p.SetState(1463)
				p.WhenClause()
			}

			p.SetState(1466)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1470)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserELSE {
			{
				p.SetState(1468)
				p.Match(SqlBaseParserELSE)
			}
			{
				p.SetState(1469)

				var _x = p.Expression()

				localctx.(*SearchedCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(1472)
			p.Match(SqlBaseParserEND)
		}

	case 21:
		localctx = NewCastContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1474)
			p.Match(SqlBaseParserCAST)
		}
		{
			p.SetState(1475)
			p.Match(SqlBaseParserT__1)
		}
		{
			p.SetState(1476)
			p.Expression()
		}
		{
			p.SetState(1477)
			p.Match(SqlBaseParserAS)
		}
		{
			p.SetState(1478)
			p.type_(0)
		}
		{
			p.SetState(1479)
			p.Match(SqlBaseParserT__2)
		}

	case 22:
		localctx = NewCastContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1481)
			p.Match(SqlBaseParserTRY_CAST)
		}
		{
			p.SetState(1482)
			p.Match(SqlBaseParserT__1)
		}
		{
			p.SetState(1483)
			p.Expression()
		}
		{
			p.SetState(1484)
			p.Match(SqlBaseParserAS)
		}
		{
			p.SetState(1485)
			p.type_(0)
		}
		{
			p.SetState(1486)
			p.Match(SqlBaseParserT__2)
		}

	case 23:
		localctx = NewArrayConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1488)
			p.Match(SqlBaseParserARRAY)
		}
		{
			p.SetState(1489)
			p.Match(SqlBaseParserT__6)
		}
		p.SetState(1498)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SqlBaseParserT__1)|(1<<SqlBaseParserT__4)|(1<<SqlBaseParserADD)|(1<<SqlBaseParserADMIN)|(1<<SqlBaseParserALL)|(1<<SqlBaseParserANALYZE)|(1<<SqlBaseParserANY)|(1<<SqlBaseParserARRAY)|(1<<SqlBaseParserASC)|(1<<SqlBaseParserAT)|(1<<SqlBaseParserBERNOULLI)|(1<<SqlBaseParserCALL)|(1<<SqlBaseParserCALLED)|(1<<SqlBaseParserCASCADE)|(1<<SqlBaseParserCASE)|(1<<SqlBaseParserCAST)|(1<<SqlBaseParserCATALOGS)|(1<<SqlBaseParserCOLUMN)|(1<<SqlBaseParserCOLUMNS))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(SqlBaseParserCOMMENT-32))|(1<<(SqlBaseParserCOMMIT-32))|(1<<(SqlBaseParserCOMMITTED-32))|(1<<(SqlBaseParserCURRENT-32))|(1<<(SqlBaseParserCURRENT_DATE-32))|(1<<(SqlBaseParserCURRENT_ROLE-32))|(1<<(SqlBaseParserCURRENT_TIME-32))|(1<<(SqlBaseParserCURRENT_TIMESTAMP-32))|(1<<(SqlBaseParserCURRENT_USER-32))|(1<<(SqlBaseParserDATA-32))|(1<<(SqlBaseParserDATE-32))|(1<<(SqlBaseParserDAY-32))|(1<<(SqlBaseParserDEFINER-32))|(1<<(SqlBaseParserDESC-32))|(1<<(SqlBaseParserDETERMINISTIC-32))|(1<<(SqlBaseParserDISTRIBUTED-32))|(1<<(SqlBaseParserEXCLUDING-32))|(1<<(SqlBaseParserEXISTS-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(SqlBaseParserEXPLAIN-64))|(1<<(SqlBaseParserEXTRACT-64))|(1<<(SqlBaseParserEXTERNAL-64))|(1<<(SqlBaseParserFALSE-64))|(1<<(SqlBaseParserFILTER-64))|(1<<(SqlBaseParserFIRST-64))|(1<<(SqlBaseParserFOLLOWING-64))|(1<<(SqlBaseParserFORMAT-64))|(1<<(SqlBaseParserFUNCTION-64))|(1<<(SqlBaseParserFUNCTIONS-64))|(1<<(SqlBaseParserGRANT-64))|(1<<(SqlBaseParserGRANTED-64))|(1<<(SqlBaseParserGRANTS-64))|(1<<(SqlBaseParserGRAPHVIZ-64))|(1<<(SqlBaseParserGROUPING-64))|(1<<(SqlBaseParserHOUR-64))|(1<<(SqlBaseParserIF-64))|(1<<(SqlBaseParserIGNORE-64))|(1<<(SqlBaseParserINCLUDING-64))|(1<<(SqlBaseParserINPUT-64))|(1<<(SqlBaseParserINTERVAL-64))|(1<<(SqlBaseParserINVOKER-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(SqlBaseParserIO-96))|(1<<(SqlBaseParserISOLATION-96))|(1<<(SqlBaseParserJSON-96))|(1<<(SqlBaseParserLANGUAGE-96))|(1<<(SqlBaseParserLAST-96))|(1<<(SqlBaseParserLATERAL-96))|(1<<(SqlBaseParserLEVEL-96))|(1<<(SqlBaseParserLIMIT-96))|(1<<(SqlBaseParserLOCALTIME-96))|(1<<(SqlBaseParserLOCALTIMESTAMP-96))|(1<<(SqlBaseParserLOGICAL-96))|(1<<(SqlBaseParserMAP-96))|(1<<(SqlBaseParserMATERIALIZED-96))|(1<<(SqlBaseParserMINUTE-96))|(1<<(SqlBaseParserMONTH-96))|(1<<(SqlBaseParserNAME-96))|(1<<(SqlBaseParserNFC-96))|(1<<(SqlBaseParserNFD-96))|(1<<(SqlBaseParserNFKC-96))|(1<<(SqlBaseParserNFKD-96))|(1<<(SqlBaseParserNO-96))|(1<<(SqlBaseParserNONE-96))|(1<<(SqlBaseParserNORMALIZE-96))|(1<<(SqlBaseParserNOT-96))|(1<<(SqlBaseParserNULL-96))|(1<<(SqlBaseParserNULLIF-96))|(1<<(SqlBaseParserNULLS-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(SqlBaseParserOFFSET-128))|(1<<(SqlBaseParserONLY-128))|(1<<(SqlBaseParserOPTION-128))|(1<<(SqlBaseParserORDINALITY-128))|(1<<(SqlBaseParserOUTPUT-128))|(1<<(SqlBaseParserOVER-128))|(1<<(SqlBaseParserPARTITION-128))|(1<<(SqlBaseParserPARTITIONS-128))|(1<<(SqlBaseParserPOSITION-128))|(1<<(SqlBaseParserPRECEDING-128))|(1<<(SqlBaseParserPRIVILEGES-128))|(1<<(SqlBaseParserPROPERTIES-128))|(1<<(SqlBaseParserRANGE-128))|(1<<(SqlBaseParserREAD-128))|(1<<(SqlBaseParserREFRESH-128))|(1<<(SqlBaseParserRENAME-128))|(1<<(SqlBaseParserREPEATABLE-128))|(1<<(SqlBaseParserREPLACE-128))|(1<<(SqlBaseParserRESET-128))|(1<<(SqlBaseParserRESPECT-128))|(1<<(SqlBaseParserRESTRICT-128))|(1<<(SqlBaseParserRETURN-128))|(1<<(SqlBaseParserRETURNS-128))|(1<<(SqlBaseParserREVOKE-128))|(1<<(SqlBaseParserROLE-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(SqlBaseParserROLES-160))|(1<<(SqlBaseParserROLLBACK-160))|(1<<(SqlBaseParserROW-160))|(1<<(SqlBaseParserROWS-160))|(1<<(SqlBaseParserSCHEMA-160))|(1<<(SqlBaseParserSCHEMAS-160))|(1<<(SqlBaseParserSECOND-160))|(1<<(SqlBaseParserSECURITY-160))|(1<<(SqlBaseParserSERIALIZABLE-160))|(1<<(SqlBaseParserSESSION-160))|(1<<(SqlBaseParserSET-160))|(1<<(SqlBaseParserSETS-160))|(1<<(SqlBaseParserSHOW-160))|(1<<(SqlBaseParserSOME-160))|(1<<(SqlBaseParserSQL-160))|(1<<(SqlBaseParserSTART-160))|(1<<(SqlBaseParserSTATS-160))|(1<<(SqlBaseParserSUBSTRING-160))|(1<<(SqlBaseParserSYSTEM-160))|(1<<(SqlBaseParserTABLES-160))|(1<<(SqlBaseParserTABLESAMPLE-160))|(1<<(SqlBaseParserTEMPORARY-160))|(1<<(SqlBaseParserTEXT-160))|(1<<(SqlBaseParserTIME-160))|(1<<(SqlBaseParserTIMESTAMP-160))|(1<<(SqlBaseParserTO-160))|(1<<(SqlBaseParserTRANSACTION-160))|(1<<(SqlBaseParserTRUE-160)))) != 0) || (((_la-192)&-(0x1f+1)) == 0 && ((1<<uint((_la-192)))&((1<<(SqlBaseParserTRY_CAST-192))|(1<<(SqlBaseParserTYPE-192))|(1<<(SqlBaseParserUNBOUNDED-192))|(1<<(SqlBaseParserUNCOMMITTED-192))|(1<<(SqlBaseParserUSE-192))|(1<<(SqlBaseParserUSER-192))|(1<<(SqlBaseParserVALIDATE-192))|(1<<(SqlBaseParserVERBOSE-192))|(1<<(SqlBaseParserVIEW-192))|(1<<(SqlBaseParserWORK-192))|(1<<(SqlBaseParserWRITE-192))|(1<<(SqlBaseParserYEAR-192))|(1<<(SqlBaseParserZONE-192))|(1<<(SqlBaseParserPLUS-192))|(1<<(SqlBaseParserMINUS-192)))) != 0) || (((_la-225)&-(0x1f+1)) == 0 && ((1<<uint((_la-225)))&((1<<(SqlBaseParserSTRING-225))|(1<<(SqlBaseParserUNICODE_STRING-225))|(1<<(SqlBaseParserBINARY_LITERAL-225))|(1<<(SqlBaseParserINTEGER_VALUE-225))|(1<<(SqlBaseParserDECIMAL_VALUE-225))|(1<<(SqlBaseParserDOUBLE_VALUE-225))|(1<<(SqlBaseParserIDENTIFIER-225))|(1<<(SqlBaseParserDIGIT_IDENTIFIER-225))|(1<<(SqlBaseParserQUOTED_IDENTIFIER-225))|(1<<(SqlBaseParserBACKQUOTED_IDENTIFIER-225))|(1<<(SqlBaseParserDOUBLE_PRECISION-225)))) != 0) {
			{
				p.SetState(1490)
				p.Expression()
			}
			p.SetState(1495)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__3 {
				{
					p.SetState(1491)
					p.Match(SqlBaseParserT__3)
				}
				{
					p.SetState(1492)
					p.Expression()
				}

				p.SetState(1497)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(1500)
			p.Match(SqlBaseParserT__7)
		}

	case 24:
		localctx = NewColumnReferenceContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1501)
			p.Identifier()
		}

	case 25:
		localctx = NewSpecialDateTimeFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1502)

			var _m = p.Match(SqlBaseParserCURRENT_DATE)

			localctx.(*SpecialDateTimeFunctionContext).name = _m
		}

	case 26:
		localctx = NewSpecialDateTimeFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1503)

			var _m = p.Match(SqlBaseParserCURRENT_TIME)

			localctx.(*SpecialDateTimeFunctionContext).name = _m
		}
		p.SetState(1507)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 194, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1504)
				p.Match(SqlBaseParserT__1)
			}
			{
				p.SetState(1505)

				var _m = p.Match(SqlBaseParserINTEGER_VALUE)

				localctx.(*SpecialDateTimeFunctionContext).precision = _m
			}
			{
				p.SetState(1506)
				p.Match(SqlBaseParserT__2)
			}

		}

	case 27:
		localctx = NewSpecialDateTimeFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1509)

			var _m = p.Match(SqlBaseParserCURRENT_TIMESTAMP)

			localctx.(*SpecialDateTimeFunctionContext).name = _m
		}
		p.SetState(1513)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 195, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1510)
				p.Match(SqlBaseParserT__1)
			}
			{
				p.SetState(1511)

				var _m = p.Match(SqlBaseParserINTEGER_VALUE)

				localctx.(*SpecialDateTimeFunctionContext).precision = _m
			}
			{
				p.SetState(1512)
				p.Match(SqlBaseParserT__2)
			}

		}

	case 28:
		localctx = NewSpecialDateTimeFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1515)

			var _m = p.Match(SqlBaseParserLOCALTIME)

			localctx.(*SpecialDateTimeFunctionContext).name = _m
		}
		p.SetState(1519)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 196, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1516)
				p.Match(SqlBaseParserT__1)
			}
			{
				p.SetState(1517)

				var _m = p.Match(SqlBaseParserINTEGER_VALUE)

				localctx.(*SpecialDateTimeFunctionContext).precision = _m
			}
			{
				p.SetState(1518)
				p.Match(SqlBaseParserT__2)
			}

		}

	case 29:
		localctx = NewSpecialDateTimeFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1521)

			var _m = p.Match(SqlBaseParserLOCALTIMESTAMP)

			localctx.(*SpecialDateTimeFunctionContext).name = _m
		}
		p.SetState(1525)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 197, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1522)
				p.Match(SqlBaseParserT__1)
			}
			{
				p.SetState(1523)

				var _m = p.Match(SqlBaseParserINTEGER_VALUE)

				localctx.(*SpecialDateTimeFunctionContext).precision = _m
			}
			{
				p.SetState(1524)
				p.Match(SqlBaseParserT__2)
			}

		}

	case 30:
		localctx = NewCurrentUserContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1527)

			var _m = p.Match(SqlBaseParserCURRENT_USER)

			localctx.(*CurrentUserContext).name = _m
		}

	case 31:
		localctx = NewSubstringContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1528)
			p.Match(SqlBaseParserSUBSTRING)
		}
		{
			p.SetState(1529)
			p.Match(SqlBaseParserT__1)
		}
		{
			p.SetState(1530)
			p.valueExpression(0)
		}
		{
			p.SetState(1531)
			p.Match(SqlBaseParserFROM)
		}
		{
			p.SetState(1532)
			p.valueExpression(0)
		}
		p.SetState(1535)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserFOR {
			{
				p.SetState(1533)
				p.Match(SqlBaseParserFOR)
			}
			{
				p.SetState(1534)
				p.valueExpression(0)
			}

		}
		{
			p.SetState(1537)
			p.Match(SqlBaseParserT__2)
		}

	case 32:
		localctx = NewNormalizeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1539)
			p.Match(SqlBaseParserNORMALIZE)
		}
		{
			p.SetState(1540)
			p.Match(SqlBaseParserT__1)
		}
		{
			p.SetState(1541)
			p.valueExpression(0)
		}
		p.SetState(1544)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserT__3 {
			{
				p.SetState(1542)
				p.Match(SqlBaseParserT__3)
			}
			{
				p.SetState(1543)
				p.NormalForm()
			}

		}
		{
			p.SetState(1546)
			p.Match(SqlBaseParserT__2)
		}

	case 33:
		localctx = NewExtractContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1548)
			p.Match(SqlBaseParserEXTRACT)
		}
		{
			p.SetState(1549)
			p.Match(SqlBaseParserT__1)
		}
		{
			p.SetState(1550)
			p.Identifier()
		}
		{
			p.SetState(1551)
			p.Match(SqlBaseParserFROM)
		}
		{
			p.SetState(1552)
			p.valueExpression(0)
		}
		{
			p.SetState(1553)
			p.Match(SqlBaseParserT__2)
		}

	case 34:
		localctx = NewParenthesizedExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1555)
			p.Match(SqlBaseParserT__1)
		}
		{
			p.SetState(1556)
			p.Expression()
		}
		{
			p.SetState(1557)
			p.Match(SqlBaseParserT__2)
		}

	case 35:
		localctx = NewGroupingOperationContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1559)
			p.Match(SqlBaseParserGROUPING)
		}
		{
			p.SetState(1560)
			p.Match(SqlBaseParserT__1)
		}
		p.SetState(1569)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-10)&-(0x1f+1)) == 0 && ((1<<uint((_la-10)))&((1<<(SqlBaseParserADD-10))|(1<<(SqlBaseParserADMIN-10))|(1<<(SqlBaseParserALL-10))|(1<<(SqlBaseParserANALYZE-10))|(1<<(SqlBaseParserANY-10))|(1<<(SqlBaseParserARRAY-10))|(1<<(SqlBaseParserASC-10))|(1<<(SqlBaseParserAT-10))|(1<<(SqlBaseParserBERNOULLI-10))|(1<<(SqlBaseParserCALL-10))|(1<<(SqlBaseParserCALLED-10))|(1<<(SqlBaseParserCASCADE-10))|(1<<(SqlBaseParserCATALOGS-10))|(1<<(SqlBaseParserCOLUMN-10))|(1<<(SqlBaseParserCOLUMNS-10))|(1<<(SqlBaseParserCOMMENT-10))|(1<<(SqlBaseParserCOMMIT-10))|(1<<(SqlBaseParserCOMMITTED-10))|(1<<(SqlBaseParserCURRENT-10))|(1<<(SqlBaseParserCURRENT_ROLE-10)))) != 0) || (((_la-45)&-(0x1f+1)) == 0 && ((1<<uint((_la-45)))&((1<<(SqlBaseParserDATA-45))|(1<<(SqlBaseParserDATE-45))|(1<<(SqlBaseParserDAY-45))|(1<<(SqlBaseParserDEFINER-45))|(1<<(SqlBaseParserDESC-45))|(1<<(SqlBaseParserDETERMINISTIC-45))|(1<<(SqlBaseParserDISTRIBUTED-45))|(1<<(SqlBaseParserEXCLUDING-45))|(1<<(SqlBaseParserEXPLAIN-45))|(1<<(SqlBaseParserEXTERNAL-45))|(1<<(SqlBaseParserFILTER-45))|(1<<(SqlBaseParserFIRST-45))|(1<<(SqlBaseParserFOLLOWING-45))|(1<<(SqlBaseParserFORMAT-45))|(1<<(SqlBaseParserFUNCTION-45))|(1<<(SqlBaseParserFUNCTIONS-45)))) != 0) || (((_la-77)&-(0x1f+1)) == 0 && ((1<<uint((_la-77)))&((1<<(SqlBaseParserGRANT-77))|(1<<(SqlBaseParserGRANTED-77))|(1<<(SqlBaseParserGRANTS-77))|(1<<(SqlBaseParserGRAPHVIZ-77))|(1<<(SqlBaseParserHOUR-77))|(1<<(SqlBaseParserIF-77))|(1<<(SqlBaseParserIGNORE-77))|(1<<(SqlBaseParserINCLUDING-77))|(1<<(SqlBaseParserINPUT-77))|(1<<(SqlBaseParserINTERVAL-77))|(1<<(SqlBaseParserINVOKER-77))|(1<<(SqlBaseParserIO-77))|(1<<(SqlBaseParserISOLATION-77))|(1<<(SqlBaseParserJSON-77))|(1<<(SqlBaseParserLANGUAGE-77))|(1<<(SqlBaseParserLAST-77))|(1<<(SqlBaseParserLATERAL-77))|(1<<(SqlBaseParserLEVEL-77))|(1<<(SqlBaseParserLIMIT-77)))) != 0) || (((_la-110)&-(0x1f+1)) == 0 && ((1<<uint((_la-110)))&((1<<(SqlBaseParserLOGICAL-110))|(1<<(SqlBaseParserMAP-110))|(1<<(SqlBaseParserMATERIALIZED-110))|(1<<(SqlBaseParserMINUTE-110))|(1<<(SqlBaseParserMONTH-110))|(1<<(SqlBaseParserNAME-110))|(1<<(SqlBaseParserNFC-110))|(1<<(SqlBaseParserNFD-110))|(1<<(SqlBaseParserNFKC-110))|(1<<(SqlBaseParserNFKD-110))|(1<<(SqlBaseParserNO-110))|(1<<(SqlBaseParserNONE-110))|(1<<(SqlBaseParserNULLIF-110))|(1<<(SqlBaseParserNULLS-110))|(1<<(SqlBaseParserOFFSET-110))|(1<<(SqlBaseParserONLY-110))|(1<<(SqlBaseParserOPTION-110))|(1<<(SqlBaseParserORDINALITY-110))|(1<<(SqlBaseParserOUTPUT-110))|(1<<(SqlBaseParserOVER-110))|(1<<(SqlBaseParserPARTITION-110))|(1<<(SqlBaseParserPARTITIONS-110))|(1<<(SqlBaseParserPOSITION-110))|(1<<(SqlBaseParserPRECEDING-110)))) != 0) || (((_la-143)&-(0x1f+1)) == 0 && ((1<<uint((_la-143)))&((1<<(SqlBaseParserPRIVILEGES-143))|(1<<(SqlBaseParserPROPERTIES-143))|(1<<(SqlBaseParserRANGE-143))|(1<<(SqlBaseParserREAD-143))|(1<<(SqlBaseParserREFRESH-143))|(1<<(SqlBaseParserRENAME-143))|(1<<(SqlBaseParserREPEATABLE-143))|(1<<(SqlBaseParserREPLACE-143))|(1<<(SqlBaseParserRESET-143))|(1<<(SqlBaseParserRESPECT-143))|(1<<(SqlBaseParserRESTRICT-143))|(1<<(SqlBaseParserRETURN-143))|(1<<(SqlBaseParserRETURNS-143))|(1<<(SqlBaseParserREVOKE-143))|(1<<(SqlBaseParserROLE-143))|(1<<(SqlBaseParserROLES-143))|(1<<(SqlBaseParserROLLBACK-143))|(1<<(SqlBaseParserROW-143))|(1<<(SqlBaseParserROWS-143))|(1<<(SqlBaseParserSCHEMA-143))|(1<<(SqlBaseParserSCHEMAS-143))|(1<<(SqlBaseParserSECOND-143))|(1<<(SqlBaseParserSECURITY-143))|(1<<(SqlBaseParserSERIALIZABLE-143))|(1<<(SqlBaseParserSESSION-143))|(1<<(SqlBaseParserSET-143))|(1<<(SqlBaseParserSETS-143))|(1<<(SqlBaseParserSHOW-143)))) != 0) || (((_la-175)&-(0x1f+1)) == 0 && ((1<<uint((_la-175)))&((1<<(SqlBaseParserSOME-175))|(1<<(SqlBaseParserSQL-175))|(1<<(SqlBaseParserSTART-175))|(1<<(SqlBaseParserSTATS-175))|(1<<(SqlBaseParserSUBSTRING-175))|(1<<(SqlBaseParserSYSTEM-175))|(1<<(SqlBaseParserTABLES-175))|(1<<(SqlBaseParserTABLESAMPLE-175))|(1<<(SqlBaseParserTEMPORARY-175))|(1<<(SqlBaseParserTEXT-175))|(1<<(SqlBaseParserTIME-175))|(1<<(SqlBaseParserTIMESTAMP-175))|(1<<(SqlBaseParserTO-175))|(1<<(SqlBaseParserTRANSACTION-175))|(1<<(SqlBaseParserTRY_CAST-175))|(1<<(SqlBaseParserTYPE-175))|(1<<(SqlBaseParserUNBOUNDED-175))|(1<<(SqlBaseParserUNCOMMITTED-175))|(1<<(SqlBaseParserUSE-175))|(1<<(SqlBaseParserUSER-175))|(1<<(SqlBaseParserVALIDATE-175))|(1<<(SqlBaseParserVERBOSE-175))|(1<<(SqlBaseParserVIEW-175)))) != 0) || (((_la-209)&-(0x1f+1)) == 0 && ((1<<uint((_la-209)))&((1<<(SqlBaseParserWORK-209))|(1<<(SqlBaseParserWRITE-209))|(1<<(SqlBaseParserYEAR-209))|(1<<(SqlBaseParserZONE-209))|(1<<(SqlBaseParserIDENTIFIER-209))|(1<<(SqlBaseParserDIGIT_IDENTIFIER-209))|(1<<(SqlBaseParserQUOTED_IDENTIFIER-209))|(1<<(SqlBaseParserBACKQUOTED_IDENTIFIER-209)))) != 0) {
			{
				p.SetState(1561)
				p.QualifiedName()
			}
			p.SetState(1566)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__3 {
				{
					p.SetState(1562)
					p.Match(SqlBaseParserT__3)
				}
				{
					p.SetState(1563)
					p.QualifiedName()
				}

				p.SetState(1568)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(1571)
			p.Match(SqlBaseParserT__2)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1584)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 204, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1582)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 203, p.GetParserRuleContext()) {
			case 1:
				localctx = NewSubscriptContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*SubscriptContext).value = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_primaryExpression)
				p.SetState(1574)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
				}
				{
					p.SetState(1575)
					p.Match(SqlBaseParserT__6)
				}
				{
					p.SetState(1576)

					var _x = p.valueExpression(0)

					localctx.(*SubscriptContext).index = _x
				}
				{
					p.SetState(1577)
					p.Match(SqlBaseParserT__7)
				}

			case 2:
				localctx = NewDereferenceContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*DereferenceContext).base = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_primaryExpression)
				p.SetState(1579)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
				}
				{
					p.SetState(1580)
					p.Match(SqlBaseParserT__0)
				}
				{
					p.SetState(1581)

					var _x = p.Identifier()

					localctx.(*DereferenceContext).fieldName = _x
				}

			}

		}
		p.SetState(1586)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 204, p.GetParserRuleContext())
	}

	return localctx
}

// IString_Context is an interface to support dynamic dispatch.
type IString_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsString_Context differentiates from other interfaces.
	IsString_Context()
}

type String_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyString_Context() *String_Context {
	var p = new(String_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_string_
	return p
}

func (*String_Context) IsString_Context() {}

func NewString_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *String_Context {
	var p = new(String_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_string_

	return p
}

func (s *String_Context) GetParser() antlr.Parser { return s.parser }

func (s *String_Context) CopyFrom(ctx *String_Context) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *String_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *String_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UnicodeStringLiteralContext struct {
	*String_Context
}

func NewUnicodeStringLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnicodeStringLiteralContext {
	var p = new(UnicodeStringLiteralContext)

	p.String_Context = NewEmptyString_Context()
	p.parser = parser
	p.CopyFrom(ctx.(*String_Context))

	return p
}

func (s *UnicodeStringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnicodeStringLiteralContext) UNICODE_STRING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNICODE_STRING, 0)
}

func (s *UnicodeStringLiteralContext) UESCAPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUESCAPE, 0)
}

func (s *UnicodeStringLiteralContext) STRING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTRING, 0)
}

func (s *UnicodeStringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterUnicodeStringLiteral(s)
	}
}

func (s *UnicodeStringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitUnicodeStringLiteral(s)
	}
}

func (s *UnicodeStringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitUnicodeStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type BasicStringLiteralContext struct {
	*String_Context
}

func NewBasicStringLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BasicStringLiteralContext {
	var p = new(BasicStringLiteralContext)

	p.String_Context = NewEmptyString_Context()
	p.parser = parser
	p.CopyFrom(ctx.(*String_Context))

	return p
}

func (s *BasicStringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BasicStringLiteralContext) STRING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTRING, 0)
}

func (s *BasicStringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterBasicStringLiteral(s)
	}
}

func (s *BasicStringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitBasicStringLiteral(s)
	}
}

func (s *BasicStringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitBasicStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) String_() (localctx IString_Context) {
	localctx = NewString_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, SqlBaseParserRULE_string_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1593)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserSTRING:
		localctx = NewBasicStringLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1587)
			p.Match(SqlBaseParserSTRING)
		}

	case SqlBaseParserUNICODE_STRING:
		localctx = NewUnicodeStringLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1588)
			p.Match(SqlBaseParserUNICODE_STRING)
		}
		p.SetState(1591)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 205, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1589)
				p.Match(SqlBaseParserUESCAPE)
			}
			{
				p.SetState(1590)
				p.Match(SqlBaseParserSTRING)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INullTreatmentContext is an interface to support dynamic dispatch.
type INullTreatmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNullTreatmentContext differentiates from other interfaces.
	IsNullTreatmentContext()
}

type NullTreatmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullTreatmentContext() *NullTreatmentContext {
	var p = new(NullTreatmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_nullTreatment
	return p
}

func (*NullTreatmentContext) IsNullTreatmentContext() {}

func NewNullTreatmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullTreatmentContext {
	var p = new(NullTreatmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_nullTreatment

	return p
}

func (s *NullTreatmentContext) GetParser() antlr.Parser { return s.parser }

func (s *NullTreatmentContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIGNORE, 0)
}

func (s *NullTreatmentContext) NULLS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULLS, 0)
}

func (s *NullTreatmentContext) RESPECT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRESPECT, 0)
}

func (s *NullTreatmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullTreatmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullTreatmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterNullTreatment(s)
	}
}

func (s *NullTreatmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitNullTreatment(s)
	}
}

func (s *NullTreatmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitNullTreatment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) NullTreatment() (localctx INullTreatmentContext) {
	localctx = NewNullTreatmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, SqlBaseParserRULE_nullTreatment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1599)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserIGNORE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1595)
			p.Match(SqlBaseParserIGNORE)
		}
		{
			p.SetState(1596)
			p.Match(SqlBaseParserNULLS)
		}

	case SqlBaseParserRESPECT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1597)
			p.Match(SqlBaseParserRESPECT)
		}
		{
			p.SetState(1598)
			p.Match(SqlBaseParserNULLS)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITimeZoneSpecifierContext is an interface to support dynamic dispatch.
type ITimeZoneSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTimeZoneSpecifierContext differentiates from other interfaces.
	IsTimeZoneSpecifierContext()
}

type TimeZoneSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimeZoneSpecifierContext() *TimeZoneSpecifierContext {
	var p = new(TimeZoneSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_timeZoneSpecifier
	return p
}

func (*TimeZoneSpecifierContext) IsTimeZoneSpecifierContext() {}

func NewTimeZoneSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimeZoneSpecifierContext {
	var p = new(TimeZoneSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_timeZoneSpecifier

	return p
}

func (s *TimeZoneSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TimeZoneSpecifierContext) CopyFrom(ctx *TimeZoneSpecifierContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *TimeZoneSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeZoneSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TimeZoneIntervalContext struct {
	*TimeZoneSpecifierContext
}

func NewTimeZoneIntervalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TimeZoneIntervalContext {
	var p = new(TimeZoneIntervalContext)

	p.TimeZoneSpecifierContext = NewEmptyTimeZoneSpecifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TimeZoneSpecifierContext))

	return p
}

func (s *TimeZoneIntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeZoneIntervalContext) TIME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIME, 0)
}

func (s *TimeZoneIntervalContext) ZONE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserZONE, 0)
}

func (s *TimeZoneIntervalContext) Interval() IIntervalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntervalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *TimeZoneIntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterTimeZoneInterval(s)
	}
}

func (s *TimeZoneIntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitTimeZoneInterval(s)
	}
}

func (s *TimeZoneIntervalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitTimeZoneInterval(s)

	default:
		return t.VisitChildren(s)
	}
}

type TimeZoneStringContext struct {
	*TimeZoneSpecifierContext
}

func NewTimeZoneStringContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TimeZoneStringContext {
	var p = new(TimeZoneStringContext)

	p.TimeZoneSpecifierContext = NewEmptyTimeZoneSpecifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TimeZoneSpecifierContext))

	return p
}

func (s *TimeZoneStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeZoneStringContext) TIME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIME, 0)
}

func (s *TimeZoneStringContext) ZONE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserZONE, 0)
}

func (s *TimeZoneStringContext) String_() IString_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *TimeZoneStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterTimeZoneString(s)
	}
}

func (s *TimeZoneStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitTimeZoneString(s)
	}
}

func (s *TimeZoneStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitTimeZoneString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) TimeZoneSpecifier() (localctx ITimeZoneSpecifierContext) {
	localctx = NewTimeZoneSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, SqlBaseParserRULE_timeZoneSpecifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1607)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 208, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTimeZoneIntervalContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1601)
			p.Match(SqlBaseParserTIME)
		}
		{
			p.SetState(1602)
			p.Match(SqlBaseParserZONE)
		}
		{
			p.SetState(1603)
			p.Interval()
		}

	case 2:
		localctx = NewTimeZoneStringContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1604)
			p.Match(SqlBaseParserTIME)
		}
		{
			p.SetState(1605)
			p.Match(SqlBaseParserZONE)
		}
		{
			p.SetState(1606)
			p.String_()
		}

	}

	return localctx
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_comparisonOperator
	return p
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) EQ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEQ, 0)
}

func (s *ComparisonOperatorContext) NEQ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNEQ, 0)
}

func (s *ComparisonOperatorContext) LT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLT, 0)
}

func (s *ComparisonOperatorContext) LTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLTE, 0)
}

func (s *ComparisonOperatorContext) GT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGT, 0)
}

func (s *ComparisonOperatorContext) GTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGTE, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitComparisonOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, SqlBaseParserRULE_comparisonOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1609)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(SqlBaseParserEQ-213))|(1<<(SqlBaseParserNEQ-213))|(1<<(SqlBaseParserLT-213))|(1<<(SqlBaseParserLTE-213))|(1<<(SqlBaseParserGT-213))|(1<<(SqlBaseParserGTE-213)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IComparisonQuantifierContext is an interface to support dynamic dispatch.
type IComparisonQuantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComparisonQuantifierContext differentiates from other interfaces.
	IsComparisonQuantifierContext()
}

type ComparisonQuantifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonQuantifierContext() *ComparisonQuantifierContext {
	var p = new(ComparisonQuantifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_comparisonQuantifier
	return p
}

func (*ComparisonQuantifierContext) IsComparisonQuantifierContext() {}

func NewComparisonQuantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonQuantifierContext {
	var p = new(ComparisonQuantifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_comparisonQuantifier

	return p
}

func (s *ComparisonQuantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonQuantifierContext) ALL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALL, 0)
}

func (s *ComparisonQuantifierContext) SOME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSOME, 0)
}

func (s *ComparisonQuantifierContext) ANY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserANY, 0)
}

func (s *ComparisonQuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonQuantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonQuantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterComparisonQuantifier(s)
	}
}

func (s *ComparisonQuantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitComparisonQuantifier(s)
	}
}

func (s *ComparisonQuantifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitComparisonQuantifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) ComparisonQuantifier() (localctx IComparisonQuantifierContext) {
	localctx = NewComparisonQuantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, SqlBaseParserRULE_comparisonQuantifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1611)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBaseParserALL || _la == SqlBaseParserANY || _la == SqlBaseParserSOME) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBooleanValueContext is an interface to support dynamic dispatch.
type IBooleanValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBooleanValueContext differentiates from other interfaces.
	IsBooleanValueContext()
}

type BooleanValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanValueContext() *BooleanValueContext {
	var p = new(BooleanValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_booleanValue
	return p
}

func (*BooleanValueContext) IsBooleanValueContext() {}

func NewBooleanValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanValueContext {
	var p = new(BooleanValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_booleanValue

	return p
}

func (s *BooleanValueContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanValueContext) TRUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRUE, 0)
}

func (s *BooleanValueContext) FALSE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFALSE, 0)
}

func (s *BooleanValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterBooleanValue(s)
	}
}

func (s *BooleanValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitBooleanValue(s)
	}
}

func (s *BooleanValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitBooleanValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) BooleanValue() (localctx IBooleanValueContext) {
	localctx = NewBooleanValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, SqlBaseParserRULE_booleanValue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1613)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBaseParserFALSE || _la == SqlBaseParserTRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IIntervalContext is an interface to support dynamic dispatch.
type IIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSign returns the sign token.
	GetSign() antlr.Token

	// SetSign sets the sign token.
	SetSign(antlr.Token)

	// GetFrom returns the from rule contexts.
	GetFrom() IIntervalFieldContext

	// GetTo returns the to rule contexts.
	GetTo() IIntervalFieldContext

	// SetFrom sets the from rule contexts.
	SetFrom(IIntervalFieldContext)

	// SetTo sets the to rule contexts.
	SetTo(IIntervalFieldContext)

	// IsIntervalContext differentiates from other interfaces.
	IsIntervalContext()
}

type IntervalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	sign   antlr.Token
	from   IIntervalFieldContext
	to     IIntervalFieldContext
}

func NewEmptyIntervalContext() *IntervalContext {
	var p = new(IntervalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_interval
	return p
}

func (*IntervalContext) IsIntervalContext() {}

func NewIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalContext {
	var p = new(IntervalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_interval

	return p
}

func (s *IntervalContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalContext) GetSign() antlr.Token { return s.sign }

func (s *IntervalContext) SetSign(v antlr.Token) { s.sign = v }

func (s *IntervalContext) GetFrom() IIntervalFieldContext { return s.from }

func (s *IntervalContext) GetTo() IIntervalFieldContext { return s.to }

func (s *IntervalContext) SetFrom(v IIntervalFieldContext) { s.from = v }

func (s *IntervalContext) SetTo(v IIntervalFieldContext) { s.to = v }

func (s *IntervalContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTERVAL, 0)
}

func (s *IntervalContext) String_() IString_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *IntervalContext) AllIntervalField() []IIntervalFieldContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIntervalFieldContext)(nil)).Elem())
	var tst = make([]IIntervalFieldContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIntervalFieldContext)
		}
	}

	return tst
}

func (s *IntervalContext) IntervalField(i int) IIntervalFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntervalFieldContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIntervalFieldContext)
}

func (s *IntervalContext) TO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTO, 0)
}

func (s *IntervalContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPLUS, 0)
}

func (s *IntervalContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUS, 0)
}

func (s *IntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterInterval(s)
	}
}

func (s *IntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitInterval(s)
	}
}

func (s *IntervalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitInterval(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) Interval() (localctx IIntervalContext) {
	localctx = NewIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, SqlBaseParserRULE_interval)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1615)
		p.Match(SqlBaseParserINTERVAL)
	}
	p.SetState(1617)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserPLUS || _la == SqlBaseParserMINUS {
		{
			p.SetState(1616)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*IntervalContext).sign = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserPLUS || _la == SqlBaseParserMINUS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*IntervalContext).sign = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1619)
		p.String_()
	}
	{
		p.SetState(1620)

		var _x = p.IntervalField()

		localctx.(*IntervalContext).from = _x
	}
	p.SetState(1623)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 210, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1621)
			p.Match(SqlBaseParserTO)
		}
		{
			p.SetState(1622)

			var _x = p.IntervalField()

			localctx.(*IntervalContext).to = _x
		}

	}

	return localctx
}

// IIntervalFieldContext is an interface to support dynamic dispatch.
type IIntervalFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntervalFieldContext differentiates from other interfaces.
	IsIntervalFieldContext()
}

type IntervalFieldContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalFieldContext() *IntervalFieldContext {
	var p = new(IntervalFieldContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_intervalField
	return p
}

func (*IntervalFieldContext) IsIntervalFieldContext() {}

func NewIntervalFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalFieldContext {
	var p = new(IntervalFieldContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_intervalField

	return p
}

func (s *IntervalFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalFieldContext) YEAR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserYEAR, 0)
}

func (s *IntervalFieldContext) MONTH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMONTH, 0)
}

func (s *IntervalFieldContext) DAY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDAY, 0)
}

func (s *IntervalFieldContext) HOUR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserHOUR, 0)
}

func (s *IntervalFieldContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUTE, 0)
}

func (s *IntervalFieldContext) SECOND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSECOND, 0)
}

func (s *IntervalFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterIntervalField(s)
	}
}

func (s *IntervalFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitIntervalField(s)
	}
}

func (s *IntervalFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitIntervalField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) IntervalField() (localctx IIntervalFieldContext) {
	localctx = NewIntervalFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, SqlBaseParserRULE_intervalField)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1625)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBaseParserDAY || (((_la-84)&-(0x1f+1)) == 0 && ((1<<uint((_la-84)))&((1<<(SqlBaseParserHOUR-84))|(1<<(SqlBaseParserMINUTE-84))|(1<<(SqlBaseParserMONTH-84)))) != 0) || _la == SqlBaseParserSECOND || _la == SqlBaseParserYEAR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// INormalFormContext is an interface to support dynamic dispatch.
type INormalFormContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNormalFormContext differentiates from other interfaces.
	IsNormalFormContext()
}

type NormalFormContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNormalFormContext() *NormalFormContext {
	var p = new(NormalFormContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_normalForm
	return p
}

func (*NormalFormContext) IsNormalFormContext() {}

func NewNormalFormContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NormalFormContext {
	var p = new(NormalFormContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_normalForm

	return p
}

func (s *NormalFormContext) GetParser() antlr.Parser { return s.parser }

func (s *NormalFormContext) NFD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNFD, 0)
}

func (s *NormalFormContext) NFC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNFC, 0)
}

func (s *NormalFormContext) NFKD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNFKD, 0)
}

func (s *NormalFormContext) NFKC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNFKC, 0)
}

func (s *NormalFormContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NormalFormContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NormalFormContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterNormalForm(s)
	}
}

func (s *NormalFormContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitNormalForm(s)
	}
}

func (s *NormalFormContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitNormalForm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) NormalForm() (localctx INormalFormContext) {
	localctx = NewNormalFormContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, SqlBaseParserRULE_normalForm)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1627)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-117)&-(0x1f+1)) == 0 && ((1<<uint((_la-117)))&((1<<(SqlBaseParserNFC-117))|(1<<(SqlBaseParserNFD-117))|(1<<(SqlBaseParserNFKC-117))|(1<<(SqlBaseParserNFKD-117)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ITypesContext is an interface to support dynamic dispatch.
type ITypesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypesContext differentiates from other interfaces.
	IsTypesContext()
}

type TypesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypesContext() *TypesContext {
	var p = new(TypesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_types
	return p
}

func (*TypesContext) IsTypesContext() {}

func NewTypesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypesContext {
	var p = new(TypesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_types

	return p
}

func (s *TypesContext) GetParser() antlr.Parser { return s.parser }

func (s *TypesContext) AllType_() []IType_Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IType_Context)(nil)).Elem())
	var tst = make([]IType_Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IType_Context)
		}
	}

	return tst
}

func (s *TypesContext) Type_(i int) IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterTypes(s)
	}
}

func (s *TypesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitTypes(s)
	}
}

func (s *TypesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitTypes(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) Types() (localctx ITypesContext) {
	localctx = NewTypesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, SqlBaseParserRULE_types)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1629)
		p.Match(SqlBaseParserT__1)
	}
	p.SetState(1638)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-10)&-(0x1f+1)) == 0 && ((1<<uint((_la-10)))&((1<<(SqlBaseParserADD-10))|(1<<(SqlBaseParserADMIN-10))|(1<<(SqlBaseParserALL-10))|(1<<(SqlBaseParserANALYZE-10))|(1<<(SqlBaseParserANY-10))|(1<<(SqlBaseParserARRAY-10))|(1<<(SqlBaseParserASC-10))|(1<<(SqlBaseParserAT-10))|(1<<(SqlBaseParserBERNOULLI-10))|(1<<(SqlBaseParserCALL-10))|(1<<(SqlBaseParserCALLED-10))|(1<<(SqlBaseParserCASCADE-10))|(1<<(SqlBaseParserCATALOGS-10))|(1<<(SqlBaseParserCOLUMN-10))|(1<<(SqlBaseParserCOLUMNS-10))|(1<<(SqlBaseParserCOMMENT-10))|(1<<(SqlBaseParserCOMMIT-10))|(1<<(SqlBaseParserCOMMITTED-10))|(1<<(SqlBaseParserCURRENT-10))|(1<<(SqlBaseParserCURRENT_ROLE-10)))) != 0) || (((_la-45)&-(0x1f+1)) == 0 && ((1<<uint((_la-45)))&((1<<(SqlBaseParserDATA-45))|(1<<(SqlBaseParserDATE-45))|(1<<(SqlBaseParserDAY-45))|(1<<(SqlBaseParserDEFINER-45))|(1<<(SqlBaseParserDESC-45))|(1<<(SqlBaseParserDETERMINISTIC-45))|(1<<(SqlBaseParserDISTRIBUTED-45))|(1<<(SqlBaseParserEXCLUDING-45))|(1<<(SqlBaseParserEXPLAIN-45))|(1<<(SqlBaseParserEXTERNAL-45))|(1<<(SqlBaseParserFILTER-45))|(1<<(SqlBaseParserFIRST-45))|(1<<(SqlBaseParserFOLLOWING-45))|(1<<(SqlBaseParserFORMAT-45))|(1<<(SqlBaseParserFUNCTION-45))|(1<<(SqlBaseParserFUNCTIONS-45)))) != 0) || (((_la-77)&-(0x1f+1)) == 0 && ((1<<uint((_la-77)))&((1<<(SqlBaseParserGRANT-77))|(1<<(SqlBaseParserGRANTED-77))|(1<<(SqlBaseParserGRANTS-77))|(1<<(SqlBaseParserGRAPHVIZ-77))|(1<<(SqlBaseParserHOUR-77))|(1<<(SqlBaseParserIF-77))|(1<<(SqlBaseParserIGNORE-77))|(1<<(SqlBaseParserINCLUDING-77))|(1<<(SqlBaseParserINPUT-77))|(1<<(SqlBaseParserINTERVAL-77))|(1<<(SqlBaseParserINVOKER-77))|(1<<(SqlBaseParserIO-77))|(1<<(SqlBaseParserISOLATION-77))|(1<<(SqlBaseParserJSON-77))|(1<<(SqlBaseParserLANGUAGE-77))|(1<<(SqlBaseParserLAST-77))|(1<<(SqlBaseParserLATERAL-77))|(1<<(SqlBaseParserLEVEL-77))|(1<<(SqlBaseParserLIMIT-77)))) != 0) || (((_la-110)&-(0x1f+1)) == 0 && ((1<<uint((_la-110)))&((1<<(SqlBaseParserLOGICAL-110))|(1<<(SqlBaseParserMAP-110))|(1<<(SqlBaseParserMATERIALIZED-110))|(1<<(SqlBaseParserMINUTE-110))|(1<<(SqlBaseParserMONTH-110))|(1<<(SqlBaseParserNAME-110))|(1<<(SqlBaseParserNFC-110))|(1<<(SqlBaseParserNFD-110))|(1<<(SqlBaseParserNFKC-110))|(1<<(SqlBaseParserNFKD-110))|(1<<(SqlBaseParserNO-110))|(1<<(SqlBaseParserNONE-110))|(1<<(SqlBaseParserNULLIF-110))|(1<<(SqlBaseParserNULLS-110))|(1<<(SqlBaseParserOFFSET-110))|(1<<(SqlBaseParserONLY-110))|(1<<(SqlBaseParserOPTION-110))|(1<<(SqlBaseParserORDINALITY-110))|(1<<(SqlBaseParserOUTPUT-110))|(1<<(SqlBaseParserOVER-110))|(1<<(SqlBaseParserPARTITION-110))|(1<<(SqlBaseParserPARTITIONS-110))|(1<<(SqlBaseParserPOSITION-110))|(1<<(SqlBaseParserPRECEDING-110)))) != 0) || (((_la-143)&-(0x1f+1)) == 0 && ((1<<uint((_la-143)))&((1<<(SqlBaseParserPRIVILEGES-143))|(1<<(SqlBaseParserPROPERTIES-143))|(1<<(SqlBaseParserRANGE-143))|(1<<(SqlBaseParserREAD-143))|(1<<(SqlBaseParserREFRESH-143))|(1<<(SqlBaseParserRENAME-143))|(1<<(SqlBaseParserREPEATABLE-143))|(1<<(SqlBaseParserREPLACE-143))|(1<<(SqlBaseParserRESET-143))|(1<<(SqlBaseParserRESPECT-143))|(1<<(SqlBaseParserRESTRICT-143))|(1<<(SqlBaseParserRETURN-143))|(1<<(SqlBaseParserRETURNS-143))|(1<<(SqlBaseParserREVOKE-143))|(1<<(SqlBaseParserROLE-143))|(1<<(SqlBaseParserROLES-143))|(1<<(SqlBaseParserROLLBACK-143))|(1<<(SqlBaseParserROW-143))|(1<<(SqlBaseParserROWS-143))|(1<<(SqlBaseParserSCHEMA-143))|(1<<(SqlBaseParserSCHEMAS-143))|(1<<(SqlBaseParserSECOND-143))|(1<<(SqlBaseParserSECURITY-143))|(1<<(SqlBaseParserSERIALIZABLE-143))|(1<<(SqlBaseParserSESSION-143))|(1<<(SqlBaseParserSET-143))|(1<<(SqlBaseParserSETS-143))|(1<<(SqlBaseParserSHOW-143)))) != 0) || (((_la-175)&-(0x1f+1)) == 0 && ((1<<uint((_la-175)))&((1<<(SqlBaseParserSOME-175))|(1<<(SqlBaseParserSQL-175))|(1<<(SqlBaseParserSTART-175))|(1<<(SqlBaseParserSTATS-175))|(1<<(SqlBaseParserSUBSTRING-175))|(1<<(SqlBaseParserSYSTEM-175))|(1<<(SqlBaseParserTABLES-175))|(1<<(SqlBaseParserTABLESAMPLE-175))|(1<<(SqlBaseParserTEMPORARY-175))|(1<<(SqlBaseParserTEXT-175))|(1<<(SqlBaseParserTIME-175))|(1<<(SqlBaseParserTIMESTAMP-175))|(1<<(SqlBaseParserTO-175))|(1<<(SqlBaseParserTRANSACTION-175))|(1<<(SqlBaseParserTRY_CAST-175))|(1<<(SqlBaseParserTYPE-175))|(1<<(SqlBaseParserUNBOUNDED-175))|(1<<(SqlBaseParserUNCOMMITTED-175))|(1<<(SqlBaseParserUSE-175))|(1<<(SqlBaseParserUSER-175))|(1<<(SqlBaseParserVALIDATE-175))|(1<<(SqlBaseParserVERBOSE-175))|(1<<(SqlBaseParserVIEW-175)))) != 0) || (((_la-209)&-(0x1f+1)) == 0 && ((1<<uint((_la-209)))&((1<<(SqlBaseParserWORK-209))|(1<<(SqlBaseParserWRITE-209))|(1<<(SqlBaseParserYEAR-209))|(1<<(SqlBaseParserZONE-209))|(1<<(SqlBaseParserIDENTIFIER-209))|(1<<(SqlBaseParserDIGIT_IDENTIFIER-209))|(1<<(SqlBaseParserQUOTED_IDENTIFIER-209))|(1<<(SqlBaseParserBACKQUOTED_IDENTIFIER-209))|(1<<(SqlBaseParserTIME_WITH_TIME_ZONE-209))|(1<<(SqlBaseParserTIMESTAMP_WITH_TIME_ZONE-209))|(1<<(SqlBaseParserDOUBLE_PRECISION-209)))) != 0) {
		{
			p.SetState(1630)
			p.type_(0)
		}
		p.SetState(1635)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__3 {
			{
				p.SetState(1631)
				p.Match(SqlBaseParserT__3)
			}
			{
				p.SetState(1632)
				p.type_(0)
			}

			p.SetState(1637)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1640)
		p.Match(SqlBaseParserT__2)
	}

	return localctx
}

// IType_Context is an interface to support dynamic dispatch.
type IType_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFrom returns the from rule contexts.
	GetFrom() IIntervalFieldContext

	// GetTo returns the to rule contexts.
	GetTo() IIntervalFieldContext

	// SetFrom sets the from rule contexts.
	SetFrom(IIntervalFieldContext)

	// SetTo sets the to rule contexts.
	SetTo(IIntervalFieldContext)

	// IsType_Context differentiates from other interfaces.
	IsType_Context()
}

type Type_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	from   IIntervalFieldContext
	to     IIntervalFieldContext
}

func NewEmptyType_Context() *Type_Context {
	var p = new(Type_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_type_
	return p
}

func (*Type_Context) IsType_Context() {}

func NewType_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_Context {
	var p = new(Type_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_type_

	return p
}

func (s *Type_Context) GetParser() antlr.Parser { return s.parser }

func (s *Type_Context) GetFrom() IIntervalFieldContext { return s.from }

func (s *Type_Context) GetTo() IIntervalFieldContext { return s.to }

func (s *Type_Context) SetFrom(v IIntervalFieldContext) { s.from = v }

func (s *Type_Context) SetTo(v IIntervalFieldContext) { s.to = v }

func (s *Type_Context) ARRAY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserARRAY, 0)
}

func (s *Type_Context) LT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLT, 0)
}

func (s *Type_Context) AllType_() []IType_Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IType_Context)(nil)).Elem())
	var tst = make([]IType_Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IType_Context)
		}
	}

	return tst
}

func (s *Type_Context) Type_(i int) IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *Type_Context) GT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGT, 0)
}

func (s *Type_Context) MAP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMAP, 0)
}

func (s *Type_Context) ROW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROW, 0)
}

func (s *Type_Context) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *Type_Context) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Type_Context) BaseType() IBaseTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBaseTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBaseTypeContext)
}

func (s *Type_Context) AllTypeParameter() []ITypeParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeParameterContext)(nil)).Elem())
	var tst = make([]ITypeParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeParameterContext)
		}
	}

	return tst
}

func (s *Type_Context) TypeParameter(i int) ITypeParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeParameterContext)
}

func (s *Type_Context) INTERVAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTERVAL, 0)
}

func (s *Type_Context) TO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTO, 0)
}

func (s *Type_Context) AllIntervalField() []IIntervalFieldContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIntervalFieldContext)(nil)).Elem())
	var tst = make([]IIntervalFieldContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIntervalFieldContext)
		}
	}

	return tst
}

func (s *Type_Context) IntervalField(i int) IIntervalFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntervalFieldContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIntervalFieldContext)
}

func (s *Type_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterType_(s)
	}
}

func (s *Type_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitType_(s)
	}
}

func (s *Type_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitType_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) Type_() (localctx IType_Context) {
	return p.type_(0)
}

func (p *SqlBaseParser) type_(_p int) (localctx IType_Context) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewType_Context(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IType_Context = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 114
	p.EnterRecursionRule(localctx, 114, SqlBaseParserRULE_type_, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1689)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 216, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1643)
			p.Match(SqlBaseParserARRAY)
		}
		{
			p.SetState(1644)
			p.Match(SqlBaseParserLT)
		}
		{
			p.SetState(1645)
			p.type_(0)
		}
		{
			p.SetState(1646)
			p.Match(SqlBaseParserGT)
		}

	case 2:
		{
			p.SetState(1648)
			p.Match(SqlBaseParserMAP)
		}
		{
			p.SetState(1649)
			p.Match(SqlBaseParserLT)
		}
		{
			p.SetState(1650)
			p.type_(0)
		}
		{
			p.SetState(1651)
			p.Match(SqlBaseParserT__3)
		}
		{
			p.SetState(1652)
			p.type_(0)
		}
		{
			p.SetState(1653)
			p.Match(SqlBaseParserGT)
		}

	case 3:
		{
			p.SetState(1655)
			p.Match(SqlBaseParserROW)
		}
		{
			p.SetState(1656)
			p.Match(SqlBaseParserT__1)
		}
		{
			p.SetState(1657)
			p.Identifier()
		}
		{
			p.SetState(1658)
			p.type_(0)
		}
		p.SetState(1665)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__3 {
			{
				p.SetState(1659)
				p.Match(SqlBaseParserT__3)
			}
			{
				p.SetState(1660)
				p.Identifier()
			}
			{
				p.SetState(1661)
				p.type_(0)
			}

			p.SetState(1667)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1668)
			p.Match(SqlBaseParserT__2)
		}

	case 4:
		{
			p.SetState(1670)
			p.BaseType()
		}
		p.SetState(1682)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 215, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1671)
				p.Match(SqlBaseParserT__1)
			}
			{
				p.SetState(1672)
				p.TypeParameter()
			}
			p.SetState(1677)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__3 {
				{
					p.SetState(1673)
					p.Match(SqlBaseParserT__3)
				}
				{
					p.SetState(1674)
					p.TypeParameter()
				}

				p.SetState(1679)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1680)
				p.Match(SqlBaseParserT__2)
			}

		}

	case 5:
		{
			p.SetState(1684)
			p.Match(SqlBaseParserINTERVAL)
		}
		{
			p.SetState(1685)

			var _x = p.IntervalField()

			localctx.(*Type_Context).from = _x
		}
		{
			p.SetState(1686)
			p.Match(SqlBaseParserTO)
		}
		{
			p.SetState(1687)

			var _x = p.IntervalField()

			localctx.(*Type_Context).to = _x
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1695)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 217, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewType_Context(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_type_)
			p.SetState(1691)

			if !(p.Precpred(p.GetParserRuleContext(), 6)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
			}
			{
				p.SetState(1692)
				p.Match(SqlBaseParserARRAY)
			}

		}
		p.SetState(1697)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 217, p.GetParserRuleContext())
	}

	return localctx
}

// ITypeParameterContext is an interface to support dynamic dispatch.
type ITypeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParameterContext differentiates from other interfaces.
	IsTypeParameterContext()
}

type TypeParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterContext() *TypeParameterContext {
	var p = new(TypeParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_typeParameter
	return p
}

func (*TypeParameterContext) IsTypeParameterContext() {}

func NewTypeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterContext {
	var p = new(TypeParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_typeParameter

	return p
}

func (s *TypeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTEGER_VALUE, 0)
}

func (s *TypeParameterContext) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TypeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterTypeParameter(s)
	}
}

func (s *TypeParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitTypeParameter(s)
	}
}

func (s *TypeParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitTypeParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) TypeParameter() (localctx ITypeParameterContext) {
	localctx = NewTypeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, SqlBaseParserRULE_typeParameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1700)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserINTEGER_VALUE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1698)
			p.Match(SqlBaseParserINTEGER_VALUE)
		}

	case SqlBaseParserADD, SqlBaseParserADMIN, SqlBaseParserALL, SqlBaseParserANALYZE, SqlBaseParserANY, SqlBaseParserARRAY, SqlBaseParserASC, SqlBaseParserAT, SqlBaseParserBERNOULLI, SqlBaseParserCALL, SqlBaseParserCALLED, SqlBaseParserCASCADE, SqlBaseParserCATALOGS, SqlBaseParserCOLUMN, SqlBaseParserCOLUMNS, SqlBaseParserCOMMENT, SqlBaseParserCOMMIT, SqlBaseParserCOMMITTED, SqlBaseParserCURRENT, SqlBaseParserCURRENT_ROLE, SqlBaseParserDATA, SqlBaseParserDATE, SqlBaseParserDAY, SqlBaseParserDEFINER, SqlBaseParserDESC, SqlBaseParserDETERMINISTIC, SqlBaseParserDISTRIBUTED, SqlBaseParserEXCLUDING, SqlBaseParserEXPLAIN, SqlBaseParserEXTERNAL, SqlBaseParserFILTER, SqlBaseParserFIRST, SqlBaseParserFOLLOWING, SqlBaseParserFORMAT, SqlBaseParserFUNCTION, SqlBaseParserFUNCTIONS, SqlBaseParserGRANT, SqlBaseParserGRANTED, SqlBaseParserGRANTS, SqlBaseParserGRAPHVIZ, SqlBaseParserHOUR, SqlBaseParserIF, SqlBaseParserIGNORE, SqlBaseParserINCLUDING, SqlBaseParserINPUT, SqlBaseParserINTERVAL, SqlBaseParserINVOKER, SqlBaseParserIO, SqlBaseParserISOLATION, SqlBaseParserJSON, SqlBaseParserLANGUAGE, SqlBaseParserLAST, SqlBaseParserLATERAL, SqlBaseParserLEVEL, SqlBaseParserLIMIT, SqlBaseParserLOGICAL, SqlBaseParserMAP, SqlBaseParserMATERIALIZED, SqlBaseParserMINUTE, SqlBaseParserMONTH, SqlBaseParserNAME, SqlBaseParserNFC, SqlBaseParserNFD, SqlBaseParserNFKC, SqlBaseParserNFKD, SqlBaseParserNO, SqlBaseParserNONE, SqlBaseParserNULLIF, SqlBaseParserNULLS, SqlBaseParserOFFSET, SqlBaseParserONLY, SqlBaseParserOPTION, SqlBaseParserORDINALITY, SqlBaseParserOUTPUT, SqlBaseParserOVER, SqlBaseParserPARTITION, SqlBaseParserPARTITIONS, SqlBaseParserPOSITION, SqlBaseParserPRECEDING, SqlBaseParserPRIVILEGES, SqlBaseParserPROPERTIES, SqlBaseParserRANGE, SqlBaseParserREAD, SqlBaseParserREFRESH, SqlBaseParserRENAME, SqlBaseParserREPEATABLE, SqlBaseParserREPLACE, SqlBaseParserRESET, SqlBaseParserRESPECT, SqlBaseParserRESTRICT, SqlBaseParserRETURN, SqlBaseParserRETURNS, SqlBaseParserREVOKE, SqlBaseParserROLE, SqlBaseParserROLES, SqlBaseParserROLLBACK, SqlBaseParserROW, SqlBaseParserROWS, SqlBaseParserSCHEMA, SqlBaseParserSCHEMAS, SqlBaseParserSECOND, SqlBaseParserSECURITY, SqlBaseParserSERIALIZABLE, SqlBaseParserSESSION, SqlBaseParserSET, SqlBaseParserSETS, SqlBaseParserSHOW, SqlBaseParserSOME, SqlBaseParserSQL, SqlBaseParserSTART, SqlBaseParserSTATS, SqlBaseParserSUBSTRING, SqlBaseParserSYSTEM, SqlBaseParserTABLES, SqlBaseParserTABLESAMPLE, SqlBaseParserTEMPORARY, SqlBaseParserTEXT, SqlBaseParserTIME, SqlBaseParserTIMESTAMP, SqlBaseParserTO, SqlBaseParserTRANSACTION, SqlBaseParserTRY_CAST, SqlBaseParserTYPE, SqlBaseParserUNBOUNDED, SqlBaseParserUNCOMMITTED, SqlBaseParserUSE, SqlBaseParserUSER, SqlBaseParserVALIDATE, SqlBaseParserVERBOSE, SqlBaseParserVIEW, SqlBaseParserWORK, SqlBaseParserWRITE, SqlBaseParserYEAR, SqlBaseParserZONE, SqlBaseParserIDENTIFIER, SqlBaseParserDIGIT_IDENTIFIER, SqlBaseParserQUOTED_IDENTIFIER, SqlBaseParserBACKQUOTED_IDENTIFIER, SqlBaseParserTIME_WITH_TIME_ZONE, SqlBaseParserTIMESTAMP_WITH_TIME_ZONE, SqlBaseParserDOUBLE_PRECISION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1699)
			p.type_(0)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBaseTypeContext is an interface to support dynamic dispatch.
type IBaseTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBaseTypeContext differentiates from other interfaces.
	IsBaseTypeContext()
}

type BaseTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBaseTypeContext() *BaseTypeContext {
	var p = new(BaseTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_baseType
	return p
}

func (*BaseTypeContext) IsBaseTypeContext() {}

func NewBaseTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BaseTypeContext {
	var p = new(BaseTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_baseType

	return p
}

func (s *BaseTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BaseTypeContext) TIME_WITH_TIME_ZONE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIME_WITH_TIME_ZONE, 0)
}

func (s *BaseTypeContext) TIMESTAMP_WITH_TIME_ZONE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIMESTAMP_WITH_TIME_ZONE, 0)
}

func (s *BaseTypeContext) DOUBLE_PRECISION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDOUBLE_PRECISION, 0)
}

func (s *BaseTypeContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *BaseTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BaseTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BaseTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterBaseType(s)
	}
}

func (s *BaseTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitBaseType(s)
	}
}

func (s *BaseTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitBaseType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) BaseType() (localctx IBaseTypeContext) {
	localctx = NewBaseTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, SqlBaseParserRULE_baseType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1706)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserTIME_WITH_TIME_ZONE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1702)
			p.Match(SqlBaseParserTIME_WITH_TIME_ZONE)
		}

	case SqlBaseParserTIMESTAMP_WITH_TIME_ZONE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1703)
			p.Match(SqlBaseParserTIMESTAMP_WITH_TIME_ZONE)
		}

	case SqlBaseParserDOUBLE_PRECISION:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1704)
			p.Match(SqlBaseParserDOUBLE_PRECISION)
		}

	case SqlBaseParserADD, SqlBaseParserADMIN, SqlBaseParserALL, SqlBaseParserANALYZE, SqlBaseParserANY, SqlBaseParserARRAY, SqlBaseParserASC, SqlBaseParserAT, SqlBaseParserBERNOULLI, SqlBaseParserCALL, SqlBaseParserCALLED, SqlBaseParserCASCADE, SqlBaseParserCATALOGS, SqlBaseParserCOLUMN, SqlBaseParserCOLUMNS, SqlBaseParserCOMMENT, SqlBaseParserCOMMIT, SqlBaseParserCOMMITTED, SqlBaseParserCURRENT, SqlBaseParserCURRENT_ROLE, SqlBaseParserDATA, SqlBaseParserDATE, SqlBaseParserDAY, SqlBaseParserDEFINER, SqlBaseParserDESC, SqlBaseParserDETERMINISTIC, SqlBaseParserDISTRIBUTED, SqlBaseParserEXCLUDING, SqlBaseParserEXPLAIN, SqlBaseParserEXTERNAL, SqlBaseParserFILTER, SqlBaseParserFIRST, SqlBaseParserFOLLOWING, SqlBaseParserFORMAT, SqlBaseParserFUNCTION, SqlBaseParserFUNCTIONS, SqlBaseParserGRANT, SqlBaseParserGRANTED, SqlBaseParserGRANTS, SqlBaseParserGRAPHVIZ, SqlBaseParserHOUR, SqlBaseParserIF, SqlBaseParserIGNORE, SqlBaseParserINCLUDING, SqlBaseParserINPUT, SqlBaseParserINTERVAL, SqlBaseParserINVOKER, SqlBaseParserIO, SqlBaseParserISOLATION, SqlBaseParserJSON, SqlBaseParserLANGUAGE, SqlBaseParserLAST, SqlBaseParserLATERAL, SqlBaseParserLEVEL, SqlBaseParserLIMIT, SqlBaseParserLOGICAL, SqlBaseParserMAP, SqlBaseParserMATERIALIZED, SqlBaseParserMINUTE, SqlBaseParserMONTH, SqlBaseParserNAME, SqlBaseParserNFC, SqlBaseParserNFD, SqlBaseParserNFKC, SqlBaseParserNFKD, SqlBaseParserNO, SqlBaseParserNONE, SqlBaseParserNULLIF, SqlBaseParserNULLS, SqlBaseParserOFFSET, SqlBaseParserONLY, SqlBaseParserOPTION, SqlBaseParserORDINALITY, SqlBaseParserOUTPUT, SqlBaseParserOVER, SqlBaseParserPARTITION, SqlBaseParserPARTITIONS, SqlBaseParserPOSITION, SqlBaseParserPRECEDING, SqlBaseParserPRIVILEGES, SqlBaseParserPROPERTIES, SqlBaseParserRANGE, SqlBaseParserREAD, SqlBaseParserREFRESH, SqlBaseParserRENAME, SqlBaseParserREPEATABLE, SqlBaseParserREPLACE, SqlBaseParserRESET, SqlBaseParserRESPECT, SqlBaseParserRESTRICT, SqlBaseParserRETURN, SqlBaseParserRETURNS, SqlBaseParserREVOKE, SqlBaseParserROLE, SqlBaseParserROLES, SqlBaseParserROLLBACK, SqlBaseParserROW, SqlBaseParserROWS, SqlBaseParserSCHEMA, SqlBaseParserSCHEMAS, SqlBaseParserSECOND, SqlBaseParserSECURITY, SqlBaseParserSERIALIZABLE, SqlBaseParserSESSION, SqlBaseParserSET, SqlBaseParserSETS, SqlBaseParserSHOW, SqlBaseParserSOME, SqlBaseParserSQL, SqlBaseParserSTART, SqlBaseParserSTATS, SqlBaseParserSUBSTRING, SqlBaseParserSYSTEM, SqlBaseParserTABLES, SqlBaseParserTABLESAMPLE, SqlBaseParserTEMPORARY, SqlBaseParserTEXT, SqlBaseParserTIME, SqlBaseParserTIMESTAMP, SqlBaseParserTO, SqlBaseParserTRANSACTION, SqlBaseParserTRY_CAST, SqlBaseParserTYPE, SqlBaseParserUNBOUNDED, SqlBaseParserUNCOMMITTED, SqlBaseParserUSE, SqlBaseParserUSER, SqlBaseParserVALIDATE, SqlBaseParserVERBOSE, SqlBaseParserVIEW, SqlBaseParserWORK, SqlBaseParserWRITE, SqlBaseParserYEAR, SqlBaseParserZONE, SqlBaseParserIDENTIFIER, SqlBaseParserDIGIT_IDENTIFIER, SqlBaseParserQUOTED_IDENTIFIER, SqlBaseParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1705)
			p.QualifiedName()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IWhenClauseContext is an interface to support dynamic dispatch.
type IWhenClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCondition returns the condition rule contexts.
	GetCondition() IExpressionContext

	// GetResult returns the result rule contexts.
	GetResult() IExpressionContext

	// SetCondition sets the condition rule contexts.
	SetCondition(IExpressionContext)

	// SetResult sets the result rule contexts.
	SetResult(IExpressionContext)

	// IsWhenClauseContext differentiates from other interfaces.
	IsWhenClauseContext()
}

type WhenClauseContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	condition IExpressionContext
	result    IExpressionContext
}

func NewEmptyWhenClauseContext() *WhenClauseContext {
	var p = new(WhenClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_whenClause
	return p
}

func (*WhenClauseContext) IsWhenClauseContext() {}

func NewWhenClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenClauseContext {
	var p = new(WhenClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_whenClause

	return p
}

func (s *WhenClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenClauseContext) GetCondition() IExpressionContext { return s.condition }

func (s *WhenClauseContext) GetResult() IExpressionContext { return s.result }

func (s *WhenClauseContext) SetCondition(v IExpressionContext) { s.condition = v }

func (s *WhenClauseContext) SetResult(v IExpressionContext) { s.result = v }

func (s *WhenClauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWHEN, 0)
}

func (s *WhenClauseContext) THEN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTHEN, 0)
}

func (s *WhenClauseContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *WhenClauseContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterWhenClause(s)
	}
}

func (s *WhenClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitWhenClause(s)
	}
}

func (s *WhenClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitWhenClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) WhenClause() (localctx IWhenClauseContext) {
	localctx = NewWhenClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, SqlBaseParserRULE_whenClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1708)
		p.Match(SqlBaseParserWHEN)
	}
	{
		p.SetState(1709)

		var _x = p.Expression()

		localctx.(*WhenClauseContext).condition = _x
	}
	{
		p.SetState(1710)
		p.Match(SqlBaseParserTHEN)
	}
	{
		p.SetState(1711)

		var _x = p.Expression()

		localctx.(*WhenClauseContext).result = _x
	}

	return localctx
}

// IFilterContext is an interface to support dynamic dispatch.
type IFilterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFilterContext differentiates from other interfaces.
	IsFilterContext()
}

type FilterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilterContext() *FilterContext {
	var p = new(FilterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_filter
	return p
}

func (*FilterContext) IsFilterContext() {}

func NewFilterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilterContext {
	var p = new(FilterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_filter

	return p
}

func (s *FilterContext) GetParser() antlr.Parser { return s.parser }

func (s *FilterContext) FILTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFILTER, 0)
}

func (s *FilterContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWHERE, 0)
}

func (s *FilterContext) BooleanExpression() IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *FilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterFilter(s)
	}
}

func (s *FilterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitFilter(s)
	}
}

func (s *FilterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitFilter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) Filter() (localctx IFilterContext) {
	localctx = NewFilterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, SqlBaseParserRULE_filter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1713)
		p.Match(SqlBaseParserFILTER)
	}
	{
		p.SetState(1714)
		p.Match(SqlBaseParserT__1)
	}
	{
		p.SetState(1715)
		p.Match(SqlBaseParserWHERE)
	}
	{
		p.SetState(1716)
		p.booleanExpression(0)
	}
	{
		p.SetState(1717)
		p.Match(SqlBaseParserT__2)
	}

	return localctx
}

// IOverContext is an interface to support dynamic dispatch.
type IOverContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// GetPartition returns the partition rule context list.
	GetPartition() []IExpressionContext

	// SetPartition sets the partition rule context list.
	SetPartition([]IExpressionContext)

	// IsOverContext differentiates from other interfaces.
	IsOverContext()
}

type OverContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	_expression IExpressionContext
	partition   []IExpressionContext
}

func NewEmptyOverContext() *OverContext {
	var p = new(OverContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_over
	return p
}

func (*OverContext) IsOverContext() {}

func NewOverContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OverContext {
	var p = new(OverContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_over

	return p
}

func (s *OverContext) GetParser() antlr.Parser { return s.parser }

func (s *OverContext) Get_expression() IExpressionContext { return s._expression }

func (s *OverContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *OverContext) GetPartition() []IExpressionContext { return s.partition }

func (s *OverContext) SetPartition(v []IExpressionContext) { s.partition = v }

func (s *OverContext) OVER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOVER, 0)
}

func (s *OverContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPARTITION, 0)
}

func (s *OverContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserBY)
}

func (s *OverContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBY, i)
}

func (s *OverContext) ORDER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserORDER, 0)
}

func (s *OverContext) AllSortItem() []ISortItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISortItemContext)(nil)).Elem())
	var tst = make([]ISortItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISortItemContext)
		}
	}

	return tst
}

func (s *OverContext) SortItem(i int) ISortItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *OverContext) WindowFrame() IWindowFrameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWindowFrameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWindowFrameContext)
}

func (s *OverContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *OverContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *OverContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OverContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OverContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterOver(s)
	}
}

func (s *OverContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitOver(s)
	}
}

func (s *OverContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitOver(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) Over() (localctx IOverContext) {
	localctx = NewOverContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, SqlBaseParserRULE_over)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1719)
		p.Match(SqlBaseParserOVER)
	}
	{
		p.SetState(1720)
		p.Match(SqlBaseParserT__1)
	}
	p.SetState(1731)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserPARTITION {
		{
			p.SetState(1721)
			p.Match(SqlBaseParserPARTITION)
		}
		{
			p.SetState(1722)
			p.Match(SqlBaseParserBY)
		}
		{
			p.SetState(1723)

			var _x = p.Expression()

			localctx.(*OverContext)._expression = _x
		}
		localctx.(*OverContext).partition = append(localctx.(*OverContext).partition, localctx.(*OverContext)._expression)
		p.SetState(1728)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__3 {
			{
				p.SetState(1724)
				p.Match(SqlBaseParserT__3)
			}
			{
				p.SetState(1725)

				var _x = p.Expression()

				localctx.(*OverContext)._expression = _x
			}
			localctx.(*OverContext).partition = append(localctx.(*OverContext).partition, localctx.(*OverContext)._expression)

			p.SetState(1730)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(1743)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserORDER {
		{
			p.SetState(1733)
			p.Match(SqlBaseParserORDER)
		}
		{
			p.SetState(1734)
			p.Match(SqlBaseParserBY)
		}
		{
			p.SetState(1735)
			p.SortItem()
		}
		p.SetState(1740)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__3 {
			{
				p.SetState(1736)
				p.Match(SqlBaseParserT__3)
			}
			{
				p.SetState(1737)
				p.SortItem()
			}

			p.SetState(1742)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(1746)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserRANGE || _la == SqlBaseParserROWS {
		{
			p.SetState(1745)
			p.WindowFrame()
		}

	}
	{
		p.SetState(1748)
		p.Match(SqlBaseParserT__2)
	}

	return localctx
}

// IWindowFrameContext is an interface to support dynamic dispatch.
type IWindowFrameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFrameType returns the frameType token.
	GetFrameType() antlr.Token

	// SetFrameType sets the frameType token.
	SetFrameType(antlr.Token)

	// GetStart returns the start rule contexts.
	GetStart() IFrameBoundContext

	// GetEnd returns the end rule contexts.
	GetEnd() IFrameBoundContext

	// SetStart sets the start rule contexts.
	SetStart(IFrameBoundContext)

	// SetEnd sets the end rule contexts.
	SetEnd(IFrameBoundContext)

	// IsWindowFrameContext differentiates from other interfaces.
	IsWindowFrameContext()
}

type WindowFrameContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	frameType antlr.Token
	start     IFrameBoundContext
	end       IFrameBoundContext
}

func NewEmptyWindowFrameContext() *WindowFrameContext {
	var p = new(WindowFrameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_windowFrame
	return p
}

func (*WindowFrameContext) IsWindowFrameContext() {}

func NewWindowFrameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFrameContext {
	var p = new(WindowFrameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_windowFrame

	return p
}

func (s *WindowFrameContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFrameContext) GetFrameType() antlr.Token { return s.frameType }

func (s *WindowFrameContext) SetFrameType(v antlr.Token) { s.frameType = v }

func (s *WindowFrameContext) GetStart() IFrameBoundContext { return s.start }

func (s *WindowFrameContext) GetEnd() IFrameBoundContext { return s.end }

func (s *WindowFrameContext) SetStart(v IFrameBoundContext) { s.start = v }

func (s *WindowFrameContext) SetEnd(v IFrameBoundContext) { s.end = v }

func (s *WindowFrameContext) RANGE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRANGE, 0)
}

func (s *WindowFrameContext) AllFrameBound() []IFrameBoundContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFrameBoundContext)(nil)).Elem())
	var tst = make([]IFrameBoundContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFrameBoundContext)
		}
	}

	return tst
}

func (s *WindowFrameContext) FrameBound(i int) IFrameBoundContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFrameBoundContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFrameBoundContext)
}

func (s *WindowFrameContext) ROWS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROWS, 0)
}

func (s *WindowFrameContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBETWEEN, 0)
}

func (s *WindowFrameContext) AND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAND, 0)
}

func (s *WindowFrameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFrameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFrameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterWindowFrame(s)
	}
}

func (s *WindowFrameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitWindowFrame(s)
	}
}

func (s *WindowFrameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitWindowFrame(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) WindowFrame() (localctx IWindowFrameContext) {
	localctx = NewWindowFrameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, SqlBaseParserRULE_windowFrame)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1766)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 225, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1750)

			var _m = p.Match(SqlBaseParserRANGE)

			localctx.(*WindowFrameContext).frameType = _m
		}
		{
			p.SetState(1751)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).start = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1752)

			var _m = p.Match(SqlBaseParserROWS)

			localctx.(*WindowFrameContext).frameType = _m
		}
		{
			p.SetState(1753)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).start = _x
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1754)

			var _m = p.Match(SqlBaseParserRANGE)

			localctx.(*WindowFrameContext).frameType = _m
		}
		{
			p.SetState(1755)
			p.Match(SqlBaseParserBETWEEN)
		}
		{
			p.SetState(1756)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).start = _x
		}
		{
			p.SetState(1757)
			p.Match(SqlBaseParserAND)
		}
		{
			p.SetState(1758)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).end = _x
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1760)

			var _m = p.Match(SqlBaseParserROWS)

			localctx.(*WindowFrameContext).frameType = _m
		}
		{
			p.SetState(1761)
			p.Match(SqlBaseParserBETWEEN)
		}
		{
			p.SetState(1762)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).start = _x
		}
		{
			p.SetState(1763)
			p.Match(SqlBaseParserAND)
		}
		{
			p.SetState(1764)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).end = _x
		}

	}

	return localctx
}

// IFrameBoundContext is an interface to support dynamic dispatch.
type IFrameBoundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFrameBoundContext differentiates from other interfaces.
	IsFrameBoundContext()
}

type FrameBoundContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrameBoundContext() *FrameBoundContext {
	var p = new(FrameBoundContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_frameBound
	return p
}

func (*FrameBoundContext) IsFrameBoundContext() {}

func NewFrameBoundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameBoundContext {
	var p = new(FrameBoundContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_frameBound

	return p
}

func (s *FrameBoundContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameBoundContext) CopyFrom(ctx *FrameBoundContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *FrameBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameBoundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BoundedFrameContext struct {
	*FrameBoundContext
	boundType antlr.Token
}

func NewBoundedFrameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BoundedFrameContext {
	var p = new(BoundedFrameContext)

	p.FrameBoundContext = NewEmptyFrameBoundContext()
	p.parser = parser
	p.CopyFrom(ctx.(*FrameBoundContext))

	return p
}

func (s *BoundedFrameContext) GetBoundType() antlr.Token { return s.boundType }

func (s *BoundedFrameContext) SetBoundType(v antlr.Token) { s.boundType = v }

func (s *BoundedFrameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BoundedFrameContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BoundedFrameContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPRECEDING, 0)
}

func (s *BoundedFrameContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOLLOWING, 0)
}

func (s *BoundedFrameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterBoundedFrame(s)
	}
}

func (s *BoundedFrameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitBoundedFrame(s)
	}
}

func (s *BoundedFrameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitBoundedFrame(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnboundedFrameContext struct {
	*FrameBoundContext
	boundType antlr.Token
}

func NewUnboundedFrameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnboundedFrameContext {
	var p = new(UnboundedFrameContext)

	p.FrameBoundContext = NewEmptyFrameBoundContext()
	p.parser = parser
	p.CopyFrom(ctx.(*FrameBoundContext))

	return p
}

func (s *UnboundedFrameContext) GetBoundType() antlr.Token { return s.boundType }

func (s *UnboundedFrameContext) SetBoundType(v antlr.Token) { s.boundType = v }

func (s *UnboundedFrameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnboundedFrameContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNBOUNDED, 0)
}

func (s *UnboundedFrameContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPRECEDING, 0)
}

func (s *UnboundedFrameContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOLLOWING, 0)
}

func (s *UnboundedFrameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterUnboundedFrame(s)
	}
}

func (s *UnboundedFrameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitUnboundedFrame(s)
	}
}

func (s *UnboundedFrameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitUnboundedFrame(s)

	default:
		return t.VisitChildren(s)
	}
}

type CurrentRowBoundContext struct {
	*FrameBoundContext
}

func NewCurrentRowBoundContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentRowBoundContext {
	var p = new(CurrentRowBoundContext)

	p.FrameBoundContext = NewEmptyFrameBoundContext()
	p.parser = parser
	p.CopyFrom(ctx.(*FrameBoundContext))

	return p
}

func (s *CurrentRowBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentRowBoundContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT, 0)
}

func (s *CurrentRowBoundContext) ROW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROW, 0)
}

func (s *CurrentRowBoundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCurrentRowBound(s)
	}
}

func (s *CurrentRowBoundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCurrentRowBound(s)
	}
}

func (s *CurrentRowBoundContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitCurrentRowBound(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) FrameBound() (localctx IFrameBoundContext) {
	localctx = NewFrameBoundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, SqlBaseParserRULE_frameBound)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1777)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 226, p.GetParserRuleContext()) {
	case 1:
		localctx = NewUnboundedFrameContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1768)
			p.Match(SqlBaseParserUNBOUNDED)
		}
		{
			p.SetState(1769)

			var _m = p.Match(SqlBaseParserPRECEDING)

			localctx.(*UnboundedFrameContext).boundType = _m
		}

	case 2:
		localctx = NewUnboundedFrameContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1770)
			p.Match(SqlBaseParserUNBOUNDED)
		}
		{
			p.SetState(1771)

			var _m = p.Match(SqlBaseParserFOLLOWING)

			localctx.(*UnboundedFrameContext).boundType = _m
		}

	case 3:
		localctx = NewCurrentRowBoundContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1772)
			p.Match(SqlBaseParserCURRENT)
		}
		{
			p.SetState(1773)
			p.Match(SqlBaseParserROW)
		}

	case 4:
		localctx = NewBoundedFrameContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1774)
			p.Expression()
		}
		{
			p.SetState(1775)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*BoundedFrameContext).boundType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserFOLLOWING || _la == SqlBaseParserPRECEDING) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*BoundedFrameContext).boundType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IExplainOptionContext is an interface to support dynamic dispatch.
type IExplainOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExplainOptionContext differentiates from other interfaces.
	IsExplainOptionContext()
}

type ExplainOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplainOptionContext() *ExplainOptionContext {
	var p = new(ExplainOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_explainOption
	return p
}

func (*ExplainOptionContext) IsExplainOptionContext() {}

func NewExplainOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplainOptionContext {
	var p = new(ExplainOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_explainOption

	return p
}

func (s *ExplainOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplainOptionContext) CopyFrom(ctx *ExplainOptionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ExplainOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ExplainFormatContext struct {
	*ExplainOptionContext
	value antlr.Token
}

func NewExplainFormatContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExplainFormatContext {
	var p = new(ExplainFormatContext)

	p.ExplainOptionContext = NewEmptyExplainOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExplainOptionContext))

	return p
}

func (s *ExplainFormatContext) GetValue() antlr.Token { return s.value }

func (s *ExplainFormatContext) SetValue(v antlr.Token) { s.value = v }

func (s *ExplainFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainFormatContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFORMAT, 0)
}

func (s *ExplainFormatContext) TEXT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTEXT, 0)
}

func (s *ExplainFormatContext) GRAPHVIZ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGRAPHVIZ, 0)
}

func (s *ExplainFormatContext) JSON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserJSON, 0)
}

func (s *ExplainFormatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterExplainFormat(s)
	}
}

func (s *ExplainFormatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitExplainFormat(s)
	}
}

func (s *ExplainFormatContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitExplainFormat(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExplainTypeContext struct {
	*ExplainOptionContext
	value antlr.Token
}

func NewExplainTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExplainTypeContext {
	var p = new(ExplainTypeContext)

	p.ExplainOptionContext = NewEmptyExplainOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExplainOptionContext))

	return p
}

func (s *ExplainTypeContext) GetValue() antlr.Token { return s.value }

func (s *ExplainTypeContext) SetValue(v antlr.Token) { s.value = v }

func (s *ExplainTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainTypeContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTYPE, 0)
}

func (s *ExplainTypeContext) LOGICAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLOGICAL, 0)
}

func (s *ExplainTypeContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDISTRIBUTED, 0)
}

func (s *ExplainTypeContext) VALIDATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVALIDATE, 0)
}

func (s *ExplainTypeContext) IO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIO, 0)
}

func (s *ExplainTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterExplainType(s)
	}
}

func (s *ExplainTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitExplainType(s)
	}
}

func (s *ExplainTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitExplainType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) ExplainOption() (localctx IExplainOptionContext) {
	localctx = NewExplainOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, SqlBaseParserRULE_explainOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1783)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserFORMAT:
		localctx = NewExplainFormatContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1779)
			p.Match(SqlBaseParserFORMAT)
		}
		{
			p.SetState(1780)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ExplainFormatContext).value = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserGRAPHVIZ || _la == SqlBaseParserJSON || _la == SqlBaseParserTEXT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ExplainFormatContext).value = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SqlBaseParserTYPE:
		localctx = NewExplainTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1781)
			p.Match(SqlBaseParserTYPE)
		}
		{
			p.SetState(1782)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ExplainTypeContext).value = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserDISTRIBUTED || _la == SqlBaseParserIO || _la == SqlBaseParserLOGICAL || _la == SqlBaseParserVALIDATE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ExplainTypeContext).value = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITransactionModeContext is an interface to support dynamic dispatch.
type ITransactionModeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTransactionModeContext differentiates from other interfaces.
	IsTransactionModeContext()
}

type TransactionModeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionModeContext() *TransactionModeContext {
	var p = new(TransactionModeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_transactionMode
	return p
}

func (*TransactionModeContext) IsTransactionModeContext() {}

func NewTransactionModeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionModeContext {
	var p = new(TransactionModeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_transactionMode

	return p
}

func (s *TransactionModeContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionModeContext) CopyFrom(ctx *TransactionModeContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *TransactionModeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionModeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TransactionAccessModeContext struct {
	*TransactionModeContext
	accessMode antlr.Token
}

func NewTransactionAccessModeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TransactionAccessModeContext {
	var p = new(TransactionAccessModeContext)

	p.TransactionModeContext = NewEmptyTransactionModeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TransactionModeContext))

	return p
}

func (s *TransactionAccessModeContext) GetAccessMode() antlr.Token { return s.accessMode }

func (s *TransactionAccessModeContext) SetAccessMode(v antlr.Token) { s.accessMode = v }

func (s *TransactionAccessModeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionAccessModeContext) READ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREAD, 0)
}

func (s *TransactionAccessModeContext) ONLY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserONLY, 0)
}

func (s *TransactionAccessModeContext) WRITE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWRITE, 0)
}

func (s *TransactionAccessModeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterTransactionAccessMode(s)
	}
}

func (s *TransactionAccessModeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitTransactionAccessMode(s)
	}
}

func (s *TransactionAccessModeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitTransactionAccessMode(s)

	default:
		return t.VisitChildren(s)
	}
}

type IsolationLevelContext struct {
	*TransactionModeContext
}

func NewIsolationLevelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IsolationLevelContext {
	var p = new(IsolationLevelContext)

	p.TransactionModeContext = NewEmptyTransactionModeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TransactionModeContext))

	return p
}

func (s *IsolationLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsolationLevelContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserISOLATION, 0)
}

func (s *IsolationLevelContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEVEL, 0)
}

func (s *IsolationLevelContext) LevelOfIsolation() ILevelOfIsolationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILevelOfIsolationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILevelOfIsolationContext)
}

func (s *IsolationLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterIsolationLevel(s)
	}
}

func (s *IsolationLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitIsolationLevel(s)
	}
}

func (s *IsolationLevelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitIsolationLevel(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) TransactionMode() (localctx ITransactionModeContext) {
	localctx = NewTransactionModeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, SqlBaseParserRULE_transactionMode)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1790)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserISOLATION:
		localctx = NewIsolationLevelContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1785)
			p.Match(SqlBaseParserISOLATION)
		}
		{
			p.SetState(1786)
			p.Match(SqlBaseParserLEVEL)
		}
		{
			p.SetState(1787)
			p.LevelOfIsolation()
		}

	case SqlBaseParserREAD:
		localctx = NewTransactionAccessModeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1788)
			p.Match(SqlBaseParserREAD)
		}
		{
			p.SetState(1789)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TransactionAccessModeContext).accessMode = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserONLY || _la == SqlBaseParserWRITE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TransactionAccessModeContext).accessMode = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILevelOfIsolationContext is an interface to support dynamic dispatch.
type ILevelOfIsolationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLevelOfIsolationContext differentiates from other interfaces.
	IsLevelOfIsolationContext()
}

type LevelOfIsolationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLevelOfIsolationContext() *LevelOfIsolationContext {
	var p = new(LevelOfIsolationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_levelOfIsolation
	return p
}

func (*LevelOfIsolationContext) IsLevelOfIsolationContext() {}

func NewLevelOfIsolationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LevelOfIsolationContext {
	var p = new(LevelOfIsolationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_levelOfIsolation

	return p
}

func (s *LevelOfIsolationContext) GetParser() antlr.Parser { return s.parser }

func (s *LevelOfIsolationContext) CopyFrom(ctx *LevelOfIsolationContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *LevelOfIsolationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LevelOfIsolationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ReadUncommittedContext struct {
	*LevelOfIsolationContext
}

func NewReadUncommittedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReadUncommittedContext {
	var p = new(ReadUncommittedContext)

	p.LevelOfIsolationContext = NewEmptyLevelOfIsolationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LevelOfIsolationContext))

	return p
}

func (s *ReadUncommittedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadUncommittedContext) READ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREAD, 0)
}

func (s *ReadUncommittedContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNCOMMITTED, 0)
}

func (s *ReadUncommittedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterReadUncommitted(s)
	}
}

func (s *ReadUncommittedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitReadUncommitted(s)
	}
}

func (s *ReadUncommittedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitReadUncommitted(s)

	default:
		return t.VisitChildren(s)
	}
}

type SerializableContext struct {
	*LevelOfIsolationContext
}

func NewSerializableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SerializableContext {
	var p = new(SerializableContext)

	p.LevelOfIsolationContext = NewEmptyLevelOfIsolationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LevelOfIsolationContext))

	return p
}

func (s *SerializableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SerializableContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSERIALIZABLE, 0)
}

func (s *SerializableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSerializable(s)
	}
}

func (s *SerializableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSerializable(s)
	}
}

func (s *SerializableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSerializable(s)

	default:
		return t.VisitChildren(s)
	}
}

type ReadCommittedContext struct {
	*LevelOfIsolationContext
}

func NewReadCommittedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReadCommittedContext {
	var p = new(ReadCommittedContext)

	p.LevelOfIsolationContext = NewEmptyLevelOfIsolationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LevelOfIsolationContext))

	return p
}

func (s *ReadCommittedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadCommittedContext) READ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREAD, 0)
}

func (s *ReadCommittedContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMITTED, 0)
}

func (s *ReadCommittedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterReadCommitted(s)
	}
}

func (s *ReadCommittedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitReadCommitted(s)
	}
}

func (s *ReadCommittedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitReadCommitted(s)

	default:
		return t.VisitChildren(s)
	}
}

type RepeatableReadContext struct {
	*LevelOfIsolationContext
}

func NewRepeatableReadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RepeatableReadContext {
	var p = new(RepeatableReadContext)

	p.LevelOfIsolationContext = NewEmptyLevelOfIsolationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LevelOfIsolationContext))

	return p
}

func (s *RepeatableReadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RepeatableReadContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREPEATABLE, 0)
}

func (s *RepeatableReadContext) READ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREAD, 0)
}

func (s *RepeatableReadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRepeatableRead(s)
	}
}

func (s *RepeatableReadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRepeatableRead(s)
	}
}

func (s *RepeatableReadContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitRepeatableRead(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) LevelOfIsolation() (localctx ILevelOfIsolationContext) {
	localctx = NewLevelOfIsolationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, SqlBaseParserRULE_levelOfIsolation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1799)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 229, p.GetParserRuleContext()) {
	case 1:
		localctx = NewReadUncommittedContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1792)
			p.Match(SqlBaseParserREAD)
		}
		{
			p.SetState(1793)
			p.Match(SqlBaseParserUNCOMMITTED)
		}

	case 2:
		localctx = NewReadCommittedContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1794)
			p.Match(SqlBaseParserREAD)
		}
		{
			p.SetState(1795)
			p.Match(SqlBaseParserCOMMITTED)
		}

	case 3:
		localctx = NewRepeatableReadContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1796)
			p.Match(SqlBaseParserREPEATABLE)
		}
		{
			p.SetState(1797)
			p.Match(SqlBaseParserREAD)
		}

	case 4:
		localctx = NewSerializableContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1798)
			p.Match(SqlBaseParserSERIALIZABLE)
		}

	}

	return localctx
}

// ICallArgumentContext is an interface to support dynamic dispatch.
type ICallArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallArgumentContext differentiates from other interfaces.
	IsCallArgumentContext()
}

type CallArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallArgumentContext() *CallArgumentContext {
	var p = new(CallArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_callArgument
	return p
}

func (*CallArgumentContext) IsCallArgumentContext() {}

func NewCallArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallArgumentContext {
	var p = new(CallArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_callArgument

	return p
}

func (s *CallArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *CallArgumentContext) CopyFrom(ctx *CallArgumentContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *CallArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PositionalArgumentContext struct {
	*CallArgumentContext
}

func NewPositionalArgumentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PositionalArgumentContext {
	var p = new(PositionalArgumentContext)

	p.CallArgumentContext = NewEmptyCallArgumentContext()
	p.parser = parser
	p.CopyFrom(ctx.(*CallArgumentContext))

	return p
}

func (s *PositionalArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PositionalArgumentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PositionalArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterPositionalArgument(s)
	}
}

func (s *PositionalArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitPositionalArgument(s)
	}
}

func (s *PositionalArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitPositionalArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

type NamedArgumentContext struct {
	*CallArgumentContext
}

func NewNamedArgumentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NamedArgumentContext {
	var p = new(NamedArgumentContext)

	p.CallArgumentContext = NewEmptyCallArgumentContext()
	p.parser = parser
	p.CopyFrom(ctx.(*CallArgumentContext))

	return p
}

func (s *NamedArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedArgumentContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NamedArgumentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NamedArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterNamedArgument(s)
	}
}

func (s *NamedArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitNamedArgument(s)
	}
}

func (s *NamedArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitNamedArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) CallArgument() (localctx ICallArgumentContext) {
	localctx = NewCallArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, SqlBaseParserRULE_callArgument)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1806)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 230, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPositionalArgumentContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1801)
			p.Expression()
		}

	case 2:
		localctx = NewNamedArgumentContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1802)
			p.Identifier()
		}
		{
			p.SetState(1803)
			p.Match(SqlBaseParserT__8)
		}
		{
			p.SetState(1804)
			p.Expression()
		}

	}

	return localctx
}

// IPrivilegeContext is an interface to support dynamic dispatch.
type IPrivilegeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrivilegeContext differentiates from other interfaces.
	IsPrivilegeContext()
}

type PrivilegeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegeContext() *PrivilegeContext {
	var p = new(PrivilegeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_privilege
	return p
}

func (*PrivilegeContext) IsPrivilegeContext() {}

func NewPrivilegeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeContext {
	var p = new(PrivilegeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_privilege

	return p
}

func (s *PrivilegeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeContext) SELECT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSELECT, 0)
}

func (s *PrivilegeContext) DELETE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDELETE, 0)
}

func (s *PrivilegeContext) INSERT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINSERT, 0)
}

func (s *PrivilegeContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterPrivilege(s)
	}
}

func (s *PrivilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitPrivilege(s)
	}
}

func (s *PrivilegeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitPrivilege(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) Privilege() (localctx IPrivilegeContext) {
	localctx = NewPrivilegeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, SqlBaseParserRULE_privilege)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1812)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserSELECT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1808)
			p.Match(SqlBaseParserSELECT)
		}

	case SqlBaseParserDELETE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1809)
			p.Match(SqlBaseParserDELETE)
		}

	case SqlBaseParserINSERT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1810)
			p.Match(SqlBaseParserINSERT)
		}

	case SqlBaseParserADD, SqlBaseParserADMIN, SqlBaseParserALL, SqlBaseParserANALYZE, SqlBaseParserANY, SqlBaseParserARRAY, SqlBaseParserASC, SqlBaseParserAT, SqlBaseParserBERNOULLI, SqlBaseParserCALL, SqlBaseParserCALLED, SqlBaseParserCASCADE, SqlBaseParserCATALOGS, SqlBaseParserCOLUMN, SqlBaseParserCOLUMNS, SqlBaseParserCOMMENT, SqlBaseParserCOMMIT, SqlBaseParserCOMMITTED, SqlBaseParserCURRENT, SqlBaseParserCURRENT_ROLE, SqlBaseParserDATA, SqlBaseParserDATE, SqlBaseParserDAY, SqlBaseParserDEFINER, SqlBaseParserDESC, SqlBaseParserDETERMINISTIC, SqlBaseParserDISTRIBUTED, SqlBaseParserEXCLUDING, SqlBaseParserEXPLAIN, SqlBaseParserEXTERNAL, SqlBaseParserFILTER, SqlBaseParserFIRST, SqlBaseParserFOLLOWING, SqlBaseParserFORMAT, SqlBaseParserFUNCTION, SqlBaseParserFUNCTIONS, SqlBaseParserGRANT, SqlBaseParserGRANTED, SqlBaseParserGRANTS, SqlBaseParserGRAPHVIZ, SqlBaseParserHOUR, SqlBaseParserIF, SqlBaseParserIGNORE, SqlBaseParserINCLUDING, SqlBaseParserINPUT, SqlBaseParserINTERVAL, SqlBaseParserINVOKER, SqlBaseParserIO, SqlBaseParserISOLATION, SqlBaseParserJSON, SqlBaseParserLANGUAGE, SqlBaseParserLAST, SqlBaseParserLATERAL, SqlBaseParserLEVEL, SqlBaseParserLIMIT, SqlBaseParserLOGICAL, SqlBaseParserMAP, SqlBaseParserMATERIALIZED, SqlBaseParserMINUTE, SqlBaseParserMONTH, SqlBaseParserNAME, SqlBaseParserNFC, SqlBaseParserNFD, SqlBaseParserNFKC, SqlBaseParserNFKD, SqlBaseParserNO, SqlBaseParserNONE, SqlBaseParserNULLIF, SqlBaseParserNULLS, SqlBaseParserOFFSET, SqlBaseParserONLY, SqlBaseParserOPTION, SqlBaseParserORDINALITY, SqlBaseParserOUTPUT, SqlBaseParserOVER, SqlBaseParserPARTITION, SqlBaseParserPARTITIONS, SqlBaseParserPOSITION, SqlBaseParserPRECEDING, SqlBaseParserPRIVILEGES, SqlBaseParserPROPERTIES, SqlBaseParserRANGE, SqlBaseParserREAD, SqlBaseParserREFRESH, SqlBaseParserRENAME, SqlBaseParserREPEATABLE, SqlBaseParserREPLACE, SqlBaseParserRESET, SqlBaseParserRESPECT, SqlBaseParserRESTRICT, SqlBaseParserRETURN, SqlBaseParserRETURNS, SqlBaseParserREVOKE, SqlBaseParserROLE, SqlBaseParserROLES, SqlBaseParserROLLBACK, SqlBaseParserROW, SqlBaseParserROWS, SqlBaseParserSCHEMA, SqlBaseParserSCHEMAS, SqlBaseParserSECOND, SqlBaseParserSECURITY, SqlBaseParserSERIALIZABLE, SqlBaseParserSESSION, SqlBaseParserSET, SqlBaseParserSETS, SqlBaseParserSHOW, SqlBaseParserSOME, SqlBaseParserSQL, SqlBaseParserSTART, SqlBaseParserSTATS, SqlBaseParserSUBSTRING, SqlBaseParserSYSTEM, SqlBaseParserTABLES, SqlBaseParserTABLESAMPLE, SqlBaseParserTEMPORARY, SqlBaseParserTEXT, SqlBaseParserTIME, SqlBaseParserTIMESTAMP, SqlBaseParserTO, SqlBaseParserTRANSACTION, SqlBaseParserTRY_CAST, SqlBaseParserTYPE, SqlBaseParserUNBOUNDED, SqlBaseParserUNCOMMITTED, SqlBaseParserUSE, SqlBaseParserUSER, SqlBaseParserVALIDATE, SqlBaseParserVERBOSE, SqlBaseParserVIEW, SqlBaseParserWORK, SqlBaseParserWRITE, SqlBaseParserYEAR, SqlBaseParserZONE, SqlBaseParserIDENTIFIER, SqlBaseParserDIGIT_IDENTIFIER, SqlBaseParserQUOTED_IDENTIFIER, SqlBaseParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1811)
			p.Identifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IQualifiedNameContext is an interface to support dynamic dispatch.
type IQualifiedNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedNameContext differentiates from other interfaces.
	IsQualifiedNameContext()
}

type QualifiedNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNameContext() *QualifiedNameContext {
	var p = new(QualifiedNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_qualifiedName
	return p
}

func (*QualifiedNameContext) IsQualifiedNameContext() {}

func NewQualifiedNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNameContext {
	var p = new(QualifiedNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_qualifiedName

	return p
}

func (s *QualifiedNameContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNameContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *QualifiedNameContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifiedNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterQualifiedName(s)
	}
}

func (s *QualifiedNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitQualifiedName(s)
	}
}

func (s *QualifiedNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitQualifiedName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) QualifiedName() (localctx IQualifiedNameContext) {
	localctx = NewQualifiedNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, SqlBaseParserRULE_qualifiedName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1814)
		p.Identifier()
	}
	p.SetState(1819)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 232, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1815)
				p.Match(SqlBaseParserT__0)
			}
			{
				p.SetState(1816)
				p.Identifier()
			}

		}
		p.SetState(1821)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 232, p.GetParserRuleContext())
	}

	return localctx
}

// IGrantorContext is an interface to support dynamic dispatch.
type IGrantorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGrantorContext differentiates from other interfaces.
	IsGrantorContext()
}

type GrantorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantorContext() *GrantorContext {
	var p = new(GrantorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_grantor
	return p
}

func (*GrantorContext) IsGrantorContext() {}

func NewGrantorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantorContext {
	var p = new(GrantorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_grantor

	return p
}

func (s *GrantorContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantorContext) CopyFrom(ctx *GrantorContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *GrantorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CurrentUserGrantorContext struct {
	*GrantorContext
}

func NewCurrentUserGrantorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentUserGrantorContext {
	var p = new(CurrentUserGrantorContext)

	p.GrantorContext = NewEmptyGrantorContext()
	p.parser = parser
	p.CopyFrom(ctx.(*GrantorContext))

	return p
}

func (s *CurrentUserGrantorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentUserGrantorContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT_USER, 0)
}

func (s *CurrentUserGrantorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCurrentUserGrantor(s)
	}
}

func (s *CurrentUserGrantorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCurrentUserGrantor(s)
	}
}

func (s *CurrentUserGrantorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitCurrentUserGrantor(s)

	default:
		return t.VisitChildren(s)
	}
}

type SpecifiedPrincipalContext struct {
	*GrantorContext
}

func NewSpecifiedPrincipalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpecifiedPrincipalContext {
	var p = new(SpecifiedPrincipalContext)

	p.GrantorContext = NewEmptyGrantorContext()
	p.parser = parser
	p.CopyFrom(ctx.(*GrantorContext))

	return p
}

func (s *SpecifiedPrincipalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecifiedPrincipalContext) Principal() IPrincipalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrincipalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrincipalContext)
}

func (s *SpecifiedPrincipalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSpecifiedPrincipal(s)
	}
}

func (s *SpecifiedPrincipalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSpecifiedPrincipal(s)
	}
}

func (s *SpecifiedPrincipalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitSpecifiedPrincipal(s)

	default:
		return t.VisitChildren(s)
	}
}

type CurrentRoleGrantorContext struct {
	*GrantorContext
}

func NewCurrentRoleGrantorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentRoleGrantorContext {
	var p = new(CurrentRoleGrantorContext)

	p.GrantorContext = NewEmptyGrantorContext()
	p.parser = parser
	p.CopyFrom(ctx.(*GrantorContext))

	return p
}

func (s *CurrentRoleGrantorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentRoleGrantorContext) CURRENT_ROLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT_ROLE, 0)
}

func (s *CurrentRoleGrantorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCurrentRoleGrantor(s)
	}
}

func (s *CurrentRoleGrantorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCurrentRoleGrantor(s)
	}
}

func (s *CurrentRoleGrantorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitCurrentRoleGrantor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) Grantor() (localctx IGrantorContext) {
	localctx = NewGrantorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, SqlBaseParserRULE_grantor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1825)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 233, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCurrentUserGrantorContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1822)
			p.Match(SqlBaseParserCURRENT_USER)
		}

	case 2:
		localctx = NewCurrentRoleGrantorContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1823)
			p.Match(SqlBaseParserCURRENT_ROLE)
		}

	case 3:
		localctx = NewSpecifiedPrincipalContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1824)
			p.Principal()
		}

	}

	return localctx
}

// IPrincipalContext is an interface to support dynamic dispatch.
type IPrincipalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrincipalContext differentiates from other interfaces.
	IsPrincipalContext()
}

type PrincipalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrincipalContext() *PrincipalContext {
	var p = new(PrincipalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_principal
	return p
}

func (*PrincipalContext) IsPrincipalContext() {}

func NewPrincipalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrincipalContext {
	var p = new(PrincipalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_principal

	return p
}

func (s *PrincipalContext) GetParser() antlr.Parser { return s.parser }

func (s *PrincipalContext) CopyFrom(ctx *PrincipalContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *PrincipalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrincipalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UnspecifiedPrincipalContext struct {
	*PrincipalContext
}

func NewUnspecifiedPrincipalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnspecifiedPrincipalContext {
	var p = new(UnspecifiedPrincipalContext)

	p.PrincipalContext = NewEmptyPrincipalContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrincipalContext))

	return p
}

func (s *UnspecifiedPrincipalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnspecifiedPrincipalContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnspecifiedPrincipalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterUnspecifiedPrincipal(s)
	}
}

func (s *UnspecifiedPrincipalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitUnspecifiedPrincipal(s)
	}
}

func (s *UnspecifiedPrincipalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitUnspecifiedPrincipal(s)

	default:
		return t.VisitChildren(s)
	}
}

type UserPrincipalContext struct {
	*PrincipalContext
}

func NewUserPrincipalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UserPrincipalContext {
	var p = new(UserPrincipalContext)

	p.PrincipalContext = NewEmptyPrincipalContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrincipalContext))

	return p
}

func (s *UserPrincipalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserPrincipalContext) USER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUSER, 0)
}

func (s *UserPrincipalContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UserPrincipalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterUserPrincipal(s)
	}
}

func (s *UserPrincipalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitUserPrincipal(s)
	}
}

func (s *UserPrincipalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitUserPrincipal(s)

	default:
		return t.VisitChildren(s)
	}
}

type RolePrincipalContext struct {
	*PrincipalContext
}

func NewRolePrincipalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RolePrincipalContext {
	var p = new(RolePrincipalContext)

	p.PrincipalContext = NewEmptyPrincipalContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrincipalContext))

	return p
}

func (s *RolePrincipalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RolePrincipalContext) ROLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLE, 0)
}

func (s *RolePrincipalContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RolePrincipalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRolePrincipal(s)
	}
}

func (s *RolePrincipalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRolePrincipal(s)
	}
}

func (s *RolePrincipalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitRolePrincipal(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) Principal() (localctx IPrincipalContext) {
	localctx = NewPrincipalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, SqlBaseParserRULE_principal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1832)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 234, p.GetParserRuleContext()) {
	case 1:
		localctx = NewUserPrincipalContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1827)
			p.Match(SqlBaseParserUSER)
		}
		{
			p.SetState(1828)
			p.Identifier()
		}

	case 2:
		localctx = NewRolePrincipalContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1829)
			p.Match(SqlBaseParserROLE)
		}
		{
			p.SetState(1830)
			p.Identifier()
		}

	case 3:
		localctx = NewUnspecifiedPrincipalContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1831)
			p.Identifier()
		}

	}

	return localctx
}

// IRolesContext is an interface to support dynamic dispatch.
type IRolesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRolesContext differentiates from other interfaces.
	IsRolesContext()
}

type RolesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRolesContext() *RolesContext {
	var p = new(RolesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_roles
	return p
}

func (*RolesContext) IsRolesContext() {}

func NewRolesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RolesContext {
	var p = new(RolesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_roles

	return p
}

func (s *RolesContext) GetParser() antlr.Parser { return s.parser }

func (s *RolesContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *RolesContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RolesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RolesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RolesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRoles(s)
	}
}

func (s *RolesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRoles(s)
	}
}

func (s *RolesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitRoles(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) Roles() (localctx IRolesContext) {
	localctx = NewRolesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, SqlBaseParserRULE_roles)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1834)
		p.Identifier()
	}
	p.SetState(1839)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserT__3 {
		{
			p.SetState(1835)
			p.Match(SqlBaseParserT__3)
		}
		{
			p.SetState(1836)
			p.Identifier()
		}

		p.SetState(1841)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) CopyFrom(ctx *IdentifierContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BackQuotedIdentifierContext struct {
	*IdentifierContext
}

func NewBackQuotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BackQuotedIdentifierContext {
	var p = new(BackQuotedIdentifierContext)

	p.IdentifierContext = NewEmptyIdentifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IdentifierContext))

	return p
}

func (s *BackQuotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackQuotedIdentifierContext) BACKQUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBACKQUOTED_IDENTIFIER, 0)
}

func (s *BackQuotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterBackQuotedIdentifier(s)
	}
}

func (s *BackQuotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitBackQuotedIdentifier(s)
	}
}

func (s *BackQuotedIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitBackQuotedIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

type QuotedIdentifierContext struct {
	*IdentifierContext
}

func NewQuotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QuotedIdentifierContext {
	var p = new(QuotedIdentifierContext)

	p.IdentifierContext = NewEmptyIdentifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IdentifierContext))

	return p
}

func (s *QuotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedIdentifierContext) QUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserQUOTED_IDENTIFIER, 0)
}

func (s *QuotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterQuotedIdentifier(s)
	}
}

func (s *QuotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitQuotedIdentifier(s)
	}
}

func (s *QuotedIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitQuotedIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

type DigitIdentifierContext struct {
	*IdentifierContext
}

func NewDigitIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DigitIdentifierContext {
	var p = new(DigitIdentifierContext)

	p.IdentifierContext = NewEmptyIdentifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IdentifierContext))

	return p
}

func (s *DigitIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DigitIdentifierContext) DIGIT_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDIGIT_IDENTIFIER, 0)
}

func (s *DigitIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDigitIdentifier(s)
	}
}

func (s *DigitIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDigitIdentifier(s)
	}
}

func (s *DigitIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitDigitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnquotedIdentifierContext struct {
	*IdentifierContext
}

func NewUnquotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnquotedIdentifierContext {
	var p = new(UnquotedIdentifierContext)

	p.IdentifierContext = NewEmptyIdentifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IdentifierContext))

	return p
}

func (s *UnquotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnquotedIdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIDENTIFIER, 0)
}

func (s *UnquotedIdentifierContext) NonReserved() INonReservedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INonReservedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INonReservedContext)
}

func (s *UnquotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterUnquotedIdentifier(s)
	}
}

func (s *UnquotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitUnquotedIdentifier(s)
	}
}

func (s *UnquotedIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitUnquotedIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, SqlBaseParserRULE_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1847)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserIDENTIFIER:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1842)
			p.Match(SqlBaseParserIDENTIFIER)
		}

	case SqlBaseParserQUOTED_IDENTIFIER:
		localctx = NewQuotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1843)
			p.Match(SqlBaseParserQUOTED_IDENTIFIER)
		}

	case SqlBaseParserADD, SqlBaseParserADMIN, SqlBaseParserALL, SqlBaseParserANALYZE, SqlBaseParserANY, SqlBaseParserARRAY, SqlBaseParserASC, SqlBaseParserAT, SqlBaseParserBERNOULLI, SqlBaseParserCALL, SqlBaseParserCALLED, SqlBaseParserCASCADE, SqlBaseParserCATALOGS, SqlBaseParserCOLUMN, SqlBaseParserCOLUMNS, SqlBaseParserCOMMENT, SqlBaseParserCOMMIT, SqlBaseParserCOMMITTED, SqlBaseParserCURRENT, SqlBaseParserCURRENT_ROLE, SqlBaseParserDATA, SqlBaseParserDATE, SqlBaseParserDAY, SqlBaseParserDEFINER, SqlBaseParserDESC, SqlBaseParserDETERMINISTIC, SqlBaseParserDISTRIBUTED, SqlBaseParserEXCLUDING, SqlBaseParserEXPLAIN, SqlBaseParserEXTERNAL, SqlBaseParserFILTER, SqlBaseParserFIRST, SqlBaseParserFOLLOWING, SqlBaseParserFORMAT, SqlBaseParserFUNCTION, SqlBaseParserFUNCTIONS, SqlBaseParserGRANT, SqlBaseParserGRANTED, SqlBaseParserGRANTS, SqlBaseParserGRAPHVIZ, SqlBaseParserHOUR, SqlBaseParserIF, SqlBaseParserIGNORE, SqlBaseParserINCLUDING, SqlBaseParserINPUT, SqlBaseParserINTERVAL, SqlBaseParserINVOKER, SqlBaseParserIO, SqlBaseParserISOLATION, SqlBaseParserJSON, SqlBaseParserLANGUAGE, SqlBaseParserLAST, SqlBaseParserLATERAL, SqlBaseParserLEVEL, SqlBaseParserLIMIT, SqlBaseParserLOGICAL, SqlBaseParserMAP, SqlBaseParserMATERIALIZED, SqlBaseParserMINUTE, SqlBaseParserMONTH, SqlBaseParserNAME, SqlBaseParserNFC, SqlBaseParserNFD, SqlBaseParserNFKC, SqlBaseParserNFKD, SqlBaseParserNO, SqlBaseParserNONE, SqlBaseParserNULLIF, SqlBaseParserNULLS, SqlBaseParserOFFSET, SqlBaseParserONLY, SqlBaseParserOPTION, SqlBaseParserORDINALITY, SqlBaseParserOUTPUT, SqlBaseParserOVER, SqlBaseParserPARTITION, SqlBaseParserPARTITIONS, SqlBaseParserPOSITION, SqlBaseParserPRECEDING, SqlBaseParserPRIVILEGES, SqlBaseParserPROPERTIES, SqlBaseParserRANGE, SqlBaseParserREAD, SqlBaseParserREFRESH, SqlBaseParserRENAME, SqlBaseParserREPEATABLE, SqlBaseParserREPLACE, SqlBaseParserRESET, SqlBaseParserRESPECT, SqlBaseParserRESTRICT, SqlBaseParserRETURN, SqlBaseParserRETURNS, SqlBaseParserREVOKE, SqlBaseParserROLE, SqlBaseParserROLES, SqlBaseParserROLLBACK, SqlBaseParserROW, SqlBaseParserROWS, SqlBaseParserSCHEMA, SqlBaseParserSCHEMAS, SqlBaseParserSECOND, SqlBaseParserSECURITY, SqlBaseParserSERIALIZABLE, SqlBaseParserSESSION, SqlBaseParserSET, SqlBaseParserSETS, SqlBaseParserSHOW, SqlBaseParserSOME, SqlBaseParserSQL, SqlBaseParserSTART, SqlBaseParserSTATS, SqlBaseParserSUBSTRING, SqlBaseParserSYSTEM, SqlBaseParserTABLES, SqlBaseParserTABLESAMPLE, SqlBaseParserTEMPORARY, SqlBaseParserTEXT, SqlBaseParserTIME, SqlBaseParserTIMESTAMP, SqlBaseParserTO, SqlBaseParserTRANSACTION, SqlBaseParserTRY_CAST, SqlBaseParserTYPE, SqlBaseParserUNBOUNDED, SqlBaseParserUNCOMMITTED, SqlBaseParserUSE, SqlBaseParserUSER, SqlBaseParserVALIDATE, SqlBaseParserVERBOSE, SqlBaseParserVIEW, SqlBaseParserWORK, SqlBaseParserWRITE, SqlBaseParserYEAR, SqlBaseParserZONE:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1844)
			p.NonReserved()
		}

	case SqlBaseParserBACKQUOTED_IDENTIFIER:
		localctx = NewBackQuotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1845)
			p.Match(SqlBaseParserBACKQUOTED_IDENTIFIER)
		}

	case SqlBaseParserDIGIT_IDENTIFIER:
		localctx = NewDigitIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1846)
			p.Match(SqlBaseParserDIGIT_IDENTIFIER)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_number
	return p
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) CopyFrom(ctx *NumberContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DecimalLiteralContext struct {
	*NumberContext
}

func NewDecimalLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)

	p.NumberContext = NewEmptyNumberContext()
	p.parser = parser
	p.CopyFrom(ctx.(*NumberContext))

	return p
}

func (s *DecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalLiteralContext) DECIMAL_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDECIMAL_VALUE, 0)
}

func (s *DecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDecimalLiteral(s)
	}
}

func (s *DecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDecimalLiteral(s)
	}
}

func (s *DecimalLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitDecimalLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type DoubleLiteralContext struct {
	*NumberContext
}

func NewDoubleLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DoubleLiteralContext {
	var p = new(DoubleLiteralContext)

	p.NumberContext = NewEmptyNumberContext()
	p.parser = parser
	p.CopyFrom(ctx.(*NumberContext))

	return p
}

func (s *DoubleLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoubleLiteralContext) DOUBLE_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDOUBLE_VALUE, 0)
}

func (s *DoubleLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDoubleLiteral(s)
	}
}

func (s *DoubleLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDoubleLiteral(s)
	}
}

func (s *DoubleLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitDoubleLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type IntegerLiteralContext struct {
	*NumberContext
}

func NewIntegerLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntegerLiteralContext {
	var p = new(IntegerLiteralContext)

	p.NumberContext = NewEmptyNumberContext()
	p.parser = parser
	p.CopyFrom(ctx.(*NumberContext))

	return p
}

func (s *IntegerLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerLiteralContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTEGER_VALUE, 0)
}

func (s *IntegerLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterIntegerLiteral(s)
	}
}

func (s *IntegerLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitIntegerLiteral(s)
	}
}

func (s *IntegerLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitIntegerLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) Number() (localctx INumberContext) {
	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, SqlBaseParserRULE_number)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1852)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserDECIMAL_VALUE:
		localctx = NewDecimalLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1849)
			p.Match(SqlBaseParserDECIMAL_VALUE)
		}

	case SqlBaseParserDOUBLE_VALUE:
		localctx = NewDoubleLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1850)
			p.Match(SqlBaseParserDOUBLE_VALUE)
		}

	case SqlBaseParserINTEGER_VALUE:
		localctx = NewIntegerLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1851)
			p.Match(SqlBaseParserINTEGER_VALUE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INonReservedContext is an interface to support dynamic dispatch.
type INonReservedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNonReservedContext differentiates from other interfaces.
	IsNonReservedContext()
}

type NonReservedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonReservedContext() *NonReservedContext {
	var p = new(NonReservedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBaseParserRULE_nonReserved
	return p
}

func (*NonReservedContext) IsNonReservedContext() {}

func NewNonReservedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonReservedContext {
	var p = new(NonReservedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_nonReserved

	return p
}

func (s *NonReservedContext) GetParser() antlr.Parser { return s.parser }

func (s *NonReservedContext) ADD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserADD, 0)
}

func (s *NonReservedContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserADMIN, 0)
}

func (s *NonReservedContext) ALL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALL, 0)
}

func (s *NonReservedContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserANALYZE, 0)
}

func (s *NonReservedContext) ANY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserANY, 0)
}

func (s *NonReservedContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserARRAY, 0)
}

func (s *NonReservedContext) ASC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserASC, 0)
}

func (s *NonReservedContext) AT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAT, 0)
}

func (s *NonReservedContext) BERNOULLI() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBERNOULLI, 0)
}

func (s *NonReservedContext) CALL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCALL, 0)
}

func (s *NonReservedContext) CALLED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCALLED, 0)
}

func (s *NonReservedContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCASCADE, 0)
}

func (s *NonReservedContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCATALOGS, 0)
}

func (s *NonReservedContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLUMN, 0)
}

func (s *NonReservedContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLUMNS, 0)
}

func (s *NonReservedContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMENT, 0)
}

func (s *NonReservedContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMIT, 0)
}

func (s *NonReservedContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMITTED, 0)
}

func (s *NonReservedContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT, 0)
}

func (s *NonReservedContext) CURRENT_ROLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT_ROLE, 0)
}

func (s *NonReservedContext) DATA() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATA, 0)
}

func (s *NonReservedContext) DATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATE, 0)
}

func (s *NonReservedContext) DAY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDAY, 0)
}

func (s *NonReservedContext) DEFINER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDEFINER, 0)
}

func (s *NonReservedContext) DESC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDESC, 0)
}

func (s *NonReservedContext) DETERMINISTIC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDETERMINISTIC, 0)
}

func (s *NonReservedContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDISTRIBUTED, 0)
}

func (s *NonReservedContext) EXCLUDING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXCLUDING, 0)
}

func (s *NonReservedContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXPLAIN, 0)
}

func (s *NonReservedContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXTERNAL, 0)
}

func (s *NonReservedContext) FILTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFILTER, 0)
}

func (s *NonReservedContext) FIRST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFIRST, 0)
}

func (s *NonReservedContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOLLOWING, 0)
}

func (s *NonReservedContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFORMAT, 0)
}

func (s *NonReservedContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFUNCTION, 0)
}

func (s *NonReservedContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFUNCTIONS, 0)
}

func (s *NonReservedContext) GRANT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGRANT, 0)
}

func (s *NonReservedContext) GRANTED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGRANTED, 0)
}

func (s *NonReservedContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGRANTS, 0)
}

func (s *NonReservedContext) GRAPHVIZ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGRAPHVIZ, 0)
}

func (s *NonReservedContext) HOUR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserHOUR, 0)
}

func (s *NonReservedContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *NonReservedContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIGNORE, 0)
}

func (s *NonReservedContext) INCLUDING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINCLUDING, 0)
}

func (s *NonReservedContext) INPUT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINPUT, 0)
}

func (s *NonReservedContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTERVAL, 0)
}

func (s *NonReservedContext) INVOKER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINVOKER, 0)
}

func (s *NonReservedContext) IO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIO, 0)
}

func (s *NonReservedContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserISOLATION, 0)
}

func (s *NonReservedContext) JSON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserJSON, 0)
}

func (s *NonReservedContext) LANGUAGE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLANGUAGE, 0)
}

func (s *NonReservedContext) LAST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLAST, 0)
}

func (s *NonReservedContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLATERAL, 0)
}

func (s *NonReservedContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEVEL, 0)
}

func (s *NonReservedContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIMIT, 0)
}

func (s *NonReservedContext) LOGICAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLOGICAL, 0)
}

func (s *NonReservedContext) MAP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMAP, 0)
}

func (s *NonReservedContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMATERIALIZED, 0)
}

func (s *NonReservedContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUTE, 0)
}

func (s *NonReservedContext) MONTH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMONTH, 0)
}

func (s *NonReservedContext) NAME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNAME, 0)
}

func (s *NonReservedContext) NFC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNFC, 0)
}

func (s *NonReservedContext) NFD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNFD, 0)
}

func (s *NonReservedContext) NFKC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNFKC, 0)
}

func (s *NonReservedContext) NFKD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNFKD, 0)
}

func (s *NonReservedContext) NO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNO, 0)
}

func (s *NonReservedContext) NONE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNONE, 0)
}

func (s *NonReservedContext) NULLIF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULLIF, 0)
}

func (s *NonReservedContext) NULLS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULLS, 0)
}

func (s *NonReservedContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOFFSET, 0)
}

func (s *NonReservedContext) ONLY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserONLY, 0)
}

func (s *NonReservedContext) OPTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOPTION, 0)
}

func (s *NonReservedContext) ORDINALITY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserORDINALITY, 0)
}

func (s *NonReservedContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOUTPUT, 0)
}

func (s *NonReservedContext) OVER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOVER, 0)
}

func (s *NonReservedContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPARTITION, 0)
}

func (s *NonReservedContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPARTITIONS, 0)
}

func (s *NonReservedContext) POSITION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPOSITION, 0)
}

func (s *NonReservedContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPRECEDING, 0)
}

func (s *NonReservedContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPRIVILEGES, 0)
}

func (s *NonReservedContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPROPERTIES, 0)
}

func (s *NonReservedContext) RANGE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRANGE, 0)
}

func (s *NonReservedContext) READ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREAD, 0)
}

func (s *NonReservedContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREFRESH, 0)
}

func (s *NonReservedContext) RENAME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRENAME, 0)
}

func (s *NonReservedContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREPEATABLE, 0)
}

func (s *NonReservedContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREPLACE, 0)
}

func (s *NonReservedContext) RESET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRESET, 0)
}

func (s *NonReservedContext) RESPECT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRESPECT, 0)
}

func (s *NonReservedContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRESTRICT, 0)
}

func (s *NonReservedContext) RETURN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRETURN, 0)
}

func (s *NonReservedContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRETURNS, 0)
}

func (s *NonReservedContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREVOKE, 0)
}

func (s *NonReservedContext) ROLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLE, 0)
}

func (s *NonReservedContext) ROLES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLES, 0)
}

func (s *NonReservedContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLLBACK, 0)
}

func (s *NonReservedContext) ROW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROW, 0)
}

func (s *NonReservedContext) ROWS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROWS, 0)
}

func (s *NonReservedContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSCHEMA, 0)
}

func (s *NonReservedContext) SCHEMAS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSCHEMAS, 0)
}

func (s *NonReservedContext) SECOND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSECOND, 0)
}

func (s *NonReservedContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSECURITY, 0)
}

func (s *NonReservedContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSERIALIZABLE, 0)
}

func (s *NonReservedContext) SESSION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSESSION, 0)
}

func (s *NonReservedContext) SET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSET, 0)
}

func (s *NonReservedContext) SETS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSETS, 0)
}

func (s *NonReservedContext) SQL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSQL, 0)
}

func (s *NonReservedContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *NonReservedContext) SOME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSOME, 0)
}

func (s *NonReservedContext) START() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTART, 0)
}

func (s *NonReservedContext) STATS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTATS, 0)
}

func (s *NonReservedContext) SUBSTRING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSUBSTRING, 0)
}

func (s *NonReservedContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSYSTEM, 0)
}

func (s *NonReservedContext) TABLES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLES, 0)
}

func (s *NonReservedContext) TABLESAMPLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLESAMPLE, 0)
}

func (s *NonReservedContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTEMPORARY, 0)
}

func (s *NonReservedContext) TEXT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTEXT, 0)
}

func (s *NonReservedContext) TIME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIME, 0)
}

func (s *NonReservedContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIMESTAMP, 0)
}

func (s *NonReservedContext) TO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTO, 0)
}

func (s *NonReservedContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRANSACTION, 0)
}

func (s *NonReservedContext) TRY_CAST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRY_CAST, 0)
}

func (s *NonReservedContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTYPE, 0)
}

func (s *NonReservedContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNBOUNDED, 0)
}

func (s *NonReservedContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNCOMMITTED, 0)
}

func (s *NonReservedContext) USE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUSE, 0)
}

func (s *NonReservedContext) USER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUSER, 0)
}

func (s *NonReservedContext) VALIDATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVALIDATE, 0)
}

func (s *NonReservedContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVERBOSE, 0)
}

func (s *NonReservedContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVIEW, 0)
}

func (s *NonReservedContext) WORK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWORK, 0)
}

func (s *NonReservedContext) WRITE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWRITE, 0)
}

func (s *NonReservedContext) YEAR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserYEAR, 0)
}

func (s *NonReservedContext) ZONE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserZONE, 0)
}

func (s *NonReservedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonReservedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonReservedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterNonReserved(s)
	}
}

func (s *NonReservedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitNonReserved(s)
	}
}

func (s *NonReservedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SqlBaseVisitor:
		return t.VisitNonReserved(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SqlBaseParser) NonReserved() (localctx INonReservedContext) {
	localctx = NewNonReservedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, SqlBaseParserRULE_nonReserved)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1854)
		_la = p.GetTokenStream().LA(1)

		if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SqlBaseParserADD)|(1<<SqlBaseParserADMIN)|(1<<SqlBaseParserALL)|(1<<SqlBaseParserANALYZE)|(1<<SqlBaseParserANY)|(1<<SqlBaseParserARRAY)|(1<<SqlBaseParserASC)|(1<<SqlBaseParserAT)|(1<<SqlBaseParserBERNOULLI)|(1<<SqlBaseParserCALL)|(1<<SqlBaseParserCALLED)|(1<<SqlBaseParserCASCADE)|(1<<SqlBaseParserCATALOGS)|(1<<SqlBaseParserCOLUMN)|(1<<SqlBaseParserCOLUMNS))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(SqlBaseParserCOMMENT-32))|(1<<(SqlBaseParserCOMMIT-32))|(1<<(SqlBaseParserCOMMITTED-32))|(1<<(SqlBaseParserCURRENT-32))|(1<<(SqlBaseParserCURRENT_ROLE-32))|(1<<(SqlBaseParserDATA-32))|(1<<(SqlBaseParserDATE-32))|(1<<(SqlBaseParserDAY-32))|(1<<(SqlBaseParserDEFINER-32))|(1<<(SqlBaseParserDESC-32))|(1<<(SqlBaseParserDETERMINISTIC-32))|(1<<(SqlBaseParserDISTRIBUTED-32))|(1<<(SqlBaseParserEXCLUDING-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(SqlBaseParserEXPLAIN-64))|(1<<(SqlBaseParserEXTERNAL-64))|(1<<(SqlBaseParserFILTER-64))|(1<<(SqlBaseParserFIRST-64))|(1<<(SqlBaseParserFOLLOWING-64))|(1<<(SqlBaseParserFORMAT-64))|(1<<(SqlBaseParserFUNCTION-64))|(1<<(SqlBaseParserFUNCTIONS-64))|(1<<(SqlBaseParserGRANT-64))|(1<<(SqlBaseParserGRANTED-64))|(1<<(SqlBaseParserGRANTS-64))|(1<<(SqlBaseParserGRAPHVIZ-64))|(1<<(SqlBaseParserHOUR-64))|(1<<(SqlBaseParserIF-64))|(1<<(SqlBaseParserIGNORE-64))|(1<<(SqlBaseParserINCLUDING-64))|(1<<(SqlBaseParserINPUT-64))|(1<<(SqlBaseParserINTERVAL-64))|(1<<(SqlBaseParserINVOKER-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(SqlBaseParserIO-96))|(1<<(SqlBaseParserISOLATION-96))|(1<<(SqlBaseParserJSON-96))|(1<<(SqlBaseParserLANGUAGE-96))|(1<<(SqlBaseParserLAST-96))|(1<<(SqlBaseParserLATERAL-96))|(1<<(SqlBaseParserLEVEL-96))|(1<<(SqlBaseParserLIMIT-96))|(1<<(SqlBaseParserLOGICAL-96))|(1<<(SqlBaseParserMAP-96))|(1<<(SqlBaseParserMATERIALIZED-96))|(1<<(SqlBaseParserMINUTE-96))|(1<<(SqlBaseParserMONTH-96))|(1<<(SqlBaseParserNAME-96))|(1<<(SqlBaseParserNFC-96))|(1<<(SqlBaseParserNFD-96))|(1<<(SqlBaseParserNFKC-96))|(1<<(SqlBaseParserNFKD-96))|(1<<(SqlBaseParserNO-96))|(1<<(SqlBaseParserNONE-96))|(1<<(SqlBaseParserNULLIF-96))|(1<<(SqlBaseParserNULLS-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(SqlBaseParserOFFSET-128))|(1<<(SqlBaseParserONLY-128))|(1<<(SqlBaseParserOPTION-128))|(1<<(SqlBaseParserORDINALITY-128))|(1<<(SqlBaseParserOUTPUT-128))|(1<<(SqlBaseParserOVER-128))|(1<<(SqlBaseParserPARTITION-128))|(1<<(SqlBaseParserPARTITIONS-128))|(1<<(SqlBaseParserPOSITION-128))|(1<<(SqlBaseParserPRECEDING-128))|(1<<(SqlBaseParserPRIVILEGES-128))|(1<<(SqlBaseParserPROPERTIES-128))|(1<<(SqlBaseParserRANGE-128))|(1<<(SqlBaseParserREAD-128))|(1<<(SqlBaseParserREFRESH-128))|(1<<(SqlBaseParserRENAME-128))|(1<<(SqlBaseParserREPEATABLE-128))|(1<<(SqlBaseParserREPLACE-128))|(1<<(SqlBaseParserRESET-128))|(1<<(SqlBaseParserRESPECT-128))|(1<<(SqlBaseParserRESTRICT-128))|(1<<(SqlBaseParserRETURN-128))|(1<<(SqlBaseParserRETURNS-128))|(1<<(SqlBaseParserREVOKE-128))|(1<<(SqlBaseParserROLE-128)))) != 0) || (((_la-160)&-(0x1f+1)) == 0 && ((1<<uint((_la-160)))&((1<<(SqlBaseParserROLES-160))|(1<<(SqlBaseParserROLLBACK-160))|(1<<(SqlBaseParserROW-160))|(1<<(SqlBaseParserROWS-160))|(1<<(SqlBaseParserSCHEMA-160))|(1<<(SqlBaseParserSCHEMAS-160))|(1<<(SqlBaseParserSECOND-160))|(1<<(SqlBaseParserSECURITY-160))|(1<<(SqlBaseParserSERIALIZABLE-160))|(1<<(SqlBaseParserSESSION-160))|(1<<(SqlBaseParserSET-160))|(1<<(SqlBaseParserSETS-160))|(1<<(SqlBaseParserSHOW-160))|(1<<(SqlBaseParserSOME-160))|(1<<(SqlBaseParserSQL-160))|(1<<(SqlBaseParserSTART-160))|(1<<(SqlBaseParserSTATS-160))|(1<<(SqlBaseParserSUBSTRING-160))|(1<<(SqlBaseParserSYSTEM-160))|(1<<(SqlBaseParserTABLES-160))|(1<<(SqlBaseParserTABLESAMPLE-160))|(1<<(SqlBaseParserTEMPORARY-160))|(1<<(SqlBaseParserTEXT-160))|(1<<(SqlBaseParserTIME-160))|(1<<(SqlBaseParserTIMESTAMP-160))|(1<<(SqlBaseParserTO-160))|(1<<(SqlBaseParserTRANSACTION-160)))) != 0) || (((_la-192)&-(0x1f+1)) == 0 && ((1<<uint((_la-192)))&((1<<(SqlBaseParserTRY_CAST-192))|(1<<(SqlBaseParserTYPE-192))|(1<<(SqlBaseParserUNBOUNDED-192))|(1<<(SqlBaseParserUNCOMMITTED-192))|(1<<(SqlBaseParserUSE-192))|(1<<(SqlBaseParserUSER-192))|(1<<(SqlBaseParserVALIDATE-192))|(1<<(SqlBaseParserVERBOSE-192))|(1<<(SqlBaseParserVIEW-192))|(1<<(SqlBaseParserWORK-192))|(1<<(SqlBaseParserWRITE-192))|(1<<(SqlBaseParserYEAR-192))|(1<<(SqlBaseParserZONE-192)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

func (p *SqlBaseParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 24:
		var t *QueryTermContext = nil
		if localctx != nil {
			t = localctx.(*QueryTermContext)
		}
		return p.QueryTerm_Sempred(t, predIndex)

	case 34:
		var t *RelationContext = nil
		if localctx != nil {
			t = localctx.(*RelationContext)
		}
		return p.Relation_Sempred(t, predIndex)

	case 43:
		var t *BooleanExpressionContext = nil
		if localctx != nil {
			t = localctx.(*BooleanExpressionContext)
		}
		return p.BooleanExpression_Sempred(t, predIndex)

	case 45:
		var t *ValueExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ValueExpressionContext)
		}
		return p.ValueExpression_Sempred(t, predIndex)

	case 46:
		var t *PrimaryExpressionContext = nil
		if localctx != nil {
			t = localctx.(*PrimaryExpressionContext)
		}
		return p.PrimaryExpression_Sempred(t, predIndex)

	case 57:
		var t *Type_Context = nil
		if localctx != nil {
			t = localctx.(*Type_Context)
		}
		return p.Type__Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *SqlBaseParser) QueryTerm_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SqlBaseParser) Relation_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SqlBaseParser) BooleanExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SqlBaseParser) ValueExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 5:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 1)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 5)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SqlBaseParser) PrimaryExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 9:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 12)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SqlBaseParser) Type__Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 11:
		return p.Precpred(p.GetParserRuleContext(), 6)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
